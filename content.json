{"meta":{"title":"LawrenceSivan","subtitle":"I was so much older then, I'm younger than that now.","description":"SJZEZOIer，CUBer","author":"LawrenceSivan","url":"https://lawrencesivan.github.io","root":"/"},"pages":[{"title":"bangumi","text":"","path":"bangumi/index.html","date":"05-27","excerpt":""},{"title":"about","text":"LawrenceSivan'page 与&nbsp; LawrenceSivan&nbsp; （ ） 对话中... bot_ui_ini()","path":"about/index.html","date":"05-27","excerpt":""},{"title":"comment","text":"讲两句话 最怕你一生庸碌无为，却总安慰自己平凡可贵 皎月半洒花","path":"comment/index.html","date":"05-27","excerpt":""},{"title":"client","text":"暂时没有，先咕着","path":"client/index.html","date":"12-20","excerpt":""},{"title":"lab","text":"目前实验室是没有干任何事情的，以后可能会利用起来","path":"lab/index.html","date":"01-05","excerpt":""},{"title":"donate","text":"","path":"donate/index.html","date":"12-20","excerpt":""},{"title":"links","text":"","path":"links/index.html","date":"12-19","excerpt":""},{"title":"music","text":"","path":"music/index.html","date":"12-20","excerpt":""},{"title":"rss","text":"暂时没有，咕咕咕","path":"rss/index.html","date":"12-20","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"12-12","excerpt":""},{"title":"video","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","path":"video/index.html","date":"12-20","excerpt":""},{"title":"theme-sakura","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","path":"theme-sakura/index.html","date":"01-04","excerpt":""}],"posts":[{"title":"FFT快速傅里叶变换学习笔记","text":"FFT 快速傅里叶变换学习笔记前言考虑到时间及能力有限，并且诸位大佬写的学习笔记已经是十分详尽，本人目前不可能也不打算写一篇详细度超越各位先人的学习笔记，只是帮助自己理清思路，整理过程并且贯彻一些证明。 自然文章中会有诸多不妥之处，希望各位不吝赐教。 部分比较简单的前置知识就跳过了。 前置知识 复数基本知识 弧度制与三角函数 耐心稳定的心态 FFT 简述FFT（Fast Fourier Transformation），中文名是 “快速傅里叶离散变换”。 作用是：以 $\\mathcal{O(n\\log n)}$ 的时间复杂度计算多项式乘法。 在 OI 中的应用：利用卷积思想，化乘为加，加速多项式乘法计算。 卷积形如 $C[k]=\\sum\\limits_{i\\oplus j=k}A[i]B[j]$​ 的式子称为卷积。 多项式乘法就是加法卷积。 多项式的表示多项式指的是单项式相加组成的代数式。 多项式的系数表示每一项单项式都有其对应的系数，将系数提炼出来就得到了多项式的系数表示。 一般的，我们把一个 $n-1$ 次的 $n$ 项多项式表示为： $$f(x)=\\sum\\limits_{i=0}^{n-1}a_i x^i=a_0x^0+a_1x^1+a_2x^2…+a_{n-1}x^{n-1}$$ 系数表示即为： $$f(x)={a_0.a_1,a_2…a_{n-1}}$$​ 对于两个 $n$ 项多项式卷积，那么需要枚举每一对系数的乘积结果，复杂度 $\\mathcal{O(n^2)}$。 多项式的点值表示给定 $n+1$ 个互不相同的点，我们可以唯一确定一个 $n$ 次多项式函数。 可以使用 $n+1$ 个点值（有序数对）来描述一个多项式。 点值表示即为 ： $$f(x)={(x_0,f(x_0)),(x_1,f(x_1)),(x_2,f(x_2))…(x_n,f(x_n) )}$$​​ 进行乘法即为函数值相乘，复杂度 $\\mathcal{O(n)}$​。 点值表示远快于暴力卷积。 基本复数运算说是不讲复数，但是怎么样还是应该说一说。 复数相加为实部虚部对应相加。 相减同理。 相乘形式为： $$(a+bi)\\times (c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i$$​ 相除形式为： $$\\dfrac{a+bi}{c+di}=\\dfrac{(a+bi)(c-di)}{(c+di)(c-di)}=\\dfrac{(ac+bd)+(bc-ad)i}{c^2+d^2}=\\dfrac{ac+bd}{c^2+d^2}+\\dfrac{bc-ad}{c^2+d^2}$$​ 复数相乘还有一个几何意义：模相乘，角相加。 具体地，$(a_1,\\theta_1)(a_2,\\theta_2)=(a_1a_2,\\theta_1+\\theta_2)$​。 struct Complex&#123; double x,y; Complex()&#123;&#125; Complex(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;; inline Complex operator + (const Complex &amp;a)const&#123; return Complex(x+a.x,y+a.y); &#125; inline Complex operator - (const Complex &amp;a)const&#123; return Complex(x-a.x,y-a.y); &#125; inline Complex operator * (const Complex &amp;a)const&#123; return Complex(x*a.x-y*a.y,x*a.y+y*a.x); &#125; inline Complex operator / (const Complex &amp;a)const&#123; double tmp=a.x*a.x+a.y*a.y; return Complex((x*a.x+y*a.y)/tmp,(y*a.x-x*a.y)/tmp); &#125; &#125;f[maxn],p[maxn]; 单位根概述 $n$ 次单位根 $\\omega_n^k$ 是 $n$ 次幂为 $1$ 的复数，即方程 $x^n=1$ 的复数解。 单位根出现在复平面的单位圆上。 $n$ 次单位根 $n$​ 等分单位圆。 图片来自 @Aw顿顿 对于单位圆上的点，可以表示为 $\\cos \\theta+i \\sin \\theta$。 从 $1$ 开始，沿着单位圆逆时针给单位根标号： $\\omega_n^0=1,\\omega_n^1$是第二个为单位根… $\\omega_n^k=\\cos\\frac{k}{n}2\\pi+i\\sin\\frac{k}{n}2\\pi$​。 性质 $\\omega _n ^k=\\omega _n ^{k \\mod n}$​​​​​​ $\\omega _n^0=1$ $\\omega_n ^k=(\\omega_n^1)^k$ （$\\omega _n^k=\\omega _n^1\\times \\omega _n^1\\times \\omega _n^1…\\times \\omega _n^1$ 共 $k$ 个，可以理解为每次逆时针转动 $\\frac{1}{n}$ 个圆周，转了 $k$ 次。或者类比同底数幂相乘 ） $\\omega_n^j\\times \\omega_n^k =\\omega_n^{j+k}$​ $(\\omega _n^k)^{-1}=(\\omega_n^{-k})=(\\omega_n^{n-k})$ 可以倒过来反向回推： $\\omega_n^{n-k}\\times \\omega_n^k=\\omega_n^{n-k+k}=\\omega_n^n=\\omega_n^n=1$ 所以 $(\\omega _n^k)^{-1}=\\omega_n^{n-k}$ $(\\omega_n^k)^j=\\omega_n^{kj}$​ $\\omega_{pn}^{pk}=\\omega_n^k$ 想象成切蛋糕，多切了几刀，但是相应的多取了几倍。 如果 $n$ 是偶数，$\\omega_n^{(k+\\frac{n}{2})}=-\\omega_n^k$ $\\omega_n^{(k+\\frac{n}{2})}=\\omega_n^k\\times\\omega_n^{(\\frac{n}{2})}$ 对于 $\\omega_n^{(\\frac{n}{2})}$ ，可以理解为把幅角转动 $\\frac{1}{2}$ 个圆周，关于原点对称。 DFT 与 IDFT 概述把系数表示转化为点值表示的算法叫做 DFT； 把点值表示转化为系数表示的算法叫做 IDFT（或者称为 DFT 的逆运算） 从系数表示确定点值表示的过程叫做求值，从点值表示确定系数表示的过程叫做插值。 FFT 快速傅里叶变换FFT 是将系数表示转化为点值表示进行计算，之后再转化成系数表示。 主要过程分为了两步：系数表示转化为点值表示，点值表示转化为系数表示。 就是 DFT 和 IDFT 了。 不使用 FFT 直接进行朴素转化是 $\\mathcal{O(n^2)}$​ 的。 考虑更高效的方法。 DFT（系数表示转化成点值表示）设多项式: $$A(x)=\\sum\\limits_{i=0}^{n-1}a_i x^i=a_0x^0+a_1x^1+a_2x^2…+a_{n-1}x^{n-1}$$​ 按奇偶分类（分治思路）： $$A(x)=（a_0x^0+a_2x^2+a_4x^4…+a_{n-2}x^{n-2}）$$ $$+$$ $$（a_1x^1+a_3x^3+a_5x^5…+a_{n-1}x^{n-1}）$$​​​​ 两边统一次数，提出后面的 $x$： $$A(x)=（a_0+a_2x^2+a_4x^4…+a_{n-2}x^{n-2}）$$ $$+$$ $$x\\times（a_1+a_3x^2+a_5x^4…+a_{n-1}x^{n-2}）$$​ 设两个 $\\frac{n}{2}$ 项的多项式 $L(x)$ 和 $R(x)$ ，考虑降低 $A(x)$ 的次数，执行分治过程： $$L(x)=（a_0+a_2x^1+a_4x^2…+a_{n-2}x^{\\frac{n}{2}-1}）$$ $$R(x)=（a_1+a_3x^1+a_5x^2…+a_{n-1}x^{\\frac{n}{2}-1}）$$​​​​​​​​ 原式可以表示为 $A(x)=L(x^2)+x\\times R(x^2)$ 注意式子中需要带入 $x^2$ ，由于我们为了执行分治降低了次数，现在要保持式子不变。 之后考虑把单位根 $\\omega_n ^k$ 带入原式 $k&lt;\\frac{n}{2}$ ，代入 $\\omega_n^ k$ : $$A(\\omega_n^k)=L((\\omega_n^k)^2)+\\omega_n^k\\times R((\\omega_n^k)^2)$$​ 根据单位根性质 $7$ $\\omega_{pn}^{pk}=\\omega_n^k$: $$(\\omega_n^k)^2=(\\omega_n^{2k})=(\\omega_{\\frac{n}{2}}^{k})$$​ $$A(\\omega_n^k)=L(\\omega_{\\frac{n}{2}}^{k})+\\omega_n^k\\times R(\\omega_{\\frac{n}{2}}^{k})$$​​ $k&lt;\\frac{n}{2}$,代入 $\\omega_n^ {k+\\frac{n}{2}}$ $$A(\\omega_n^ {k+\\frac{n}{2}})=L((\\omega_n^ {k+\\frac{n}{2}})^2)+\\omega_n^ {k+\\frac{n}{2}}\\times R((\\omega_n^ {k+\\frac{n}{2}})^2)$$​ 由单位根的性质 $6$ $(\\omega_n^k)^j=\\omega_n^{kj}$​得： $$A(\\omega_n^ {k+\\frac{n}{2}})=L(\\omega_n^ {2k+n})+\\omega_n^ {k+\\frac{n}{2}}\\times R(\\omega _n^{2k+n})$$​ 由单位根的性质 $1$​​ $\\omega_n^k=\\omega_n^{k\\mod n}$​​ 得到： $$A(\\omega_n^ {k+\\frac{n}{2}})=L(\\omega_n^ {2k})+\\omega_n^ {k+\\frac{n}{2}}\\times R(\\omega _n^{2k})$$​ 由单位根的性质 $7$ $\\omega_{pn}^{pk}=\\omega_n^k$ 得到： $$A(\\omega_n^ {k+\\frac{n}{2}})=L(\\omega_{\\frac{n}{2}}^ {k})+\\omega_n^ {k+\\frac{n}{2}}\\times R(\\omega_{\\frac{n}{2}}^ {k})$$​ 由单位根的性质 $8$ $\\omega_n^{(k+\\frac{n}{2})}=-\\omega_n^k$ 得： $$A(\\omega_n^ {k+\\frac{n}{2}})=L(\\omega_{\\frac{n}{2}}^ {k})-\\omega_n^ {k}\\times R(\\omega_{\\frac{n}{2}}^ {k})$$​ 对比两个式子： ​ $$A(\\omega_n^k)=L(\\omega_{\\frac{n}{2}}^{k})+\\omega_n^k\\times R(\\omega_{\\frac{n}{2}}^{k})$$​​ ​ $$A(\\omega_n^ {k+\\frac{n}{2}})=L(\\omega_{\\frac{n}{2}}^ {k})-\\omega_n^ {k}\\times R(\\omega_{\\frac{n}{2}}^ {k})$$​ 发现右侧只有一个符号的差别。于是他们可以同步计算。 换句话说，FFT 就是把单位根上下半圆的部分分别带入 $A(x)=L(x^2)+x\\times R(x^2)$​ 于是我们在 $\\mathcal{O(n\\log n)}$ 时间复杂度内完成了系数表示转成点值表示的过程。 IDFT （点值表示转化成系数表示）由于代入时我们选择了单位根，现在我们十分方便地就可以完成 点值表示转化成系数表示。 首先写出结论：把 DFT 中的 $\\omega_n^1$ 换成 $\\omega_n^{-1}$ 做完之后除以 $n$​ 即可。 证明与单位根反演有关。 设 多项式 $A(x)$ 经过了 DFT 变换之后得到的点值数列为 $G$。 即 $G=DFT(A)$ 回忆代入的过程，可以得到： $G[k]=\\sum\\limits^{n-1}_{i=0}(\\omega_n^k)^iA[i]$​（含义是每一个点值都是把单位根代进每一项中乘以系数得到的） 结论是 $n\\times A[k]=\\sum\\limits^{n-1}_{i=0}(\\omega_n^{-k})^iG[i]$​ 证明： 把点值代入右边可以得到： $$\\sum\\limits _{i=0} ^{n-1}\\left( (\\omega_n^{-k})G[i] \\right)=\\sum\\limits _{i=0}^{n-1}\\left( \\left( \\sum\\limits^{n-1}_{j=0}(\\omega_n^i)^jA[j] \\right) \\times(\\omega_n^{-k})^i \\right)$$​​​​​ 化简得到： $$\\sum\\limits^{n-1}_{i=0}\\left( (\\omega_n^{-k})G[i] \\right)=\\sum\\limits^{n-1}_{i=0}\\left( \\sum\\limits^{n-1}_{j=0}(\\omega_n^{i(j-k)})A[j] \\right)$$​​ 分类讨论： $j=k$ 贡献是 $$\\sum\\limits^{n-1}_{i=0} \\sum\\limits^{n-1}_{j=0}(\\omega_n^{i(j-k)})A[j] \\times[j==k]$$​​​ $$=\\sum\\limits^{n-1}_{i=0}\\omega_n^{i(k-k)}A[k]$$​​​ $$=\\sum\\limits^{n-1}_{i=0}A[k]$$​​ $$=n\\times A[k]$$ $j\\ne k$ 设 $p=j-k$ 贡献就是 $$\\sum\\limits_{i=0}^{n-1}\\omega_n^{ip}A[k+p]$$​​ $$=\\omega_n^p\\left(\\sum\\limits_{i=0}^{n-1}\\omega_n^{i}\\right)A[k+p]$$​​ 等比数列求和得到： $$\\left(\\sum\\limits_{i=0}^{n-1}\\omega_n^{i}\\right)=\\frac{1-\\omega_n^{np}}{1-\\omega_n^{p}}=\\frac{1-\\omega_n^{0}}{1-\\omega_n^{p}}=0$$​ 所以这一部分贡献是 $0$。 证毕。 于是把 $G$ 数列当作系数再代入一遍，单位根换成所谓的 $\\omega _n^{-1}$ 就行了。 代码实现有了上述思路，我们就可以开始着手代码实现了。 补充 $n$ 至 $2$ 的整次幂。 我们上面的过程都是针对 $n$ 是 $2$ 的整次幂进行的，原因是这样可以保证分的足够均匀。 实际中不满足这个条件？补项就行了。在最高次强行添加系数为 $0$ 的项。 预处理单位根 根据单位根的性质 $3$ $\\omega_n ^k=(\\omega_n^1)^k$，我们可以把他乘 $n$ 次，就能得到所有想要的单位根。 第一个单位根是有的，肯定是 $1$。 第二个单位根 $\\omega_n ^1$​ 必然是第一个不与实轴重合的单位根，所以他的坐标就是 $(\\cos(\\frac{2\\pi}{n}),\\sin(\\frac{2\\pi}{n}))$​​ Complex omega(cos(2*Pi/p),sin(2*Pi/p)); for(re int i=0;i&lt;n;i++)&#123; w[i]=buf; buf=buf*omega; &#125; 蝴蝶变换 大概意思是递归版效率太低，我们需要找到迭代解法。 可以发现多项式的第 $i$ 次项到达递归底层时下标为 $i$ 二进制翻转后的数，所以就可以自底向上迭代合并。 可以 $\\mathcal{O(n)}$ 递推求出。 for(re int i=0;i&lt;n;i++)&#123; trans[i]=(trans[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); &#125; 具体证明以及 详细信息以后再补，今天没时间了。 CODE: //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e7+5; const int maxm=1; const double Pi=acos(-1); struct Complex&#123; double x,y; Complex()&#123;&#125; Complex(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;; inline Complex operator + (const Complex &amp;a)const&#123; return Complex(x+a.x,y+a.y); &#125; inline Complex operator - (const Complex &amp;a)const&#123; return Complex(x-a.x,y-a.y); &#125; inline Complex operator * (const Complex &amp;a)const&#123; return Complex(x*a.x-y*a.y,x*a.y+y*a.x); &#125; inline Complex operator / (const Complex &amp;a)const&#123; double tmp=a.x*a.x+a.y*a.y; return Complex((x*a.x+y*a.y)/tmp,(y*a.x-x*a.y)/tmp); &#125; &#125;f[maxn],p[maxn]; int trans[maxn]; int n,m; inline void FFT(Complex *f,bool op)&#123; for(re int i=0;i&lt;n;i++)&#123; if(i&lt;trans[i])swap(f[i],f[trans[i]]); &#125; for(re int p=2;p&lt;=n;p&lt;&lt;=1)&#123; int len=p&gt;&gt;1; Complex omega(cos(2*Pi/p),sin(2*Pi/p)); if(!op)omega.y*=-1; for(re int k=0;k&lt;n;k+=p)&#123; Complex buf(1,0); for(re int l=k;l&lt;k+len;l++)&#123; Complex tmp=buf*f[l+len]; f[l+len]=f[l]-tmp; f[l]=f[l]+tmp; buf=buf*omega; &#125; &#125; &#125; &#125; namespace IO&#123; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; template &lt;typename T, typename... Args&gt; inline void read(T&amp; t, Args&amp;... args) &#123; read(t); read(args...); &#125; template&lt;typename T&gt; void write(T x)&#123; if(x&lt;0)putchar(&#39;-&#39;),x=-x; if(x&gt;9)write(x/10); putchar(x%10+&#39;0&#39;); &#125; template&lt;typename T,typename... Args&gt; void write(T t,Args... args)&#123; write(t);putchar(&#39; &#39;);write(args...); &#125; &#125; using namespace IO; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;, stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;, stdout); #endif read(n,m); for(re int i=0;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;f[i].x); for(re int i=0;i&lt;=m;i++)scanf(&quot;%lf&quot;,&amp;p[i].x); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(re int i=0;i&lt;n;i++)&#123; trans[i]=(trans[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); &#125; FFT(f,1),FFT(p,1); for(re int i=0;i&lt;n;i++)f[i]=f[i]*p[i]; FFT(f,0); for(re int i=0;i&lt;=m;i++)write((int)(f[i].x/n+0.5)),putchar(&#39; &#39;); puts(&quot;&quot;); return 0; &#125;","path":"2021/08/06/FFT快速傅里叶变换学习笔记/","date":"08-06","excerpt":"","tags":[]},{"title":"2021年8月月记","text":"$2021$ 年 $8$ 月月记前言太忙了前言先不写 $8$​ 月 $1$​ 日爬进了学校 然后这个智障学校刚进来就给我当头一棒 大门口装修翻新，于是灰溜溜的从东边绕？ 喂，我可是二中正经学生啊！ 此时可怜的 $LawrenceSivan$​ 还没有意识到这会成为他一整天绕行整个学校好几圈的良好开端。 刚走了没几步，突然草丛中钻出一个光校长。 我直接傻在那里不知所措。 他走上前来轻轻拍着我的肩膀：“孩子你是干啥的”。 我：“wcnm你从草丛里突然钻出来吓我一跳你还问我我是干啥的” 我：“竞赛的”。 然后他就走了。 我怀疑他是在草丛里不干好事 于是爬啊爬啊终于爬到了宿舍。 嘿！看到了熟悉的乔大侠！ 走进了宿舍，化竞的同学们在打羽毛球。 快跑过去打个招呼！ 我：“嘿！你丫干啥呢！” 。。。。 然后我就走进了宿舍啊。 一进宿舍就闻到了一股非常痛快的蘑菇味。 cnm 全他妈发霉了啊！ 聂韶涵朝我邪魅一笑：“嘿嘿，你的被子发霉啦，你的床单发霉啦，你的衣服发霉啦，哈哈哈哈哈哈啊哈哈哈哈啊哈” 草 然后我赶紧把被子抱出去，不得不说长了毛的被子是真的恶心呕 之后我赶紧打开衣柜。 发现一整个衣柜几乎全都发毛了，唯一幸存的是几件礼服。 呕 赶紧抱出去交给爸妈处理。 于是洗了一下午衣服。 对了，顺便收回这句话: 洗衣服一点都不快乐，洗衣服让我感到痛苦！ 之后我开始找蘑菇。 找了半天没有发现蘑菇在哪里。 然后我突然看到了聂韶涵的方便面。 。。。。 之后玩了会手机，看了看新生群。 发现有小学弟想看看学校？ 那好，带他们转转去。 于是我走上了不归路。 首先去了教室，发现到处都是施工的叔叔。 而且在教学楼门口还直接堆了一个坟包土包 于是艰难地迈进去，随便找了个不知道哪个班拍了张照片就爬了。 之后去了操场，发现操场上多了很多奇妙的杆子？？ 用途不详。不过很期待。 之后再去了食堂附近看了猫猫。 于是 发现了几只可爱的猫猫正在贴贴。 于是赶紧拍了几张照片。 由于手机被收走了所以现在先不贴图了，拿到手机再补。 然后转了孔子像。 于是我在这地方上了一年的学，从来没有绕着学校转一整圈，今天居然为了拍照转了一整圈而且穿的是板鞋导致整双脚就快要烂掉了了 也是因为太久不锻炼 然后就爬去了录播室上自习。 晚上被 webnie 老师骂了，原因是乱放路由器。 可是这破屋信号真的一直不好啊 /kk 晚上在颓废，于是立的 flag 又倒了。 没想到啊这月记真的是一天拖一天，然后明年复明年。 睡了好觉。 $8$ 月 $2$ 日集训 DAY 1 是很不熟悉的分治内容。 还是那句话： 我曾经无数次以为我会 CDQ 分治/整体二分/线段树分治 了，但是我败得一败涂地。 这上面仨你写过的题加起来还不到 5 道你会个d 于是这一天听的十分憋屈。 脑子很乱，似乎还没有找回状态。 然后 $nekko$ 上课直接开启了直播啊。 最重要的是他的直播姬不是正经来的，是某软件园。 这一波啊叫引传奇入室 中午睡得很好，甚至还起晚了。。。 不过一定要吐槽一句：统一的饭是真的难吃啊！！！！！ 持续迷糊 lasting… $8$ 月 $3$ 日昨晚睡得可真是好啊。现在身上能数得出来的包大概有好几百个。 大概 $20$ 多个包的样子吧。 似乎找到了军训时的感觉。 鞠狗：”一条胳膊上没三四十个包我都不好意思说自己是国旗班的“ 上午听说 $ztb$​ 要讲插头 DP 了，赶紧屁颠屁颠过去听啊！ 然后就跑过去了，完全不考虑有什么后果。 开始还很正常，但直到我发现他用了 $10 min$ 过了 $3$ 道题的时候，我开始害怕了。 直到他用了半个小时把插头 DP 连知识点带例题全部搞定的时候，我害怕极了。 听说他准备了一个超大型杂题选讲的时候，我开始浑身发抖了。 于是接下来我看到的画面事这样的： ztb：“…之后我们只需要一个二项式反演就行了” kupi：“这确定是给他们出的题吗？” ztb：“啊？他们不会二项式反演吗？他们学过FFT吗？” 我：“你***，我们还没学多项式，你给我们整这个玩？” 于是一个上午就是白费的。 下午赶紧爬回去复习昨天讲过的内容啊。 毕竟是弱项。 然后突然 $wangk$ 爬走了进来，叫我们出去找聂老师做核酸检测。 我说好啊，然后我拿起身份证就往外走啊。 到了大门口就找聂老师，我看了半天没有： “欸，我说这聂老师真是的，啥毛病让我们等他吗？” 突然我看到前面有个箱子，于是我走过去了， 我指着箱子问：“聂老师你是不是躲在里面了？” 然后我身后传来了声音：“你毛病了？” 挺好。 然后他说你们仨先等着，我先把他们送到地方去。 然后他就开车走了。 开车走了。 走了。 了。 。 草，那你这么早把我们都叫下来干啥 于是等着。 做了核酸之后，和大家走着回学校。 然后又浪费了一个钟头… 懵逼的一天。 $8$ 月 $4$ 日考试日。 字符串专场。 D 题是原题。 据说四个题都是原题啊 于是我找到了杰哥比 $wangk$ 强的地方：杰哥考试弄的题我们是一般找不到原题的。 于是开始做。 写了 D 就看 A 没啥思路，只有一个 30 pts 的暴力。 看 B。 似乎是板子题，但是有多组询问。 只会 $\\mathcal{O(nq)}$ 的暴力。 于是莽了，管他多少分。 看 C。 没啥思路。 假贪心。 之后回头把 A 的暴力打了。 好了人生圆满了。 开始颓博客。 略微调整了部分内容，不过看起来应该没有什么很大的变化。 测评了，D 的测评直接给我看傻。 情况是这样的： hhhhhhhc 血亏 $100 pts$。 麻了。 A 比我想象的高了 $10pts$ ，不过暴力大师就是暴力大师，$123hh2$ 居然暴力都比我高 $20pts$ ！OrzOrz 下午常规改题 $＋$ 复习。 分享有趣事： $ 8$ 月 $5$ 日按照昨晚杰哥的要求，我们终于起了个大早，前去操场跑操。 可即便如此到了以后也发现自己已经差不多是最后几个到的了。 然后我还在嘻嘻哈哈，全然不知道后面发生什么事情。 然后我还在嘻嘻哈哈啊 于是走上了不归路。 ：“跑个操那还不是简简单单？” 一圈以后我人傻掉了。 草你是真的不知道，一个一个月不怎么动的人，突然之间让他跑个操，这是一件多么**的事情。 两圈下来我已经不能做到自主呼吸喘的比狗还快 累趴了。 上午 zrq 讲课。 过程十分欢乐。 还有些意外收获 比如什么珍贵的视频什么的: 然后一上午挺顺利的，要讲的东西差不多都搞定了。 于是下午开了多项式。 多项式入门 不太顺利，有的东西没有听懂。 于是准备明天淦。 回宿舍的时候发现外面有闪电。 没太在意。 熄灯了，外面开始作起来了。 闪电接二连三，一个比一个闪。 CG：“草，不会是隔壁 Wiki 的电脑炸了吧” 逐渐有了雷声。 再后来又出现了滂沱大雨。 没错是滂沱大雨。 于是我开始“辗转反侧”。 说句实话我害怕极了 于是把眼罩拉下来顺被安心的睡个好觉。 之后由于宿舍的奇特构造，门后传来了哗哗哗的水声。 于是电闪雷鸣交织着滂沱大雨。 草睡你妈啊 于是开始和舍友 bb 一些有的没的 $ 8$ 月 $6$ 日睡梦中。 ZzzZzz 然后醒过来。 随手摸起枕边的表。 cnm！ 已经 $6:50$ 了！（由于 $6:50$ 是集合准备跑操的时间来着 然后以整个宿舍都很绝望。。。 突然我们想到了一个绝佳的借口：昨晚下雨了。 于是心安理得地慢慢悠悠。 出了门发现外面格外的晴朗。 并且地上一点水都没有 草昨晚那可是滂沱大雨啊！！！ 行了人没了 上午在复习，写了一些贪心题。 于是中午直接立下 $flag$ ，下午要学多项式。 然后下午看了 cmd 的 FFT 入门。 看了一下午// 没错我真的看了一下午。。 之后晚上开始写 FFT 笔记，算是着手补之前留下的天坑。 于是补了一晚上？？？ 成果在这里：FFT快速傅里叶变换学习笔记 | LawrenceSivan 效率挺高的，但是我就是慢啊 太菜了嘤嘤嘤。 $ 8$ 月 $7$ 日是立秋了。 似乎和往常一样，没有什么不同，似乎只是一个寻常且无聊又极其平凡的夏日。","path":"2021/08/01/2021年8月月记/","date":"08-01","excerpt":"","tags":[]},{"title":"2021 二南新生报到必备物品指南~（第二版）","text":"2021 二南新生报到必备物品指南~（第二版）本篇文章主要针对报道之前需要准备的物品进行小小的总结。 希望能够帮到大家，祝大家开学前一切顺利！ 生活方面（宿舍准备）物品总览：床垫，被子，床笠，夏凉被，盆，毛巾，暖水壶，暖水袋，拖鞋，雨伞，蚊帐，锁，洗漱用品，洗澡篮子，防晒用品，手电筒，洗衣用品，卫生用品，水杯，晾衣架，整理箱，适量衣物，校服，适量应急药物，消毒湿巾，口罩），花露水，洗手液，梳子，指甲刀，剃须刀，闹钟，腰带，台灯，镜子，鞋刷子，粘钩，晾衣杆，适量现金，电话卡，钥匙链，牛奶水果，糖糖，海绵墩布，自己兴趣爱好的所需物品。 首先自然是床垫，被子，枕头等床上用品啦。二中的床是 $200cm \\times 90 cm$ 的，床单枕套被盖（就是你的被子叠起来之后还要用一块蓝色的布罩起来，为了整齐）都是有统一要求的。其实里面除了床单其他的要求都不严格。枕头规格不做要求。所以这个随心准备就好啦。床单被罩枕巾床垫到了学校统一买，除了床单以外都可以用自己的。卖的时候分五件套和三件套（大概就是那些东西，其实差别不太大），如果没抢到五件套也没关系，反正多出来的东西都没啥用。雨可以带床笠，方面好用，有奇效哦~伞！经常下雨的，虽然有连廊，但是免不了要横穿校园，所以雨伞雨衣也要带。 之后就是蚊帐。最好准备一个，很多在二中的学长学姐都反映过蚊子真的是太多啦！尤其是一楼二楼，根本忍受不了！（不过其实我个人认为其实还好，不算必需品），还有花露水！ 暖水壶暖水壶暖水壶！暖水壶作用还是很大的。接来的水可以干很多事情，比如用来洗脚等卫生用途，以及泡面等食用用途（ 夏凉被。二南的空调温度是统一的，开关时间也是阿姨一个一个负责。所以对大家情况不一样，可能会有一些热，但是半夜会冷，所以大家尽量带上。实在不行大家可以自备空调遥控器。 盆和毛巾。毛巾多带几块，要不然可能不太够用，盆可以多带几个，分不同的用处。 防晒用品，来了以后军训，请注意操场是没有任何遮挡物的，暴晒，会晒伤，一定要防范，不要带喷雾，有爆炸风险！ 锁！一定要买！多买几个，总有用的。平常柜子不上锁可是要扣分的哦~学校里也买得到。尽量稍微大一点，不要太小，但是不要太大。 洗漱用品，包括但不限于牙刷，牙杯，洗面奶，洗发水，沐浴露，护发素，香皂等等（女生可能会多一些，但是我是大老爷们懂得不多，所以各位看着带。 洗澡篮子，每次去浴室的时候，把自己需要的东西都用篮子装起来带过去，非常方便！ 洗衣用品，包括但不限于洗衣液，肥皂等。虽说学校有洗衣房，但是风评越来越差，比如会有怪味之类，我觉得大家可能不太会喜欢，所以自己的衣服还是自己洗吧~ 卫生用品，包括但不限于卫生纸，卫生巾（女生要格外注意） 校服多买几套！实测一两套绝对穿不过来，夏季三四套打底，秋季两套，较为合适。 整理箱。不必须，如果你有很强烈的整理癖好bushi）管理意识，那么你可能会需要这种东西，大小不宜太大，太大宿舍也没地方放。行李箱可以带，带来放宿舍里，有规定的地方 衣物主要是周日穿。平常周一到周五要求穿校服，周六日可以便装。不宜太多，适量带，穿便装所需要的其他物品以及搭配也要自备。 药物：感冒药，退烧药啥的备上一点，爱运动的孩子一定要备好碘伏，纱布。不要带酒精！过敏体质的带上抗组胺类药物，有肠痉挛史的需要抗胆碱性药物，鼻炎的同学别忘了自己的长期药物。 消毒湿巾，口罩带足！尽管现在很多人认为中国已经处在后疫情时代，但是截至初版截稿之日，中国还是存在确诊病例，防疫不能放松哦~ 口罩也要带一些防霾的，石家庄的冬天几乎天天说都是雾霾天，非常严重。 在学校期间主要使用校园一卡通，但是现金还是要有一些，有备无患。圈存机有时会出现问题，这个时候现金可以打进一卡通中。 私推物品（眼罩。可能大家会有疑问为什么需要这个东西，空调的灯还是挺亮的，有的同学受不了。另外学习很累，戴眼罩可以让自己更舒服一些，并且提高睡眠质量。） 有些女生也许会有一些化妆品，建议收敛一些，不要太明显（但是可以带 护肤品，润唇膏，面膜之类的，可以带。 台灯！学校有时会举办活动，需要占用教室，这样的话大家就要回宿舍自习，台灯就派上用场了！（自然您也可以选择夜战），就那种充电宝台灯也可以，可以给一些小物件啥的充电 电话卡，学校打电话都需要使用中国联通的 201 服务，需要购买电话卡，面值分 20￥ ，50￥ 两种。 有的同学有自己的兴趣爱好啊，喜欢打球，踢球，滑板，乐器啥的，可以带，要交给老师保管哦~ 腰带，礼服是需要腰带的哦！尤其是冬季礼服。女生的夏季裙子也许也需要，但是本来就有，有备无患。军训期间腰带很劣质，可以自备。 来了二南钥匙很重要，宿舍天天要锁门，不锁就要扣分，所以快为自己挑选心仪的钥匙链吧~ 牛奶水果，学校超市有卖的，你也可以自带，但是不要放太久，容易坏。 糖，偶尔奖励自己，也避免低血糖。 镜子！学校宿舍里是没有镜子的！一定要带！女生教室里也可以放一个。 闹钟！克罗地亚还是很魔性的，如果想稍微早一点，闹钟是必然的。带着闹钟不仅可以让自己了解时间，还能让自己更灵活。 粘钩！这个东西比较重要。有了它，你的衣柜更加灵性，你的收纳更加清爽。宿舍里的电话一般是放在地上的。有了粘钩把它挂在墙上，告别趴在地上打电话！ 宿舍里阳台上有晾衣绳。但是挂的比较高，可能弟弟妹妹们会够不到，所以最好买一个晾衣杆，具体就是长成一个长长的杆子，末端有一个钩子，方便自己晾衣服用，否则就要踩凳子啦。 至于海绵墩布，学校的墩布都是布头的，非常难用且容易坏，而且还弄不干净，可以自备墩布。如果嫌路上太沉的话，可以到了学校再买。 生活方面（学习中）物品总览：足够的笔（笔芯），笔记本，作业本，书立，书筐，作图用具，荧光笔（笔记），适量教辅材料，书包，备用眼镜，橡皮，小刀，长尾夹，订书机，打孔器，胶棒，剪刀，胶带，水杯（大小号），茶叶，咖啡（酌情），暖水袋。 笔，黑色，彩色，铅笔都要有。中性笔要分两种，0.5 的和 0.7 的，有不同的作用。0.5 用于正常写字，0.7 用于写作文。 笔记本要带够啊~已经是高中生了，一定要养成做笔记的好习惯。笔记本也可以当错题本使用，用处很多，非常重要。 作业本，和笔记本不是一回事，部分科目有要求，主流要求是牛皮纸封皮，上下翻，就一般一块一个或者一块五一个的那种。 书立，高中以后书超级多啊，有的同学喜欢堆在桌子上，为了更整齐一些，带个书立吧。（不过有的班主任不喜欢这样，要看人的，大部分班主任都允许 书筐，原因同上，注意点同上。 作图工具，方便理科类科目学习及考试 荧光笔，多色笔自然是笔记好助手啦！ 教辅材料，个人认为最好还是有一些，对学习帮助还算不小。但是不要太多，要不然可能写不完或者看不完，买那种简单精巧，内容及其有用精华的。包括但不限于教材帮，王后雄，必刷题，一本涂书等等。 备用眼镜重要性不言而喻。 长尾夹：高消耗品！用处超多，夹卷子，整理物品必备！ 水杯也很重要，大号小号都要带，宿舍教室都要有，多准备几个。男生可以带那种 1.5L 的，打完水放在脚下，小号的可以放在座子上。上课可以喝水。杯子不建议瓷制于玻璃制，最好是不锈钢与塑料。 关于茶叶咖啡，完全看个人喜好。夏天菊花，冬天枸杞，早上浓茶，中午花茶。 其他方面 团员同学请注意！需要办理团组织关系迁出手续（包括智慧团建电子团籍，志愿书，团证，团证上要有转出章，团员档案要密封）。 到了学校以后千万不要把所有的东西都翻出来，过两天还会搬宿舍！会很麻烦！ 没有身份证的同学一定要提前办理！以后很多地方都要用到身份证！ 照片，一寸照片两寸照片都需要一些，虽然可能不一定会用上，但是有总比没有强。 中考成绩单要带！开学以后要填很多表格。","path":"2021/07/27/2021 二南新生报到必备物品指南~（第二版）/","date":"07-27","excerpt":"","tags":[]},{"title":"二分图题目类型总结与选讲","text":"二分图题目类型总结与选讲前言自从上次的决策单调性小结和刚刚更新的莫队全家桶，已经很久没有写过正经的总结类文章了。 最近也是在复习二分图和网络流，于是借此契机水篇博客总结一下 二分图理论相关二分图 (Bipartite graph) 定义如果一张无向图的 $n$ 个节点可以分成 $A,B$ 两个非空集合，其中 $A\\bigcap B=\\varnothing$ ，并且在同一集合内的点都没有边相连，那么称这张图为一张二分图。 其中，$A，B$ 分别称为这张二分图的左部与右部。 性质一张无向图是二分图，当且仅当途中不存在奇环。 二分图的判定 P1525 [NOIP2010 提高组] 关押罪犯 经典中的经典。 根据二分图的性质，我们可以使用染色法进行二分图的判定。 具体地，我们使用黑白两种颜色来对二分图进行染色。每次将相邻的两个节点染成不同的颜色。如果在过程中遇到已经被染色，但是现在需要染上另外一种颜色的情况下，那么这张图一定存在奇环，不是二分图。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; int n,m; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],w[maxn&lt;&lt;1],cnt; inline void add(int u,int v,int val)&#123; nxt[++cnt]=head[u]; to[cnt]=v; w[cnt]=val; head[u]=cnt; &#125; int l=0,r=-INF,vis[maxn],now; bool ok; void dfs(int u,int tag)&#123; vis[u]=tag; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(w[i]&gt;now)&#123; if(!vis[v])dfs(v,3-tag); else if(vis[v]==tag)&#123; ok=false; return; &#125; &#125; &#125; &#125; inline bool check(int x)&#123; memset(vis,0,sizeof(vis)); now=x;ok=1; for(re int i=1;i&lt;=n&amp;&amp;ok;i++)&#123; if(!vis[i])dfs(i,1); &#125; return ok; &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read(); for(re int i=1,u,v,val;i&lt;=m;i++)&#123; u=read();v=read();val=read(); add(u,v,val);add(v,u,val); r=max(r,val); &#125; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))r=mid; else l=mid+1; &#125; printf(&quot;%d\\n&quot;,l); return 0; &#125; 二分图的匹配理论知识匹配：任意两条边都没有公共顶点的边的集合被称为图的一组匹配。 最大匹配：在二分图中，包含边数最多的一组匹配被称为是二分图的最大匹配。 匹配边：对于任意一组匹配 $S$ ，属于 $S$ 的边被称为匹配边，否则为非匹配边。 匹配点：匹配边的端点被称为匹配点，否则是非匹配点。 增广路：在二分图上一条连接两个非匹配点的路径，使得非匹配边与匹配边在路径上交替出现。 增广路的性质： 长度是奇数 路径上单数号是非匹配边，双数号是匹配边。 于是得出一个性质：如果我们得到了一条增广路，可以将路径上的边全部取反，原来的匹配边变成非匹配边，非匹配边变成匹配边，匹配数会增加 $1$ 。 完备匹配（完美匹配）：给定一张左右部点数相同的二分图，如果此二分图的最大匹配包含恰好 $n$ 条匹配边，那么成此匹配为完备匹配（完美匹配） 多重匹配：给定一张左部点为 $n$ ，右部点为 $m$ ，的二分图，从中选择尽量多的边，使第 $i$ 个左部节点至多与 $k_{l_i}$ 条选出的边相连,第 $j$ 个右部点最多与 $k_{r_j}$ 条选出的边相连。 多重匹配是一个广义的匹配问题，二分图最大匹配是 $k_{l_i}=k_{r_j}=1$ 的特殊情况。 二分图的最大匹配算法匈牙利算法（增广路算法） 二分图的一组匹配 $S$ 是最大匹配，当且仅当图中不存在 $S$ 的增广路。 流程： 设开始的所有边都是非匹配边 寻找增广路，把路径上所有边的状态取反； 重复上面一步，直到图中不存在增广路 如何寻找增广路？ 依次给每一个左部点寻找一个匹配的右部点，如果右部点没有匹配，那么直接匹配，否则，尝试给和右部点匹配的点寻找新的匹配，之后把这个右部点分给左部点。 代码简单好写： bool find(int x)&#123; for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(vis[v])continue; vis[v]=true; if(!match[v]||find(match[v]))&#123; match[v]=x; return true; &#125; &#125; return false; &#125; int main()&#123; for(re int i=1;i&lt;=n;i++)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; &#125; 时间复杂度 $\\mathcal{O(nm)}$ 例题：P2756 飞行员配对方案问题 板子题，无细节 唯一要注意的就是开 long long //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const ll maxn = 5e5+5; ll n,m,ans; ll head[maxn],nxt[maxn],to[maxn],cnt,match[maxn]; bool vis[maxn]; inline void add(int x,int y)&#123; to[++cnt]=y; nxt[cnt]=head[x]; head[x]=cnt; &#125; bool find(ll u)&#123; for(ll i=head[u];i;i=nxt[i])&#123; ll v=to[i]; if(vis[v])continue; vis[v]=true; if(!match[v]||find(match[v]))&#123; match[v]=u; return true; &#125; &#125; return false; &#125; inline ll read() &#123; ll x = 0, f = 1;char ch = getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x * f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read(); ll x,y; while(~scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y))&#123; if(x==-1&amp;&amp;y==-1)break; add(x,y); &#125; for(re ll i=1;i&lt;=n;i++)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf(&quot;%lld\\n&quot;,ans); for(ll i=n+1;i&lt;=m;i++)&#123; if(match[i])printf(&quot;%lld %lld\\n&quot;,match[i],i); &#125; return 0; &#125; P1129 [ZJOI2007] 矩阵游戏 给定一块棋盘，上面有一些点，问经过行行互换与列列互换能否实现所有对角线上都有点 目标状态是 $(1,1),(2,2),(3,3)…$ 都要有一个点。 于是我们可以把点看成是一条边，这条边连接了这个点的横纵坐标。 于是就是说每行和每一列都要有匹配。 可以发现交换两行或者两列的操作并不会影响匹配。 因为如果两个点一开始不在一行或者一列，那么无论怎么交换都不会出现在一行或者一列 就是说交换不影响匹配数。 于是我们就要求匹配数恰好为点数 建图的话每次把一个点的行号和列号连接起来。 可以看做是用第 $i$ 行 第 $j$ 列的 $1$ 去交换同一行 对角线上的 $1$ ； 求最大匹配即可： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define INF 0x3f3f3f3f #define re register const int maxn=4e4+5; int T,n,ans; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int match[maxn],a[205][205]; bool vis[maxn]; bool find(int x)&#123; for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(vis[v])continue; vis[v]=true; if(!match[v]||find(match[v]))&#123; match[v]=x; return true; &#125; &#125; return false; &#125; inline void init()&#123; ans=0; memset(match,0,sizeof(match)); memset(head,0,sizeof(head)); memset(vis,0,sizeof(vis)); &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif T=read(); while(T--)&#123; n=read(); init(); for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=n;j++)&#123; a[i][j]=read(); if(a[i][j])add(i,j); &#125; &#125; for(re int i=1;i&lt;=n;i++)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; ans&gt;=n?puts(&quot;Yes&quot;):puts(&quot;No&quot;); &#125; return 0; &#125; P2825 [HEOI2016/TJOI2016]游戏 经典套路了。 有石头的位置不能放。 石头分为硬石头和软石头，硬石头炸不穿，软石头能炸碎。 硬石头可以将一行或者一列分隔开，可以认为是一行新的和一列新的。 于是我们给每一个连续的极长不可扩展的一块一个新的编号。 之后横竖建边，跑最大匹配就好了。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=2005; int head[maxn],to[maxn],nxt[maxn],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int n,m,tot; char mp[maxn][maxn]; int l[maxn][maxn],r[maxn][maxn]; bool vis[maxn]; int match[maxn],ans; bool dfs(int u)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(vis[v])continue; vis[v]=true; if(!match[v]||dfs(match[v]))&#123; match[v]=u; return true; &#125; &#125; return false; &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n),read(m); for(re int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;mp[i]+1; &#125; for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; if(mp[i][j]==&#39;#&#39;)continue; if(j==1||mp[i][j-1]==&#39;#&#39;)tot++; l[i][j]=tot; &#125; &#125; for(re int j=1;j&lt;=m;j++)&#123; for(re int i=1;i&lt;=n;i++)&#123; if(mp[i][j]==&#39;#&#39;)continue; if(i==1||mp[i-1][j]==&#39;#&#39;)tot++; r[i][j]=tot; &#125; &#125; for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; if(mp[i][j]!=&#39;*&#39;)continue; add(l[i][j],r[i][j]); &#125; &#125; for(re int i=1;i&lt;=tot;i++)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))ans++; &#125; printf(&quot;%d\\n&quot;,ans); return 0; &#125; 二分图的多重匹配解决方案： 拆点：能连几条边就拆成几个点 如果只有一侧是多重的，那么直接让多重的一侧每个点执行 $k$ 次。 允许一个点被匹配多次，超过次数以后再寻求改变匹配 网络流（网络流大法吼啊！ 还没写过，先咕着 二分图的带权匹配给定一张二分图，每一条边都有一个权值，求出最大匹配，并要求边权和最大。 第一目的是最大匹配，其次是边权要求。 算法KM算法 稠密图上效率很高 只能满足带权最大匹配一定是完备匹配的问题 交错树：如果在匹配过程中，从某个左部点出发寻找匹配失败，在 dfs 过程中，所经过的点及边共同构成了一棵树——交错树 交错树的根节点是左部节点，叶子节点也都是左部节点，奇数层是非匹配边，偶数层是匹配边。 顶点标记值（顶标）：给每一个左部点一个标记 $la_i$ ，右部点一个标记 $lb_i$ 。必须满足 $la_i+lb_i\\ge w(i,j)$ . 相等子图：所有节点与满足 $la_i+lb_i = w(i,j)$ 的边构成的子图。 定理 若相等子图中存在完备匹配，那么这个完备匹配就是二分图的最大带权匹配 证明： 相等子图中，完备匹配的边权和就是顶标之和，而因为 $la_i+lb_i\\ge w(i,j)$ ，所以权值无法扩展。 算法过程： 满足顶标定义的前提下，首先给每个顶点任意附顶标，之后不断扩大相等子图的规模，直到相等子图存在完备匹配。通常赋值为 $la_i=\\max \\limits_{1\\le j\\le n} {w(i,j}$ ，$lb_i=0$. 每找到一个相等子图，就用匈牙利算法求最大匹配。如果最大匹配不完备，就会形成交错树。 每次将交错树中所有左部点的顶标都减去一个 $delta$ ，右部点顶标都加上 $delta$ 。 重复上述过程 UVA1411 Ants 给定一些黑点白点，要求一个黑点连接一个白点，并且所有线段不相交 可以发现，如果黑白连线相交，我们可以通过交换的方式使得不相交，并且相交之后线段变短。 求解二分图最小权最大匹配。 把权值写成负数，然后跑最大权最大匹配就行了。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=105; #define debug cerr&lt;&lt;&quot;!!!!!!!!!!!!!!!!!!!!!!!!!&quot;&lt;&lt;endl; int n; double la[maxn],lb[maxn]; int match[maxn]; double upd[maxn],delta; bool va[maxn],vb[maxn]; double xl[maxn],yl[maxn]; double xr[maxn],yr[maxn]; double w[maxn][maxn]; const double eps=1e-8; inline double dis(double x,double y,double xx,double yy)&#123; return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy)); &#125; bool dfs(int x)&#123; va[x]=true; for(re int y=1;y&lt;=n;y++)&#123; if(!vb[y])&#123; if(fabs(la[x]+lb[y]-w[x][y]&lt;eps))&#123; vb[y]=true; if(!match[y]||dfs(match[y]))&#123; match[y]=x; return true; &#125; &#125; else upd[y]=min(upd[y],la[x]+lb[y]-w[x][y]); &#125; &#125; return false; &#125; inline void KM()&#123; memset(match,0,sizeof(match)); for(re int i=1;i&lt;=n;i++)&#123; la[i]=-INF;lb[i]=0; for(re int j=1;j&lt;=n;j++)&#123; la[i]=max(la[i],w[i][j]); &#125; &#125; for(re int i=1;i&lt;=n;i++)&#123; while(true)&#123; memset(va,0,sizeof(va)); memset(vb,0,sizeof(vb)); for(re int j=1;j&lt;=n;j++)upd[j]=INF; if(dfs(i))break; delta=INF; for(re int j=1;j&lt;=n;j++)&#123; if(!vb[j])delta=min(delta,upd[j]); &#125; for(re int j=1;j&lt;=n;j++)&#123; if(va[j])la[j]-=delta; if(vb[j])lb[j]+=delta; &#125; &#125; &#125; for(re int i=1;i&lt;=n;i++)&#123; printf(&quot;%d\\n&quot;,match[i]); &#125; &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123; for(re int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf%lf&quot;,&amp;xl[i],&amp;yl[i]); &#125; for(re int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf%lf&quot;,&amp;xr[i],&amp;yr[i]); &#125; for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=n;j++)&#123; w[j][i]=-dis(xl[i],yl[i],xr[j],yr[j]); &#125; &#125; KM(); &#125; return 0; &#125; 二分图的覆盖与独立集二分图的最小点覆盖给定一张二分图，求出一个最小的点集 $S$ 。使得图中任意一条边都有至少一个端点属于 $S$ 二分图的最小点覆盖的点数 $=$ 二分图最大匹配的边数 简单记作：最小点覆盖等于最大匹配、 构造方法： 求出最大匹配 从左部每一个非匹配点出发，执行一次寻找增广路的过程，标记经过的节点。 取左部未被标记的节点与右部被标记的节点。 P7368 [USACO05NOV]Asteroids G 发现问题是这样的。 一颗小星星一定会出现在一行与一列的交汇点，所以可以选择在消灭行时消灭，也可以在消灭列时消灭。 只要有一个覆盖即可。 把小星星的坐标看成一条边的两个端点，只要其中一个节点被覆盖就达成了目的。 建图跑最大匹配，因为最小点覆盖等于最大匹配，所以直接输出就好了 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=25005; int n,k,ans; int head[maxn],to[maxn],nxt[maxn],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int match[maxn]; bool vis[maxn]; bool dfs(int x)&#123; for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(vis[v])continue; vis[v]=true; if(!match[v]||dfs(match[v]))&#123; match[v]=x; return true; &#125; &#125; return false; &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();k=read(); for(re int i=1,x,y;i&lt;=k;i++)&#123; x=read();y=read(); add(x,y); &#125; for(re int i=1;i&lt;=n;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))ans++; &#125; printf(&quot;%d\\n&quot;,ans); return 0; &#125; P6062 [USACO05JAN]Muddy Fields G 每块泥地要不然被横着的一行盖住，要不被纵着的一列盖住。 木板不能盖住干净地面，所以木板所遮盖的必然是一块极大不可扩展的泥地方格。 预处理出所有的横着的极大方格和纵着的极大方格，横纵建边。 求解最小点覆盖 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1005; const int maxm=55; int n,m,ans; char a[55][55]; int head[maxn],to[maxn],nxt[maxn],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int L[maxm][maxm],R[maxm][maxm],cnt1,cnt2; int match[maxn]; bool vis[maxn]; bool dfs(int x)&#123; for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(vis[v])continue; vis[v]=true; if(!match[v]||dfs(match[v]))&#123; match[v]=x; return true; &#125; &#125; return false; &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read(); for(re int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]+1; &#125; for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; if(a[i][j]==&#39;*&#39;)&#123; if(j==1||a[i][j-1]==&#39;.&#39;)L[i][j]=++cnt1; else L[i][j]=cnt1; &#125; &#125; &#125; for(re int i=1;i&lt;=m;i++)&#123; for(re int j=1;j&lt;=n;j++)&#123; if(a[j][i]==&#39;*&#39;)&#123; if(j==1||a[j-1][i]==&#39;.&#39;)R[j][i]=++cnt2; else R[j][i]=cnt2; add(L[j][i],R[j][i]); &#125; &#125; &#125; for(re int i=1;i&lt;=cnt1;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))ans++; &#125; printf(&quot;%d\\n&quot;,ans); return 0; &#125; 二分图最大独立集独立集：给定一张二分图，将其划分成若干个点集，使得任意两点之间没有边相连。 最大独立集：独立集里面最大的那个 团：任意两点都有边相连的子图 最大团：最大的那个 无向图的最大团等于其补图的最大独立集 对于一般无向图，求解最大团，最大独立集是 NP 完全问题。 定理 二分图最大独立集是 $=$ 总点数 $-$ 最大匹配数 去掉最小点覆盖就是最大独立集。 即最大独立集就是最小点覆盖关于全图点数的补集。 P3355 骑士共存问题 将图进行黑白染色，每次把“日”字格子的两角建边，跑最大独立集即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6; const int dx[8]=&#123;-1,-2,-2,-1,1,2,2,1&#125;; const int dy[8]=&#123;-2,-1,1,2,2,1,-1,-2&#125;; int n,m,cnt,ans; bool mapp[2005][2005]; bool vis[100005]; int match[100005],head[maxn]; vector &lt;int&gt; node; struct edge&#123; int next,to; &#125;e[maxn]; inline void add(int u,int v)&#123; e[++cnt].next=head[u]; e[cnt].to=v; head[u]=cnt; &#125; bool find(int u)&#123; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(!vis[v])&#123; vis[v]=1; if(match[v]==-1||find(match[v]))&#123; match[v]=u; return 1; &#125; &#125; &#125; return 0; &#125; int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1,x,y;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; mapp[x][y]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(!mapp[i][j]&amp;&amp;(i+j)%2)&#123;//遍历图，如果没有障碍就黑白染色 node.push_back(n*(i-1)+j);//把行列抻直了使用1—n^2作为编号 for(int k=0;k&lt;8;k++)&#123;//对可以扩展出的8个可能的日字的对角点连边 int xx=i+dx[k]; int yy=j+dy[k]; if(xx&lt;=0||xx&gt;n||yy&lt;=0||yy&gt;n)continue; if(!mapp[xx][yy])&#123; add(n*(i-1)+j,n*(xx-1)+yy); &#125; &#125; &#125; &#125; &#125; memset(match,-1,sizeof(match)); for(int i=0;i&lt;node.size();i++)&#123;//冲冲冲！ memset(vis,0,sizeof(vis)); ans+=find(node[i]); &#125; cout&lt;&lt;n*n-m-ans; return 0; &#125; P2423 [HEOI2012]朋友圈 有两个国家，A 国家内部两人编号一奇一偶就连边，B 内部同奇数都连边，同偶数都连边。 A 和 B 之间可能有边。 求最大团。 看到最大团，我们考虑进行补图转化，也就是想办法求出最大独立集。 考虑补图： 对于 A补图： A 点的奇数点构成了一个团，偶数点构成一个团。 对于 B补图： 奇数点和偶数点构成了二分图。 于是问题变成了在补图上找最大独立集。 由于 A 补图有两个团，所以我们选择方案极其有限：一个都不选，从其中的一个团选出一个，两个团各选一个。 设取出的这两个点分别是 $x,y$我们在 B 补图中删去与这两点有边相连的 B 补图点，之后在 B 补图中剩余点跑最大独立集就可以了。 为什么正确呢？ 首先最大独立集对于 B 补图一定是正确的。 考虑带上 A 补图中的点。 由于 A 补图中有两个团，所以同一个团中最多选出一个节点，才能保证不与其他点相连。 每次选出 A 补图中的人就把 B 补图中相连的点删去，这保证了 B 补图中点不与 A 补图中点相连。 所以这样建出的图是正确的，且他的原图所有点都互相连接。 细节是双向边。 注意这道题目中其实暗中规定好了左部点和右部点，应当直接默认奇数点是左部点，否则会多出一倍的常数。 还需要一个优化。 本题极度卡常，所以常规的匈牙利算法已经不足以满足我们的需求。 为什么？ 可以发现每次找到一个节点准备进行增广时，都需要把 $vis$ 清空。 效率很低。 所以我们引入时间戳的概念来进行优化。 具体实现看代码 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=3005; int T,ans; int n1,n2,A[maxn],B[maxn],m; int mp[maxn][maxn]; vector &lt;int&gt; Bmp[maxn]; int vis[maxn],tim,match[maxn]; int flag[maxn],t; bool dfs(int x)&#123; for(unsigned int i=0;i&lt;Bmp[x].size();i++)&#123; int v=Bmp[x][i]; if(vis[v]!=tim&amp;&amp;flag[v]==t)&#123;//时间戳优化 vis[v]=tim; if(!match[v]||dfs(match[v]))&#123; match[v]=x; return true; &#125; &#125; &#125; return false; &#125; inline int solve0()&#123;//如果一个都不选 int res=0; for(re int i=1;i&lt;=n2;i++)&#123; if(B[i]&amp;1)&#123;//定好左部点 tim++;//时间戳优化 if(dfs(i))res++; &#125; &#125; res=n2-res; return res; &#125; inline int solve1()&#123;//如果只选一个 int res=-INF; for(re int i=1;i&lt;=n1;i++)&#123; t++;int sum=0,nn=0; memset(match,0,sizeof(match)); for(re int j=1;j&lt;=n2;j++)&#123; if(mp[i][j])flag[j]=t,nn++;//删除B补图中相连的点 &#125; for(re int j=1;j&lt;=n2;j++)&#123; if(flag[j]==t&amp;&amp;(B[j]&amp;1))&#123; tim++;//时间戳 if(dfs(j))sum++; &#125; &#125; res=max(res,nn-sum+1); &#125; return res; &#125; inline int solve2()&#123;//如果选两个 int res=-INF; for(re int i=1;i&lt;=n1;i++)&#123; for(re int j=i+1;j&lt;=n1;j++)&#123; if((A[i]^A[j])&amp;1)&#123; t++;int sum=0,nn=0; memset(match,0,sizeof(match)); for(re int k=1;k&lt;=n2;k++)&#123; if(mp[i][k]&amp;&amp;mp[j][k])flag[k]=t,nn++;//删除相连的点 &#125; for(re int k=1;k&lt;=n2;k++)&#123; if(flag[k]==t&amp;&amp;(B[k]&amp;1))&#123; tim++;//时间戳 if(dfs(k))sum++; &#125; &#125; res=max(res,nn-sum+2); &#125; &#125; &#125; return res; &#125; inline int calc(int x)&#123; int res=0; while(x)&#123; res+=x&amp;1; x&gt;&gt;=1; &#125; return res; &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(T); while(T--)&#123; memset(mp,0,sizeof(mp));ans=-INF; read(n1),read(n2),read(m); for(re int i=1;i&lt;=n1;i++)read(A[i]); for(re int i=1;i&lt;=n2;i++)read(B[i]); for(re int i=1,u,v;i&lt;=m;i++)&#123; read(u),read(v); mp[u][v]=mp[v][u]=1; &#125; for(re int i=1;i&lt;=n2;i++)&#123; if(B[i]&amp;1)&#123; for(re int j=1;j&lt;=n2;j++)&#123; if(!(B[j]&amp;1)&amp;&amp;!(calc(B[i]|B[j])&amp;1))Bmp[i].push_back(j),Bmp[j].push_back(i); &#125; &#125; &#125; ans=max(ans,solve0()); ans=max(ans,solve1()); ans=max(ans,solve2()); printf(&quot;%d\\n&quot;,ans); &#125; return 0; &#125; DAG 的最小路径覆盖（多条链不能有公共点）给定一张 DAG ，要求用尽量少的不相交的简单路径，覆盖 DAG 的所有顶点，每个顶点恰好覆盖一次。 将原来 DAG 中每一个点拆点，拆成 $x,x+n$ 两个点。 以 $1-n$ 为左部点，$n+1-2\\times n$ 为右部点，建立二分图，对于原图中每一条有向边 $(x,y)$ 在二分图左部点 $x$ 与右部点 $y+n$ 连边。 这个二分图被称为原 DAG 的拆点二分图，记为 $G_2$ 。 定理 DAG $G$ 的最小路径覆盖包含的路径条数 $=$ $n-G_2$ 的最大匹配数。 最小路径覆盖等于最大独立集 证明 一开始每个点都是独立的一条路径，总共有 $n$ 条不相交路径。每次在二分图中找一条匹配边就相当于把两条路径合并成了一条，就是总路径数减少了 $1$ ，所以找到了几条匹配边，路径就减少了多少。于是最小路径覆盖包含的路径条数 $=$ $n-G_2$ 的最大匹配数 DAG 的最小链覆盖（多条链可以重叠）DAG 的最小链覆盖也被称为最小路径可重复点覆盖。 考虑一个 DAG 上的两条相交路径 _suppose_： 路径 $a$ : $…\\rightarrow x\\rightarrow p\\rightarrow y \\rightarrow …$ 路径 $b$ ： $…\\rightarrow u\\rightarrow p\\rightarrow v\\rightarrow…$ 他们有公共交点 $p$ 。 为了防止相交我们可以在 $x\\rightarrow y$ 直接连一条新边，这样就不用走同一条路了。 于是我们首先使用 floyd 传递闭包得到新的 DAG $G’$ 之后直接在 $G’$ 上跑最小路径覆盖就可以了。 P4589 [TJOI2018]智力竞赛 观察题面，发现一个人如果要答题的话，可以选择一条链全部进行回答。 由于贡献来自他和亲友团没有答到的题目中价值最小的。 对于一道相同的题目，显然再答一次不会有任何多出的贡献。 相当于对这张图进行最小链覆盖。 首先进行 floyd 传递闭包。 对于我们需要求出的没有被答到的题目最小价值最大，显然需要二分。 每次检查一个 $mid$ ，把小于 $mid$ 的值放入新的邻接矩阵中，之后对这个新的邻接矩阵求解最小路径覆盖。 最小路径覆盖等于最大独立集，最大独立集等于最小点覆盖的补集，最小点覆盖等于最大匹配。 于是求出最大匹配之后，算出最大独立集，从而得出最小路径覆盖，再与 $n+1$ 个人进行比较，得出结论即可。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1005; int n,m; int val[maxn]; int g[maxn][maxn],f[maxn][maxn]; inline void floyd()&#123; for(re int k=1;k&lt;=m;k++)&#123; for(re int i=1;i&lt;=m;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; g[i][j]|=g[i][k]&amp;g[k][j]; &#125; &#125; &#125; &#125; int l=INF,r=-INF; int match[maxn]; bool vis[maxn]; bool dfs(int u)&#123; for(re int v=1;v&lt;=m;v++)&#123; if(f[u][v]&amp;&amp;!vis[v])&#123; vis[v]=true; if(!match[v]||dfs(match[v]))&#123; match[v]=u; return true; &#125; &#125; &#125; return false; &#125; inline bool check(int x)&#123; memset(f,0,sizeof(f)); memset(match,0,sizeof(match)); int cnt=0,res=0; for(re int i=1;i&lt;=m;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; if(val[i]&lt;x&amp;&amp;val[j]&lt;x)f[i][j]=g[i][j]; &#125; &#125; for(re int i=1;i&lt;=m;i++)if(val[i]&lt;x)cnt++; for(re int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))res++; &#125; return n+1&gt;=cnt-res;//还要包含小豆自己呢 &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n),read(m); for(re int i=1,k;i&lt;=m;i++)&#123; read(val[i]),read(k); l=min(l,val[i]),r=max(r,val[i]); while(k--)&#123; int a; read(a); g[i][a]=1; &#125; &#125; floyd(); if(check(r+1))&#123; puts(&quot;AK&quot;); return 0; &#125; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(mid))l=mid; else r=mid-1; &#125; printf(&quot;%d\\n&quot;,l); return 0; &#125; 二分图的最长反链最长反链：一张有向无环图的最长反链为一个集合 $ S\\subseteq V$，满足对于 $S$ 中的任意两个不同的点 $u, v \\in S(u \\ne v)$，$u$ 不能到达 $v$，$v$ 也不能到达 $u$，且 $S$ 的大小尽量大。 Dilworth 定理 对于任意有限偏序集，其最长链中元素的数目必等于其最小长链划分中反链的数目。 即最长反链的大小等于最小可重链覆盖大小。 最长反链 $=$ 最小链覆盖 于是转化为求最小链覆盖。 由于最小链覆盖可以转化成最小路径覆盖，于是最小路径覆盖等于最大独立集，而最大独立集是最小点覆盖的补集，最小点覆盖等于最大匹配。 于是思路就理顺了，正常进行即可 P4298 [CTSC2008]祭祀 首先进行 floyd 传递闭包，转化为最小路径覆盖问题。 之后跑一次最大匹配，它的补集大小就是答案。 本题还要求构造答案。 首先需要构造最大独立集。 构造最大独立集可以通过构造最小点覆盖，之后进行补集转化来实现。 跑完最大匹配之后，对于每一个没有匹配的左部点，以他为起点进行一次尝试增广的 dfs 操作（必定会失败），过程中记录下经过的点。 最后取出左部被标记的点且右部没有标记的点（最小点覆盖是需要取出左部没有标记的点与右部被标记的点的并集，但是由于我们构造的是其补集，所以左部被标记的点与右部没有被标记的点的交集） 于是我们构造出了最大独立集。 由最小路径覆盖等于最大独立集，相当于我们构造出了最小路径覆盖。 由于我们已经进行了传递闭包，所以等价于我们构造出了最小链覆盖，也就是最长反链的方案。 对于问题 $3$ ，要求我们满足最长反链最大的前提下，找到所有可能位置。 考虑一个已经求出的最长反链，如果从最长反链中去除一个点，最长反链大小会减小 $1$ 。 于是我们可以首先钦定一个点在最长反链里，之后我们删除和这个点有偏序关系的所有点，之后再求一次最长反链，并且判断最长反链长度是否比原来小 $1$，从而判断这个点在不在最长反链中。 本题极好，一定要把思路理顺，代码并不难写。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=105; int n,m; int mp[maxn][maxn]; int match[maxn]; bool vis[maxn],del[maxn]; inline void floyd()&#123; for(re int k=1;k&lt;=n;k++) for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) mp[i][j]|=mp[i][k]&amp;mp[k][j]; &#125; int cnt1,cnt2,tmp; bool dfs(int x)&#123; for(re int y=1;y&lt;=n;y++)&#123; if(mp[x][y]&amp;&amp;!vis[y]&amp;&amp;!del[y])&#123; vis[y]=true; if(!match[y]||dfs(match[y]))&#123; match[y]=x; return true; &#125; &#125; &#125; return false; &#125; bool flag[maxn][2]; void try_to_dfs(int x)&#123; flag[x][0]=true; for(re int y=1;y&lt;=n;y++)&#123; if(mp[x][y]&amp;&amp;match[y]!=x&amp;&amp;!flag[y][1])&#123; flag[y][1]=true; if(match[y]!=0)try_to_dfs(match[y]); &#125; &#125; &#125; bool used[maxn]; inline void solve2()&#123; for(re int i=1;i&lt;=n;i++)used[match[i]]=true; for(re int i=1;i&lt;=n;i++)&#123; if(!used[i])try_to_dfs(i); &#125; for(re int i=1;i&lt;=n;i++)&#123; if(!(!flag[i][0]||flag[i][1]))printf(&quot;1&quot;);else printf(&quot;0&quot;); //或者可以写成 flag[i][0]&amp;&amp;!flag[i][1] &#125; puts(&quot;&quot;); &#125; inline void solve3()&#123; for(re int i=1;i&lt;=n;i++)&#123; memset(del,0,sizeof(del)); memset(match,0,sizeof(match)); cnt2=0,tmp=n; for(re int j=1;j&lt;=n;j++)&#123; if(mp[i][j]||mp[j][i]||i==j)del[j]=true,tmp--; &#125; for(re int j=1;j&lt;=n;j++)&#123; if(del[j])continue; memset(vis,0,sizeof(vis)); if(dfs(j))cnt2++; &#125; printf(&quot;%d&quot;,tmp-cnt2==n-cnt1-1); &#125; &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n),read(m); for(re int i=1,u,v;i&lt;=m;i++)&#123; read(u),read(v); mp[u][v]=1; &#125; floyd(); for(re int i=1;i&lt;=n;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))cnt1++; &#125; printf(&quot;%d\\n&quot;,n-cnt1); solve2(); solve3(); return 0; &#125; 二分图的最小支配集选出一个点集，每个点要么被选择，要么和被选择的点相连 例题还没写，先咕着，写完再来补 二分图的必经边与可行边先咕着，还没学会","path":"2021/07/18/二分图题目类型总结与选讲/","date":"07-18","excerpt":"","tags":[]},{"title":"决策单调性小结","text":"决策单调性小结前言学了这一块我才明白原来以前的 DP 都是过家家。。。 下面部分内容来自 《算法竞赛进阶指南》 定义决策单调性 对于形如 $F[i]=\\min\\limits_{0\\le j &lt;i}{F[j]+val(j,i) }$ 的状态转移方程，记 $p[i]$ 表示令 $F[i]$ 取到最小值的 $j$ 的值，即 $p[i]$ 是 $F[i]$ 的最优决策。若 $p$ 在 $[1,n]$ 上单调不减，那么称 $F$ 具有决策单调性。 四边形不等式 设 $w(x,y)$ 为定义在整数集合上的二元函数。若对于定义域上的任意整数 $a,b,c,d$ 满足 $a\\le b \\le c \\le d$ ，都有 $w(a,c)+w(b,d)\\le w(a,d)+w(b,c)$ ，那么称函数 $w$ 满足四边形不等式。（也简记为“交叉小于等于包含”） 关于区间包含的单调性 若对于 $∀a≤b≤c≤d$，$w[a,d]≥w[b,c]$（或对于 $∀a≤b≤c≤d，w[a,d]≤w[b,c]$）则称 $w$ 满足关于区间包含的单调性 定理定理 A：四边形不等式的另一种定义。 $w(x,y)$ 是定义在整数集合上的一个二元函数，若 $\\forall a&lt;b$ ，都有 $w(a,b)+w(a+1,b+1)\\le w(a+1,b)+w(a,b+1)$，那么函数 $w$ 满足四边形不等式。 证明： 对于 $a&lt;c$ ，有 $w(a,c)+w(a+1,c+1)\\le w(a+1,c)+w(a,c+1)$. 对于 $a+1&lt;c$ ，有 $w(a+1,c)+w(a+2,c+1)\\le w(a+2,c)+w(a+1,c+1)$. 两式相加，得： $w(a,c)+w(a+2,c+1)\\le w(a+2,c)+w(a,c+1)$. 以此类推 $\\forall a\\le b\\le c$ ，$w(a,c)+w(b,c+1)\\le w(b,c)+w(a,c+1)$. 同理 $\\forall a\\le b\\le c\\le d$ ，$w(a,c)+w(b,d)\\le w(a,d)+w(b,c)$. 证毕。 定理二： 对于方程 $F[i]=min{F[j]+val(j,i) }$ ，我们称 $val(j,i)$ 为附属函数。 若附属函数 $val$ 满足四边形不等式，那么 $F$ 有决策单调性。 证明：$\\forall i \\in [1,n],j\\in [0,p[i]-1]$， 即 ： $j&lt;p[i]&lt;i$ 由决策单调性定义可得： $F[p[i]]+val(p[i],i)\\le F[j]+val(j,i)$ . $\\forall i’\\in[i+1,n]$ ，即 $j&lt;p[i]&lt;i&lt;i’$ . 由于 $val$ 满足四边形不等式，所以交叉小于等于包含可以得到： $val(j,i)+val(p[i],i’)\\le val(j,i’)+val(p[i],i)$ 根据同变量同侧原则进行移项得： $val(p[i],i’)-val(p[i],i)\\le val(j,i’)-val(j,i)$. 与一开始的不等式相加得； $F[p[i]]+val(p[i],i’)\\le F[j]+val(j,i’)$. 根据此式，发现以 $p[i]$ 作为 $F[i’]$ 得决策会更优，即 $F[i’]$ 的最优决策不会比 $p[i]$ 更小，即 $p[i]$ 单调不降。所以 $F$ 有决策单调性。 证毕。 具体操作$F[i]=min{F[j]+val(j,i) }$ 看这种 1D1D 的方程，直接计算显然是 $O(n)$ 的。 一旦具有决策单调性，就可以把复杂度降成 $O(nlogn)$ 的。 一般有两种方案： 二分栈（单调队列）有单调性的玩意自然是可以用单调数据结构处理啦 对于决策集合，如果对 $p$ 进行维护，在过程中的任意时刻，$p$ 一定是单调的。 于是我们每次一定可以找到一个位置，使得在这个位置之前的决策都比当前决策好，这个位置之后所有决策都更劣。 于是可以把这个位置之后的所有决策都变成当前决策。 于是我们发现这貌似是一个区间修改？ 要用线段树或者树状数组嘛？ 没有必要。 首先要明确，对于队列这种数据结构每次进队出队操作都要是 $O(1)$ 的，如果如果使用了线段树或者树状数组进行修改那会导致复杂度不正确，甚至本身就是不太可行的。 可以发现每次要修改的值都是一样的，所以考虑直接把他们看成一体。 具体地，我们可以建立一个队列，其中存放一些三元组。 三元组形如 $node(p,l,r)$ ，代表 $[l,r]$ 内的值都是 $p$ 。 于是我们的修改操作就变成了一整段一整段地修改。 于是对于每一个 $i\\in[1,n]$ ，都进行以下操作： 检查队头：设队头为 $(p_0,l_0,r_0)$ ，若$r_0=i-1$，那么直接删队头。 $f[i]$ 的值必然已经求出来了，对于一个针对区间比 $i$ 更早的三元组，完全对我们来说是没有价值的。 取队头进行计算。 尝试加入新决策，依照以下步骤(1). 取出队尾 $node(p_t,l_t,r_t)$. (2) 若对于 $f[l_t]$ 来说，$i$ 是比 $j_t$ 更优的决策，即 $f[i]+w(i,l_t)\\le f[j_t]+w(j_t,l_t)$，记 $pos=l_t$，删除队尾，返回步骤(1)。 (3) 若对于 $f[r_t]$ 来说，$i$ 是比 $j_t$ 更优的决策，即 $f[j_t]+w(j_t,r_t)\\le f[i]+w(i,r_t)$，去往步骤(5)。 (4) 否则，则在 $[l_t,r_t]$ 上二分查找出位置 $pos$，在此之前决策比 $i$ 优，在此之后决策 $i$ 更优，将 $[l_t,r_t]$ 修改为 $[l_t,pos-1]$，去往步骤(5)。 (5) 把三元组 $(i,pos,n)$ 插入队尾。 由于有二分所以时间复杂度 $O(nlogn)$ 。 代码片段： inline int BIN(int loc,int x)&#123; int ans=q[loc].r+1,l=q[loc].l,r=q[loc].r; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(calc(mid,q[loc].v)&lt;=calc(mid,x))r=mid,ans=mid; else l=mid+1; &#125; return ans; &#125; inline void insert(ll i)&#123; q[tail].l=max(q[tail].l,i); while(head&lt;tail&amp;&amp;calc(q[tail].l,i)&gt;=calc(q[tail].l,q[tail].v))tail--; if(head&gt;tail)q[++tail]=(node)&#123;i,i,n&#125;; else&#123; int pos=BIN(tail,i); if(pos&gt;n)return; q[tail].r=pos-1; q[++tail]=(node)&#123;i,pos,n&#125;; &#125; &#125; void solve()&#123; head=1,tail=0; q[++tail]=(node)&#123;0,1,n&#125;; for(re int i=1;i&lt;=n;i++)&#123; insert(i); if(head&lt;tail&amp;&amp;q[head].r&lt;i)head++; else q[head].l=i; p[i]=max(p[i],calc(i,q[head].v)); &#125; &#125; 分治u1s1，这个比二分栈好写的多。 但是比较局限。 假设已知 $[l,r]$ 的最优决策在 $[kl,kr]$ 上。 再设 $f[mid]$ 的最优决策为 $p$ 根据决策单调性的定义可知： $f[l,mid-1]$ 的最优决策在 $[kl,kmid]$ 中 $f[mid+1,r]$ 的最优决策在 $[kmid,kr]$ 中 于是就可以分治了。 模板如下： void solve(int l,int r,int kl,int kr)&#123; int mid=(l+r)&gt;&gt;1,kmid=kl; double MAX=0; for(re int i=kl;i&lt;=min(mid,kr);i++)&#123; double tmp=a[i]+sqt[mid-i]; if(tmp&gt;MAX)MAX=tmp,kmid=i; &#125; p[mid]=max(MAX,p[mid]); if(l&lt;mid)solve(l,mid-1,kl,kmid); if(r&gt;mid)solve(mid+1,r,kmid,kr); &#125; 时间复杂度同样是 $O(nlogn)$ 。 例题这一块例题实在是太多，但是我实在是太弱，所以只能完成为数不多的几道。 CF868F Yet Another Minimization Problem &amp;&amp; CF833B The Bakery 有一篇好题解 大伙全然把他当作双倍经验做就好了（虽然第二个有线段树优化 DP 的做法，但是今天不说（我也是学了决策单调性才知道原来这个题还能决策单调性做的）） 题目出奇地类似： 将一个长度为 $n$ 的序列分为 $k$ 段，使得总价值最小(大）。 一段区间的价值表示为区间内x相同（不同）数字的个数。 一个区间内相同（不同）数字个数这是莫队的拿手好戏，可以先不考虑。 可以比较轻松地列出转移方程： 设 $f[i][j]$ 为把前 $i$ 个数分成 $j$ 段所需要的最大价值，可以得出： $f[i][j]=\\max{f[i-1][j-1]+val(j+1,i)}$，其中 $val(l,r)$ 表示的是 $[l,r]$ 这个区间的价值。 可以看出，随着 $i$ 的增加，如果 $j$ 不变，显然 $f[i][j]$ 单调不降。所以， $f[i][j]$ 在向右转移时具有决策单调性。 然后套个板子就行了？ CF868F 代码： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; const int maxm=25; ll n,k,kmid; ll a[maxn]; ll f[maxn][maxm]; ll L=1,R=0,cnt[maxn],sum; inline void add(ll x)&#123; sum+=cnt[x]++; &#125; inline void del(ll x)&#123; sum-=--cnt[x]; &#125; inline ll val(ll l,ll r)&#123; while(L&lt;l)del(a[L]),L++; while(L&gt;l)L--,add(a[L]); while(R&lt;r)R++,add(a[R]); while(R&gt;r)del(a[R]),R--; return sum; &#125; void solve(int l,int r,int kl,int kr,int now)&#123; int mid=(l+r)&gt;&gt;1,kmid=kl; for(re int i=kl;i&lt;=min(mid,kr);i++)&#123; ll pre=f[i-1][now-1]+val(i,mid); pre&lt;f[mid][now]?f[mid][now]=pre,kmid=i:0; &#125; if(l&lt;mid)solve(l,mid-1,kl,kmid,now); if(r&gt;mid)solve(mid+1,r,kmid,kr,now); &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n),read(k); for(re int i=1;i&lt;=n;i++)&#123; read(a[i]); &#125; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(re int i=1;i&lt;=k;i++)&#123; solve(1,n,1,n,i); &#125; printf(&quot;%lld\\n&quot;,f[n][k]); return 0; &#125; 复杂度 $\\text{O(nklogn)}$。 然后大家可以注意这玩意比线段树优化 DP 快了一半。 可见决策单调性是个好玩意。 P3515 [POI2011]Lightning Conductor 题目也很简单：给定一个长度为 $n$ 的序列 ${a_n}$，对于每个 $i\\in [1,n] $，求出一个最小的非负整数 $p$ ，使得 $\\forall j\\in[1,n]$，都有 $a_j\\le a_i+p-\\sqrt{|i-j|}$ $1≤n≤5×10^5，0 \\le a_i \\le 10^9$ 第一手资料往往是不好用的. $a_j\\le a_i+p_i-\\sqrt{|i-j|}$ 移项可以得到： $p_i \\ge a_j-a_i+\\sqrt{|i-j|}$ $p_i=\\max{a_j+\\sqrt{|i-j|}}-a_i$ 去掉绝对值： $p_i=\\max{\\max{a_j+\\sqrt{i-j}}(j\\in[1,i]),\\max {a_j+\\sqrt{j-i}}(j\\in[i+1,n])}-a_i$ 发现前半部分具有决策单调性； 求解前半部分：即 $\\max{\\max{a_j+\\sqrt{i-j}}(j\\in[1,i]),\\max {a_j+\\sqrt{j-i}}(j\\in[i+1,n])}$ 两边分开做，另外一边直接序列翻转就可以了 然后两者取个最大值。 最后不要忘记减掉 $a[i]$ 于是我们既可以单调队列也能分治。 这里一并给出 单调队列： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e6+5; ll n; ll a[maxn]; struct node&#123; ll v,l,r; &#125;q[maxn]; ll head=1,tail; double p[maxn],sqt[maxn]; inline double calc(int i,int j)&#123; return a[j]+sqt[i-j]; &#125; inline int BIN(int loc,int x)&#123; int ans=q[loc].r+1,l=q[loc].l,r=q[loc].r; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(calc(mid,q[loc].v)&lt;=calc(mid,x))r=mid,ans=mid; else l=mid+1; &#125; return ans; &#125; inline void insert(ll i)&#123; q[tail].l=max(q[tail].l,i); while(head&lt;tail&amp;&amp;calc(q[tail].l,i)&gt;=calc(q[tail].l,q[tail].v))tail--; if(head&gt;tail)q[++tail]=(node)&#123;i,i,n&#125;; else&#123; int pos=BIN(tail,i); if(pos&gt;n)return; q[tail].r=pos-1; q[++tail]=(node)&#123;i,pos,n&#125;; &#125; &#125; void solve()&#123; head=1,tail=0; q[++tail]=(node)&#123;0,1,n&#125;; for(re int i=1;i&lt;=n;i++)&#123; insert(i); if(head&lt;tail&amp;&amp;q[head].r&lt;i)head++; else q[head].l=i; p[i]=max(p[i],calc(i,q[head].v)); &#125; &#125; inline void rev()&#123; for(re int i=1;i&lt;=n/2;i++)&#123; swap(a[i],a[n-i+1]); swap(p[i],p[n-i+1]); &#125; &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n); for(re int i=1;i&lt;=n;i++)&#123; read(a[i]); sqt[i]=sqrt(i); &#125; solve(); rev(); solve(); for(re int i=n;i;i--)&#123; printf(&quot;%lld\\n&quot;,(ll)ceil(p[i])-a[i]); &#125; return 0; &#125; 分治： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e6+5; ll n; ll a[maxn]; double sqt[maxn],p[maxn]; void solve(int l,int r,int kl,int kr)&#123; int mid=(l+r)&gt;&gt;1,kmid=kl; double MAX=0; for(re int j=kl;j&lt;=min(mid,kr);j++)&#123; double tmp=a[j]+sqt[mid-j]; if(tmp&gt;MAX)MAX=tmp,kmid=j; &#125; p[mid]=max(MAX,p[mid]); if(l&lt;mid)solve(l,mid-1,kl,kmid); if(r&gt;mid)solve(mid+1,r,kmid,kr); &#125; inline void rev()&#123; for(re int i=1;i&lt;=n/2;i++)&#123; swap(a[i],a[n-i+1]); swap(p[i],p[n-i+1]); &#125; &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n); for(re int i=1;i&lt;=n;i++)&#123; read(a[i]); sqt[i]=sqrt(i); &#125; solve(1,n,1,n); rev(); solve(1,n,1,n); for(re int i=n;i;i--)&#123; printf(&quot;%lld\\n&quot;,(ll)ceil(p[i])-a[i]); &#125; return 0; &#125; 不过单调队列那个交 SPOJ 就 WA 了，不太清楚什么原因，也许是写假了但是碰巧这个题数据比较水。 后面的例题待补充…","path":"2021/07/04/决策单调性小结/","date":"07-04","excerpt":"","tags":[]},{"title":"斜率优化小结","text":"斜率优化小结前言没有前言 简介相较于单调队列优化，斜率优化主要解决以下问题： 对于状态转移中的方程，其中存在某一个多项式同时和两个变量有关。 可以类比数学中线性规划的知识进行求解。 原理概述对于状态转移方程中的多项式 $val(i,j)$ ，我们首先将其拆开，按照变量种类进行分类。 会出现下面的情况： 只含有其中的一项 $i$ 只含有其中的一项 $j$ 既含有 $i$ 又含有 $j$ ，也就是通常说的交叉项。 将第一类看作常数 $B$，第二类看作因变量 $Y$，第三类进行拆分，将含 $i$的部分连同系数一起看作系数 $K$，将剩下的部分看作自变量 $X$。 经过这样的变换，原转移方程一定可以写成以下形式： $Y=KX+B$ 于是这就是一条直线的解析式。 在 DP 过程中斜率是固定不变的，于是相当于我们在坐标系上平移一条斜率已知的直线，通过令直线经过不同的决策点，从而使答案体现在截距上从而得到答案的解。 决策点集合在坐标系中必然以凸包形式出现。 图解证明 通过对于凸包各个部分斜率的比较可以确定最优解的出现位置。 同时也可以及时排除不合法或者没有机会成为更优答案的无用节点。 凸包的形式会有两种： 对于答案要求求最大值，需要维护上凸壳。 对于答案要求求最小值，需要维护下凸壳。 这样做是片面的，还需要结合 $f[i]$ 的符号以及大于小于号来判断。 对于上下凸包的辨别分析应当使用斜率式证明。 斜率式的一般形式： 首先应将方程进行转化，表示为解析式形式。（或者先分析凸包形状再解决式子也是可以的，我倾向于前者） 设 $j_1,j_2$ 为决策点，且 $j_2$ 优于 $j_1$，$0\\le j_1&lt;j_2&lt;i$ 之后根据题目要求判定两种决策所造成的答案大小关系。 进一步得出一个关于斜率的不等式。 形式如下： $$k_0\\ge\\dfrac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$$ 就是说 $j_2$ ，$j_1$ 两个点的斜率如果小于等于直线斜率，那么 $j_2$ 要比 $j_1$ 要优。 对应下凸包。 如果将不等号方向改变，即以下形式： $$k_0\\le \\dfrac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$$ 则对应上凸包。 同时每种凸包形式还对应两种不同斜率的直线，同时对应了不同的实现方式（数据结构的使用（其实本质上是思想的不同）。 对于上凸包且直线斜率递减：队头拓展新的决策点，队尾排除不可能选择。使用单调队列。 对于上凸包且直线斜率递增：每次只在队尾操作，使用单调栈。 对于下凸包且直线斜率递减：每次只在队尾操作，使用单调栈。 对于下凸包且直线斜率递增：队头拓展新的决策点，队尾排除不可能选择。使用单调队列。 如何找到最优决策点呢？ 考虑暴力，可以在凸包中逐个枚举，对于第一个斜率满足带决策点斜率要求的点，即为我们要求的最佳决策。 更进一步地，由于凸包上点斜率单调，于是可以二分。 对于队列的初始化，一般需要加入初始值。 一般队列的初始化时 head=1,tail=0，之后由于加入了初始值会使 tail++。 对于部分题目，可以通过 head=tail=1 等方式省略初始化。 在求解问题之前首先需要注意单调性问题。 如果 $X$ (即决策点横坐标) 不单调：如果待决策点斜率依然单调的话，显然单调队列就 GG 了，于是需要可以查询前驱后继的东西，可以使用平衡树，CDQ等手段。 若待决策点斜率不单调：如果决策点横坐标依然单调的话，由于不知道最优决策会出现在什么位置，所以队首就不再有用了，这种情况下只能二分。 如果 待决策点斜率与决策点横坐标都不单调：平衡树搞起来！(或者是处理一维之后使用 CDQ) 例题P3195 [HNOI2008]玩具装箱 满足下凸包且直线斜率递增。 使用单调队列。 同时使用了 head=tail=1 的技巧来简化初始化。 首先写出转移方程并打出暴力。 for(re int i=1;i&lt;=n;i++)&#123; for(re int j=0;j&lt;i;j++)&#123; f[i]=min(f[i],f[j]+(i-(j+1)+sum[i]-sum[j]-L)*(i-(j+1)+sum[i]-sum[j]-L)); &#125; &#125; 之后进行斜率优化。 推导过程： $$f[i]=min(f[i],f[j]+(i-(j+1)+sum[i]-sum[j]-L)^2)$$ $$f[i]=min(f[i],f[j]+((i+sum[i])-(sum[j]+j+1)-L)^2)$$ $$设\\ A[i]=sum[i]+i,B[j]=sum[j]+j+1+L$$ $$f[i]=min(f[i],f[j]+(A[i]-B[j])^2)$$ $$f[i]=min(f[i],f[j]+B[j]^2-2A[i]B[j]+A[i]^2)$$ $$f[i]=f[j]+B[j]^2-2A[i]B[j]+A[i]^2$$ $$2A[i]B[j]+f[i]-A[i]^2=f[j]+B[j]^2$$ $$设\\ X=B[j],Y=f[j]+B[j]$$ $$2A[i]B[j]+f[i]-A[i]^2=f[j]+B[j]^2$$ $$Y=2A[i]X+f[i]-A[i]^2$$ 代码： //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=5e4+5; #define INF 0x3f3f3f3f #define int ll int n,L; double c[maxn],sum[maxn]; double f[maxn]; int head=1,tail=1,q[maxn]; #define A(x) (sum[x]+x) #define B(x) (sum[x]+x+1+L) #define X(x) B(x) #define Y(x) (f[x]+B(x)*B(x)) inline double pro(int x,int y)&#123; return (Y(x)-Y(y))/(X(x)-X(y)); &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; signed main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();L=read(); for(re int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf&quot;,&amp;c[i]); sum[i]=sum[i-1]+c[i]; &#125; for(re int i=1;i&lt;=n;i++)&#123; while(head&lt;tail&amp;&amp;pro(q[head],q[head+1])&lt;2*A(i))head++; f[i]=f[q[head]]+(A(i)-B(q[head]))*(A(i)-B(q[head])); while(head&lt;tail&amp;&amp;pro(q[tail-1],q[tail])&gt;pro(q[tail-1],i))tail--; q[++tail]=i; &#125; printf(&quot;%lld\\n&quot;,(ll)f[n]); return 0; &#125; P3628 [APIO2010]特别行动队 满足上凸包且斜率递减。 使用单调队列。 依旧是写出状态转移方程并打出暴力： for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;i;++j)&#123; f[i]=max(f[i],f[j]+F(c[i]-c[j])); &#125; &#125; 斜率优化： $$f[i]=max(f[i],f[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c)$$ $$f[i]=max(f[i],f[j]+asum[i]^2-2asum[i]sum[j]+sum[j]^2+bsum[i]-bsum[j]+c)$$ $$f[i]=max(f[i],f[j]-2asum[i]sum[j]+asum[j]^2-bsum[j])+asum[i]^2+bsum[i]+c$$ $$设\\ A[i]=2asum[i],B[j]=f[i]-asum[i]^2-bsum[i]-c$$ $$B(i)=min(f[i],f[j]-A[i]sum[j]+asum[j]^2-bsum[j])$$ $$设\\ X(j)=sum[j],Y(j)=f[j]+B[j]^2$$ $$B(i)=min(f[i],f[j]-A[i]X(j)+aX(j)^2-bX(j))$$ $$B(i)=f[j]-A[i]X(j)+aX(j)^2-bX(j)$$ $$Y=f[j]+aX(j)^2-bX(j)$$ $$(Y=A[i]X(j)+B[i])$$ $$f[i]=f[j]-A(i)X(j)+aX(j)^2-bX(j)+asum[i]^2+bsum[i]+c$$ $$求解队头\\ f[i]=-A(i)X(j)+Y(j)+aX(i)^2+bX(i)+c$$ 代码： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define INF 0x3f3f3f3f #define re register const int maxn=1e6+5; ll n,a,b,c; double f[maxn]; double x[maxn],sum[maxn]; ll head,tail,q[maxn]; #define A(x) (a*sum[x]) #define B(x) (f[x]-a*sum[x]*sum[x]-b*sum[x]-c) #define X(x) sum[x] #define Y(x) (f[x]+a*sum[x]*sum[x]-b*sum[x]) inline double pro(int x,int y)&#123; return (Y(x)-Y(y))/(X(x)-X(y)); &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;commando.in&quot;, &quot;r&quot;, stdin); freopen(&quot;commando.out&quot;, &quot;w&quot;, stdout); #endif n=read();a=read();b=read();c=read(); for(re int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf&quot;,&amp;x[i]); sum[i]=sum[i-1]+x[i]; &#125; for(re int i=1;i&lt;=n;i++)&#123; while(head&lt;tail&amp;&amp;pro(q[head],q[head+1])&gt;2*A(i))head++; f[i]=-2*A(i)*X(q[head])+Y(q[head])+a*X(i)*X(i)+b*X(i)+c; while(head&lt;tail&amp;&amp;pro(q[tail-1],q[tail])&lt;pro(q[tail-1],i))tail--; q[++tail]=i; &#125; printf(&quot;%lld\\n&quot;,(ll)f[n]); return 0; &#125; P5504 [JSOI2011] 柠檬 满足上凸包且直线斜率单调递增。 使用单调栈。 存在性质：最优情况下，每一段的首尾数字必定相同，而且作为 $s_0$。 需要给每一个点都维护一个独立凸包。 实现可以使用 std::vector. 此题中求 $f[x]$ 时需要把 $x$ 放入凸包中，所以应该先维护凸包，然后把点放进去，之后寻找最优决策点（判断目标斜率），最后求解答案。 方程 $$f[i]=\\max\\limits_{0&lt;j\\le i,s_i=s_j}{f_{j-1}+s_i\\times (cnt_i-cnt_j+1)^2}$$ $$f[i]=f_{j-1}+s_i\\times (cnt_i-cnt_j+1)^2$$ $$f[i]=f_{j-1}+s_i\\times (cnt_i^2-2cnt_icnt_j+2cnt_i+cnt_j^2-2cnt_j+1)$$ $$f[i]=f_{j-1}+s_icnt_i^2-2s_icnt_icnt_j+2s_icnt_i+s_jcnt_j^2-2s_jcnt_j+s_i$$ $$设\\ B=f_i-s_icnt_i^2-2s_icnt_i-s_i$$ $$Y=f_{j-1}+s_jcnt_j^2-2s_jcnt_j$$ $$K=2s_icnt_i$$ $$X=cnt_j$$ 可以求解。 代码: //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; ll n; double f[maxn]; ll s[maxn],cnt[maxn],tot[maxn]; //ll stk[maxn],top; vector &lt;ll&gt; stk[maxn]; #define Y(x) (f[x-1]+s[x]*cnt[x]*cnt[x]-2*s[x]*cnt[x]) #define X(x) (cnt[x]) #define K(x) (2*s[x]*cnt[x]) #define B(x) (f[x]-s[x]*cnt[x]*cnt[x]-2*s[x]*cnt[x]-s[x]) inline double slope(int x,int y)&#123; return (Y(x)-Y(y))/(X(x)-X(y)); &#125; inline double calc(int x,int y)&#123; return Y(y)-K(x)*X(y)+s[x]*cnt[x]*cnt[x]+2*s[x]*cnt[x]+s[x]; &#125; #define top stk[s[i]].size() template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n); for(re int i=1;i&lt;=n;i++)&#123; read(s[i]); cnt[i]=++tot[s[i]]; &#125; for(re int i=1;i&lt;=n;i++)&#123; while(top&gt;=2&amp;&amp;slope(stk[s[i]][top-2],stk[s[i]][top-1])&lt;slope(stk[s[i]][top-2],i))stk[s[i]].pop_back(); stk[s[i]].push_back(i); while(top&gt;=2&amp;&amp;calc(i,stk[s[i]][top-1])&lt;calc(i,stk[s[i]][top-2]))stk[s[i]].pop_back(); f[i]=calc(i,stk[s[i]][top-1]); &#125; printf(&quot;%lld\\n&quot;,(ll)f[n]); return 0; &#125; P2900 [USACO08MAR]Land Acquisition G 好题！ 需要以下结论： 由于我们需要的代价是最长的乘以最宽的，所以对我们来说我们只关心这两个极值，其他的一概不管。 于是考虑这样几种情况： 长宽都不如人家的：这个肯定是白送，不管。 长宽都比人家大的：原来那个就白送了，现在管这个。 长的不如人家长，但是宽度比人家宽：有点用，因为分块合并一起买，后面可能会有贡献。 宽的不如人家宽，但是比人家长：同上。 所以可以发现，对于任意的一整段，我们只关心其中长度最长的，宽度最宽的两个（或者一个），考虑把这些地排成一个序列。 把最高的放最左边，最宽的放最右边。 这样就可以构成一个长度递减但是宽度递增的序列了。 夹在中间的长不如最长的长，宽不如最长的宽的那几个就没啥用了。 对于一段区间，可以考虑拆开买，于是总贡献就是前半部分加上后半部分。 由此列出转移方程： $$f_i=min{f_j+h_{j+1}\\times w_i }$$ 解释: $f_j$ 是表示买 $[1,j]$ 这个区间需要的代价，$h_{j+1}\\times w_i$ 是后半段的代价。由于长度降序排序，宽度升序排序，所以拆分位置下一位必然是最高的，即 $h_{j+1}$ ，整个区间的右端点一定是最宽的，即 $w_i$ 。 发现包含一个与 $i,j$ 都有关的多项式。 考虑斜率优化： $$f_i=min{f_j+h_{j+1}\\times w_i }$$ $$f_i=f_j+h_{j+1}\\times w_i$$ $$B=f_i$$ $$Y=f_j$$ $$K=w_i$$ $$X=h_{j+1}$$ $$B=Y+KX$$ $$Y=-KX+B$$ 不是我刻意水，这个斜率优化就这么简单 注意一下虽然题目要我们求最小值，但是这个可不是下凸包哦。 推导过程（使用斜率式）： 设 $j_1,j_2$ 为决策点，且 $j_2$ 优于 $j_1$，$0\\le j_1&lt;j_2&lt;i$ 则 $f_2+h_{j_2+1}w_i\\le f_1+h_{j_1+1}w_i$ 移项得到 $w_i(h_{j_2+1}-h_{j_1+1})\\le f_{j_1}-f_{j_2}$ 由高度降序可得 $h_{j_2+1}&lt;h_{j_1+1}$ 于是除过去变号。 即：$w_i\\ge \\dfrac {f_{j_1}-f_{j_2}}{(h_{j_2+1}-h_{j_1+1})}$ 调整分母符号得： 即：$-w_i\\le \\dfrac {f_{j_1}-f_{j_2}}{(h_{j_1+1}-h_{j_2+1})}$ 所以斜率递减。维护上凸包 复杂度瓶颈在于排序 代码： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; int n,num; double f[maxn]; ll q[maxn],head,tail; #define mp make_pair pair &lt;ll,ll&gt; a[maxn]; #define B(x) (f[x]) #define X(x) (a[x+1].first) #define Y(x) (f[x]) #define K(x) (a[x].second) inline double slope(int x,int y)&#123; return (Y(x)-Y(y))/(X(x)-X(y)); &#125; template &lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n); for(re int i=1;i&lt;=n;i++)&#123; read(a[i].first);read(a[i].second); &#125; sort(a+1,a+1+n); reverse(a+1,a+1+n); for(re int i=1;i&lt;=n;i++)&#123; if(a[i].second&gt;a[head].second)a[++head]=a[i]; &#125; n=head;head=tail=1; for(re int i=1;i&lt;=n;i++)&#123; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&gt;-K(i))head++; f[i]=K(i)*X(q[head])+Y(q[head]); while(head&lt;tail&amp;&amp;slope(q[tail-1],q[tail])&lt;slope(q[tail-1],i))tail--; q[++tail]=i; &#125; printf(&quot;%lld\\n&quot;,(ll)f[n]); return 0; &#125; CF311B Cats Transport 这个玩意太坑啦！！！！ 调了一整个上午+下午的 1h ，最后求助了大家才明白怎么回事。 最后脑子都不转了。 首先考虑一个人出发后，会有一部分猫在等待。 如果到达某一个点的时候不能够恰好接到一只猫，那么肯定是不优的，他完全可以早走一会然后让猫少等一会。 于是这启示我们应该注意一只猫恰好被接到的时间。 如果想要恰好接到需要满足在 $A_i$ 出发 $$A_i=T_i-\\sum\\limits_{j=1}^{H_j}D_j$$ 所以出发时间若为 $t$ ，那么这只猫的等待时间就是 $t-A_i$. 设 $f[i,j]$ 表示 $i$ 个人带走了 $j$ 只猫所用的代价。 方程 $$f[i,j]=min{f[i-1][k]+\\sum\\limits_{p=k+1}^{j}A_j-A_p}$$ $$f[i,j]=min{f[i-1][k]+(j-k)A_j-\\sum\\limits_{p=k+1}^{j}A_p }$$ $$f[i,j]=min{f[i-1][k]+(j-k)A_j-S[j]+S[k] }$$ $$f[i,j]=f[i-1][k]+(j-k)A_j-S[j]+S[k] $$ $$f[i,j]=f[i-1][k]+j\\times A_j-k\\times A_j-S[j]+S[k] $$ $$设\\ B=f[i,j]-j\\times A_j+S[j]$$ $$Y=f[i-1][k]+S[k]$$ $$X=k$$ $$K=A[j]$$ $$Y=KX+B$$ $$设\\ k_2\\ 优于\\ k_1\\ 且k_2&gt;k_1。$$ $$f[i - 1][k_1] + sum[k_1] - A[j] * k_1 &gt; f[i - 1][k_2] + sum[k_2] - A[j] * k_2$$ $$Y(k_1)-Kk_1&gt;Y(k_2)-Kk_2$$ $$(k_1-k_2)K&lt;Y(k_1)-Y(k_2)$$ $$K&gt;\\dfrac{Y(k_1)-Y(k_2)}{k_1-k_2}$$ 满足下凸包，且直线斜率递增 使用单调队列。 但是这个题有及其坑爹的地方！ 如果横坐标相等的话斜率就不存在了（或者可以理解为斜率无穷大） 然后我们平常写的 slope 就 GG 了。 如何解决呢？ 把分母乘过去，不要写成斜率形式就好啦。 代码： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define INF 0x3f3f3f3f #define re register const int maxn=2e5+5; ll n,m,p; ll d[maxn],H[maxn],T[maxn],A[maxn],sum[maxn]; ll f[105][maxn],ans=INF; ll q[maxn],head=1,tail=0; ll i; #define Y(x) (f[i-1][x]+sum[x]) #define X(x) (x) #define K(x) (A[x]) #define B(x) (f[i][x]-x*A[x]+sum[x]) inline double slope(int x,int y)&#123; return 1.0*(Y(x)-Y(y))/(X(x)-X(y)); &#125; inline ll read()&#123; ll x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read();p=read(); for(re int i=2;i&lt;=n;i++)&#123; d[i]=d[i-1]+read(); &#125; for(re int i=1;i&lt;=m;i++)&#123; H[i]=read();T[i]=read(); A[i]=T[i]-d[H[i]]; &#125; sort(A+1,A+1+m); for(re int i=1;i&lt;=m;i++)&#123; sum[i]=sum[i-1]+A[i]; &#125; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(re int i=1;i&lt;=p;i++)&#123; head=1;tail=0;q[++tail]=0; for(re int j=1;j&lt;=m;j++)&#123; while(head&lt;tail&amp;&amp;Y(q[head])-Y(q[head+1])&gt;K(j)*(q[head]-q[head+1]))head++; f[i][j]=Y(q[head])+A[j]*(j-q[head])-sum[j]; while(head&lt;tail&amp;&amp;(Y(j)-Y(q[tail-1]))*(q[tail]-q[tail-1])&lt;(Y(q[tail])-Y(q[tail-1]))*(j-q[tail-1]))tail--; q[++tail]=j; &#125; &#125; printf(&quot;%lld\\n&quot;,f[p][m]); return 0; &#125; P3648 [APIO2014]序列分割 根据题意很容易可以列出方程： 设 $F[i,j]$ 表示当前处理到第 $i$ 位，分了 $j$ 次。 $$F[i,k]=\\max\\limits_{0\\le j&lt;i}{F[j,k-1]+val(j+1,i) }$$ 其中 $$val(j+1,i) =(sum(i)-sum(j))\\times sum(j)$$ 去掉 $\\max$ 得到： $$F[i,k]=F[j,k-1]+(sum(i)-sum(j))\\times sum(j)$$ 为了方便可以将 $F[i,k]$ 暂且看作 $f[i]$ ，把 $F[j,k-1]$ 暂且看作 $f[j]$ 得到： $$f[i]=f[j]+sum(i)\\times sum(j)-sum(j)^2$$ $$设\\ B=f[i]$$ $$Y=f[j]-sum(j)^2$$ $$K=-sum(i)$$ $$X=sum(j)$$ 直线斜率单调递减。 设决策点 $k_2$ 优于 $k_1$ 且 $k_2&gt;k_1$， 根据方程可以发现： $$f[k_2]+sun(i)\\times sum(k_2)-sum(k_2)^2\\ge f[k_1]+sun(i)\\times sum(k_1)-sum(k_1)^2$$ $$即\\ Y(k_2)-KX(k_2)\\ge Y(k_1)-KX(k_1)$$ 通过移项可以得到： $$KX(k_1)-KX(k_2)\\ge Y(k_1)-Y(k_2)$$ $$K(X(k_1)-X(k_2))\\ge Y(k_1)-Y(k_2)$$ $$K\\le \\dfrac{Y(k_1)-Y(k_2)}{X(k_1)-X(k_2)}$$ 上凸包。 满足上凸包且直线斜率单调递减。 使用单调队列。 通过这道题，我们可以发现：$f$ 数组千万不要开 double ！！！ 否则你会最后一个点 WA 的很惨！！！ 另外一个需要注意的点就是横坐标相等的情况。 直接取斜率为 -INF 就行了。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f3f3f3f3f #define re register const int maxn=1e5+5; ll n,k; ll a[maxn],sum[maxn]; ll f[maxn],g[maxn]; ll q[maxn],head=1,tail=0; ll pre[maxn][300]; #define B(x) (f[i]) #define X(x) (sum[x]) #define Y(x) (g[x]-sum[x]*sum[x]) #define K(x) (-sum[x]) inline double slope(ll x,ll y)&#123; return X(x)==X(y)?-INF:1.0*((Y(x)-Y(y))*1.0)/((X(x)-X(y))*1.0); &#125; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n),read(k); for(re int i=1;i&lt;=n;i++)&#123; read(a[i]); sum[i]=sum[i-1]+a[i]; &#125; for(re int tim=1;tim&lt;=k;tim++)&#123; head=1,tail=0; q[++tail]=0; memcpy(g,f,sizeof(g)); for(re int i=1;i&lt;=n;i++)&#123; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&gt;=K(i))head++; //f[i]=Y(q[head])-K(i)*X(q[head]); f[i]=g[q[head]]-sum[q[head]]*sum[q[head]]+sum[i]*sum[q[head]]; pre[i][tim]=q[head]; while(head&lt;tail&amp;&amp;slope(q[tail-1],q[tail])&lt;=slope(q[tail-1],i))tail--; q[++tail]=i; &#125; &#125; printf(&quot;%lld\\n&quot;,f[n]); int i=k,j=n; while(pre[j][i])&#123; printf(&quot;%lld &quot;,pre[j][i]); j=pre[j][i],i--; &#125; return 0; &#125; 自然是可以通过写成相乘形式来避免这种问题的。 注意要带等号，否则会 WA for(re int i=1;i&lt;=n;i++)&#123; while(head&lt;tail&amp;&amp;Y(q[head])-Y(q[head+1])&lt;=K(i)*(X(q[head])-X(q[head+1])))head++; //f[i]=Y(q[head])-K(i)*X(q[head]); f[i]=g[q[head]]-sum[q[head]]*sum[q[head]]+sum[i]*sum[q[head]]; pre[i][tim]=q[head]; while(head&lt;tail&amp;&amp;(Y(q[tail-1])-Y(q[tail]))*(X(q[tail-1])-X(i))&lt;=(Y(q[tail-1])-Y(i))*(X(q[tail-1])-X(q[tail])))tail--; q[++tail]=i; &#125; P4027 [NOI2007] 货币兑换 设 $f[i]$ 表示在第 $i$ 天卖掉所有的金券所获得的最大收益。 容易得到： $$f[i]=max{f[i-1],num_A\\times A[i]+num_B\\times B[i]}$$ 发现只与我们手中剩下的金券数量有关。 于是回去考虑我们什么时候获得的金券。 假设在第 $j$ 天买到了金券，而上一次卖是在第 $k$ 天，于是可以写出： $$f[k]=num_A\\times A[j]+num_B\\times B[j]$$ 用 $rate$ 把 $num_A$ 进行转换： $$f[k]=num_B\\times R[j]\\times A[j]+num_B\\times B[j]$$ 移项得到： $$num_B=\\dfrac{f[k]}{R[j]\\times A[j]+B[j]}$$ 同时得到： $$num_A=\\dfrac{f[k]\\times R[j]}{R[j]\\times A[j]+B[j]}$$ 于是至此可以把方程写出来： $$f[i]=max{\\dfrac{f[k]\\times R[j]}{R[j]\\times A[j]+B[j]}\\times A[i]+\\dfrac{f[k]}{R[j]\\times A[j]+B[j]}\\times B[i]}$$ 然后这就是 $\\mathcal{O(n^2)}$ 的了。 cin&gt;&gt;n&gt;&gt;f[0]; for(int i=1;i&lt;=n;++i)cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;R[i]; f[1]=f[0]*R[1]/(A[1]*R[1]+B[1]); ans=S; for(int i=2;i&lt;=n;++i) &#123; for(int j=1;j&lt;i;++j) ans=max(ans,f[j]*A[i]+f[j]/R[j]*B[i]); f[i]=ans*R[i]/(A[i]*R[i]+B[i]); &#125; printf(&quot;%.3lf\\n&quot;,ans); 考虑进一步优化。 之后去掉 $max$ $$f[i]=\\dfrac{f[k]\\times R[j]}{R[j]\\times A[j]+B[j]}\\times A[i]+\\dfrac{f[k]}{R[j]\\times A[j]+B[j]}\\times B[i]$$ 发现式子很丑，于是我们还是看原来的式子吧。。。 $$f[i]=num_A\\times A[i]+num_B\\times B[i]$$ 通过上面的研究可以发现，$num$ 这两项中 $i,j$ 是捆绑在一起的，存在交叉项。 考虑斜率优化。 两边同时除以 $B[i]$： $$\\dfrac{f[i]}{B[i]}=num_A\\times \\dfrac{A[i]}{B[i]}+num_B$$ 移项： $$num_B =-\\dfrac{A[i]}{B[i]}\\times num_A +\\dfrac{f[i]}{B[i]}$$ 这里的转化和以往的转化不大一样，并不只是单纯按照变量种类进行分类，而是适当根据题目进行了调整。 设 $x[i]=num_A,y[i]=num_B,k=-A[i]/B[i]$ 设决策点 $j,k$ ，满足 并且 $j$ 优于 $k$： $$x[j]A[i]+y[j]B[i]&gt;x[k]A[i]+y[k]B[i]$$ $$(x[j]-x[k])\\times A[i]&gt;-(y[j]-y[k])\\times B[i]$$ $$-\\dfrac{A[i]}{B[i]}&lt;\\dfrac{y[j]-y[k]}{x[j]-x[k]}$$ 发现对应了一个上凸包。 并且同时横坐标不严格单调递增，并且直线斜率也不是单调的，所以需要动态维护凸包，或者采取 CDQ 分治的手段。 平衡树和 CDQ 都是可以的。 分别说一下： CDQ 做法： 常规的斜率优化是需要满足横坐标与斜率都要单调的，于是可以考虑排序后处理。 可以发现，斜率再输入之后其实就是固定的，所以我们可以首先按照斜率排序。 发现天数变成了乱序，所以需要对天数进行分治。 对于 CDQ 解决 DP 问题，我们需要首先递归左区间，然后处理左区间对右区间的影响，再递归右区间。 考虑如何处理影响。 每次处理影响之前都已经处理好左区间了，所以现在不需要管左区间的顺序。所以对于左区间，我们对它进行任何顺序的调换都不会有影响。 由于我们需要构建凸包，所以需要保证 $x$ 的有序。 索性左区间直接按照横坐标排序，使用单调栈构建凸包即可。 由于右区间斜率已经递减，所以直接使用单调队列更新答案即可。 在分治边界还需要处理一下 $f[l]=\\max(f[l],f[l-1])$。 值得注意的是，对于上面提到的对左区间按照横坐标排序，如果直接使用快速排序的话，那么复杂度为 $\\mathcal{O(n\\log^2 n)}$。 稍加调整就可以做到 $\\mathcal{O(n\\log n)}$。 CDQ 分治本身就是归并的过程，所以直接在处理完右区间之后，进行一次归并排序即可。 处理完右区间之后再归并是为了保证左区间按照横坐标有序，右区间按照斜率有序。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; const double eps=1e-9; int n; double f[maxn]; double A[maxn],B[maxn],R[maxn]; struct node&#123; double x,y; int id; inline bool operator &lt; (const node &amp;a)const&#123; return -(A[id]/B[id])&gt;-(A[a.id]/B[a.id]); &#125; &#125;q[maxn],t[maxn]; inline double slope(int x,int y)&#123; if(q[x].x==q[y].x)return -INF; return (q[x].y-q[y].y)/(q[x].x-q[y].x); &#125; int stk[maxn]; #define K(x) (-A[x]/B[x]) void cdq(int l,int r)&#123;//按天数分治 if(l==r)&#123; f[l]=max(f[l],f[l-1]); q[l].x=f[l]/(A[l]*R[l]+B[l])*R[l]; q[l].y=f[l]/(A[l]*R[l]+B[l]); return; &#125; int mid=(l+r)&gt;&gt;1,lp=l,rp=mid+1,tot=l; for(re int i=l;i&lt;=r;i++)&#123; if(q[i].id&lt;=mid)t[lp++]=q[i]; else t[rp++]=q[i]; &#125; for(re int i=l;i&lt;=r;i++)&#123; q[i]=t[i]; &#125; cdq(l,mid); int top=0,ptr=1;//单调栈构建凸包 for(re int i=l;i&lt;=mid;i++)&#123; while(top&gt;=2&amp;&amp;slope(stk[top],i)&gt;slope(stk[top-1],stk[top]))top--; stk[++top]=i; &#125; for(re int i=mid+1;i&lt;=r;i++)&#123;//单调队列更新 while(ptr&lt;top&amp;&amp;slope(stk[ptr],stk[ptr+1])&gt;K(q[i].id))ptr++; f[q[i].id]=max(f[q[i].id],q[stk[ptr]].x*A[q[i].id]+q[stk[ptr]].y*B[q[i].id]); &#125; cdq(mid+1,r); lp=l,rp=mid+1,tot=l; while(lp&lt;=mid&amp;&amp;rp&lt;=r)&#123;//按照横坐标归并排序 if(q[lp].x&lt;q[rp].x)t[tot++]=q[lp++]; else t[tot++]=q[rp++]; &#125; while(lp&lt;=mid)t[tot++]=q[lp++]; while(rp&lt;=r)t[tot++]=q[rp++]; for(re int i=l;i&lt;=r;i++)q[i]=t[i]; &#125; namespace IO&#123; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; template &lt;typename T, typename... Args&gt; inline void read(T&amp; t, Args&amp;... args) &#123; read(t); read(args...); &#125; template&lt;typename T&gt; void write(T x)&#123; if(x&lt;0)putchar(&#39;-&#39;),x=-x; if(x&gt;9)write(x/10); putchar(x%10+&#39;0&#39;); &#125; template&lt;typename T,typename... Args&gt; void write(T t,Args... args)&#123; write(t);putchar(&#39; &#39;);write(args...); &#125; &#125; using namespace IO; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;, stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;, stdout); #endif read(n);scanf(&quot;%lf&quot;,&amp;f[0]); for(re int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;R[i]); q[i]=(node)&#123;f[0]/(A[i]*R[i]+B[i])*R[i],f[0]/(A[i]*R[i]+B[i]),i&#125;; f[i]=f[0];//记录天数 &#125; sort(q+1,q+1+n);//外层按照斜率排序 cdq(1,n); printf(&quot;%.3lf\\n&quot;,f[n]); return 0; &#125; 平衡树做法： 需要维护两个东西 $lk[],rk[]$ ，分别代表每一个点左侧的直线的斜率和右侧的直线的斜率。 其实过程就是这样的： 现在有一个凸包，我们需要插入一个新的节点。 如果新点再凸包内部，那么直接扔掉就可以了。 如果在外部，就要删掉一部分点。 做法是，找到左边第一个可以和他构成凸包的点，找到右边第一个可以构成凸包的点，然后把中间的全删掉就行了。 具体地，对于维护上凸包，首先把新点旋转到根，然后对于当前点 $s$，如果 $s$ 左边线的斜率大于了 $s\\rightarrow x$ 的斜率，代表满足了，但不确定是不是第一个，于是找右儿子，否则找左儿子。 右侧同理。 inline int Pre(int x)&#123; int s=ls(x),u=x; while(s) if(slope(s,x)&lt;=lk[s]+eps)u=s,s=rs(s); else s=ls(s); return u; &#125; inline int Nxt(int x)&#123; int s=rs(x),u=x; while(s) if(slope(x,s)+eps&gt;=rk[s])u=s,s=ls(s); else s=rs(s); return u; &#125; 一定要注意精度。 eps 给不等号朝向的一侧。 更新状态时直接找到第一个大于当前直线斜率的位置更新即可。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; const double eps=1e-9; int n; double f[maxn],A[maxn],B[maxn],R[maxn]; double lk[maxn],rk[maxn]; double X[maxn],Y[maxn]; namespace Splay&#123; int c[maxn][2],fa[maxn],val[maxn],rt,tot; #define ls(x) c[x][0] #define rs(x) c[x][1] inline int dir(int x)&#123; return x==ls(fa[x])?0:1; &#125; inline void set(int x,int px,int d)&#123; c[px][d]=x,fa[x]=px; &#125; inline void rotate(int x)&#123; int d=!dir(x),f=fa[x]; set(c[x][d],f,!d); set(x,fa[f],dir(f)); set(f,x,d); &#125; inline void splay(int x,int goal)&#123; for(;fa[x]!=goal;rotate(x)) if(fa[fa[x]]!=goal) rotate(dir(x)^dir(fa[x])?x:fa[x]); if(goal==0)rt=x; &#125; inline double slope(int x,int y)&#123; if(fabs(X[x]-X[y])&lt;eps)return -INF; return (Y[x]-Y[y])/(X[x]-X[y]); &#125; inline int Pre(int x)&#123; int s=ls(x),u=x; while(s) if(slope(s,x)&lt;=lk[s]+eps)u=s,s=rs(s); else s=ls(s); return u; &#125; inline int Nxt(int x)&#123; int s=rs(x),u=x; while(s) if(slope(x,s)+eps&gt;=rk[s])u=s,s=ls(s); else s=rs(s); return u; &#125; inline int find(double num)&#123; int u=rt; while(true)&#123; if(!u)return 0; if(lk[u]+eps&gt;=num&amp;&amp;rk[u]&lt;=num+eps)return u; else if(lk[u]+eps&lt;num)u=ls(u); else u=rs(u); &#125; &#125; inline void update(int x)&#123; splay(x,0); if(ls(x))&#123; int l=Pre(x); splay(l,x);rs(l)=0; lk[x]=rk[l]=slope(l,x); &#125; else lk[x]=INF; if(rs(x))&#123; int r=Nxt(x); splay(r,x);ls(r)=0; rk[x]=lk[r]=slope(x,r); &#125; else rk[x]=-INF; if(lk[x]&lt;=rk[x]+eps)&#123; rt=ls(x),rs(rt)=rs(x),fa[rs(x)]=rt,fa[rt]=0; lk[rt]=rk[rs(rt)]=slope(rt,rs(rt)); &#125; &#125; inline void insert(int &amp;x,int last,int id)&#123; if(!x)&#123; x=id,fa[x]=last; return; &#125; if(X[id]&lt;=X[x]+eps)insert(ls(x),x,id); else insert(rs(x),x,id); &#125; &#125; using namespace Splay; namespace IO&#123; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; template &lt;typename T, typename... Args&gt; inline void read(T&amp; t, Args&amp;... args) &#123; read(t); read(args...); &#125; template&lt;typename T&gt; void write(T x)&#123; if(x&lt;0)putchar(&#39;-&#39;),x=-x; if(x&gt;9)write(x/10); putchar(x%10+&#39;0&#39;); &#125; template&lt;typename T,typename... Args&gt; void write(T t,Args... args)&#123; write(t);putchar(&#39; &#39;);write(args...); &#125; &#125; using namespace IO; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;, stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;, stdout); #endif read(n);scanf(&quot;%lf&quot;,&amp;f[0]); for(re int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;R[i]); int j=find(-A[i]/B[i]); f[i]=max(f[i-1],X[j]*A[i]+Y[j]*B[i]); Y[i]=f[i]/(A[i]*R[i]+B[i]),X[i]=Y[i]*R[i]; insert(rt,0,i); update(i); &#125; printf(&quot;%.3lf\\n&quot;,f[n]); return 0; &#125; 后记天坑到这里就算是填完了，期待着下一个天坑的填补 /kk","path":"2021/07/02/斜率优化小结/","date":"07-02","excerpt":"","tags":[]},{"title":"2021年7月月记","text":"$2021$ 年 $7$ 月月记前言其实已经算不上前言了。 由于种种原因月记咕咕咕了好多天！ 所以现在一次性补齐真的好累好累啊 $7$ 月 $1$ 日今天是就要去二北了。 于是还蛮期待的。 由于各个科目都结课了所以一整天直接机房颓废。 爽死了！ 似乎干了一些正事但是现在记不太清了。 这种感觉就像是今天就要放暑假了？ 这可不太好 下午拿到了手机，终于弄好了 leancloud 于是大家可以来评论啦！ 然后下午就来到了北校区。 好久不坐车，乍一坐总有种晕车的感觉。 到了以后匆匆忙忙地噎了一口饭，就回去打模拟赛了。 没啥状态。 开了以后 T1 看着像个进制，打表找了半天二进制规律没找到。 开 T2 看了几眼 T2 的题面，总感觉非常熟悉，但是就是想不起来在哪里见过。 多个条件都指向某一道我做过的题目。 然后我这榆木脑袋就是想不出来。 于是开了 T3 tarjan 模板题》 然后就开始敲键盘了。 打完 T3 以后又回去看了 T1. 发现其实和二进制没啥关系. 只是一个普通的 K 进制。 然后就切了 subtask #1 然后看着 subtask #2 人就傻了。 又因为脑子比较抽，于是根本不知道怎么做。 想了个二分。 然后就不假思索地打上去了。 一测样例发现和答案差了十万八千里。 稍微一反应发现二分出来的值根本不合法。 然后人就傻了。 赛后发现只要把正着的过程倒过来就好了。 我真是个nt。 T2 是超级钢琴。 当时刚了很久的题目。 hhhhhccc 居然一点都想不起来。 菜死了。 $7$ 月 $2$ 日早上起的挺早的。 只是没饭吃了。 集训 Day 1 讲的是 DP 的优化手段。 一些内容之前学过了。 但是也学到了很多闻所未闻的东西。 啊对了。 甚至让我发现我以前学的斜率优化都是皮毛，甚至很多知识都是错误的。 于是花了一整晚上重新大概也许算是比较系统的重修了一下斜率优化。 写了总结帖。 很有收获。 中午吃的是面。 不得不说二北的饭真的是不敢恭维。 于是晚上毅然决然的出去吃了。 胡辣汤真好喝。 喝了快乐水。 $7$ 月 $3$ 日今天早上起晚了。 起来的时候发现还有 5 min 就要迟到了。 可是我们要穿过整个校园然后还要坐电梯上 8 楼。 于是就迟到了。 也是非常邪门，明明睡得很早但是就是宿舍所有人都起晚了。 于是总结出了人生哲理： 睡得越早，起的越晚，所以以后尽量不要睡觉。 哦对了，今天达成了成就， AC500祭 $7$ 月 $4$ 日很好。 昨天起晚了，今天回宿舍回晚了。 然后被封在外面了。 然后场景就是将近 15 个人被堵在门外。 你可以想象到绝望的场景吗？ 一群人趴在玻璃上。 鬼哭狼嚎地求宿管阿姨开门。 可是宿管阿姨依旧没有开门的意思。 之后出现了诡异的一幕。 突然从隔壁的女生宿舍窜出一些人。 之后在门口开始打闹。 然后有两个女生被封在外面了。 这两个女生干脆就在门外快乐地嬉戏起来。 然后一会取翻墙打算翻进宿舍。 一会又回来拼命地敲击玻璃。 正当我们觉得无计可施的时候，她们居然掏出了手机。 直接就打起了电话。 我们一行十几个人直接目蹬狗呆。 看起来就像是一排等待军训的傻小子。 不得不说，二中人才真的是太多了。 $7$ 月 $5$ 日考试了。 具体内容实在是忘记了。 $7$ 月 $6$ 日终于见到 SGcolin 啦 数学专题。 也算是把之前的内容又来了一遍。 还补充了一些新的内容。 康托展开与变进制数。 以前貌似是搞过的，但是因为研究的层次太浅所以几乎不怎么够用。 然后开始搞搞搞。 $7$ 月 $7$ 日构造 随机化，爆搜！__youwike 确实是很有意思的一部分内容 $7$ 月 $8$ 日无事发生 $7$ 月 $9$ 日数据结构。 又讲了一堆一直打算做却一直没有开始的东西。 于是现在 Todo_list 越堆越多。 或许把这些全部搞定是一个长期目标？ $7$ 月 $10$ 日今天研究了 LCT 终于是会了。 大概过程就是找了5 6篇博客轮着看。 还找了几篇论文。 确实认识到 LCT 作为 NOI 大纲中 10 级知识点真的毫无吹嘘。 甚至比一些大模拟还要难写。 之后还解锁了横屏调代码的独特技能。 至于原因，大家可以自己看： 之后写完了板子自然是要抓紧时间写博客啊！ 然后快写写写！ 然后吃完晚饭就开始写了。 大概从 7 点多写到了 将近 10 点。 即将完工了。 之后 wangk 老师让我插一下插销。 然后我一看插销觉得很乱，然后我就想整理一下。 于是我把旁边的插销拔掉了准备整理一下。 —————— 整理完了。 可以安心写博客了。 然后我看着黑掉的屏幕，陷入了沉思。 草我他妈把我台式机主机给拔了。 我还没保存！！！！ 傻逼！！！ 草 然后直接失声痛哭。 晚上抓紧时间补补。 于是回去了以后深夜码了码，到 1 点多终于快完工了。 吓得我赶紧点保存。 不过之前写的东西都没了。 损失。 $7$ 月 $11$ 日$O(\\log n)$ or $\\mathcal{O}(\\log n)$ or $\\mathrm{O}(\\log n)$ $7$ 月 $12$ 日休息日！！！！ 请好假出去玩啦！ 之后就开始了无聊的下午。 和 CG 123hh2 wiki XYY1411 凉笙在外面逛了一大圈。 然后屁都没干。 可以说是非常无聊。 唯一的收获就是早上的懒觉，睡得很爽。 啊对了。 还有一个直观感受。 石家庄的小情侣们太勇了。 亲眼看着好几对北校的同学们穿着校服直接就在学校附近不超过 100 米的地方牵手与卿卿我我 $7$ 月 $13$ 日考试 挂分大场。 过于悲痛 不想多说。 $7$ 月 $14$ 日考试。 可以发现数据结构两道树剖，一道基环树森林，还有一个不知道是什么玩意的东西。 以为稳了，至少 300+ 然后惊奇地发现除了 T3 其他的全爆零了。 这可能是截至目前 OI 生涯中最痛苦的一段时间。 树剖及树链问题一直都是我认为我的强项。 然后这一场考试直接从头到尾打击了自信心。 就像是唯一拥有的东西突然失去。 就像是有些人突然离开。 一下午脑子都处于不清醒的状态。 每一道题都调不出来。 看到每一道题都没有思路。 想换题又舍不得。 想关掉又做不到。 不知道该干些什么。 无助。 无奈。 无感。 陷入了病态。 无法自拔。 头疼。 头晕 心情极度烦躁。 教练谈过了。 找到了点希望 要继续，别他妈放弃啊！ $7$ 月 $15$ 日自习。 补题。 概率期望题单几乎补全了。 $7$ 月 $16$ 日今天是问清哥哥讲课！ 还是觉得问情哥哥比较好听。 然后就花了将近两个小时去讲了 KMP。 很合理啊 留下可怜的 nekko 独自痛苦。 晚上写了二分图的总结。 确实发现二分图看似简单的一个模块，但是内容实在是博大精深。 不过确实很久不写这些总结性质的东西了。 好习惯还是要有的啊！ 最长反链晚上一直刚 刚到2点终于刚出来了 睡个好觉！ $7$ 月 $17$ 日继续补博客。 发现内容越来越多。 不过确实都很有意思！ 晚上被告知最近会下大雨，于是就要明天就改成调休了。 感觉距离上一次调休没过几天啊。 之后做了机房大扫除。 依然偷了懒。 不过按照石家庄以往的惯例，大雨是必然下不成的。 等着看明天吧。 由于明天要调休所以晚上比较颓废。 下了 phigros 和 arcaea 顺便和 凉笙打了拳皇。 用的 $wiki$ 的炫酷键盘。 青轴。 估计舍友睡得很好。 $7$ 月 $18$ 日合理。 大雨果真没下。 真的是太灵验了。 于是上午直接睡疯了。 起来的时候快 11 点了。 然后穿上衣服洗完漱就爬到机房了。 上午没干啥事情就要出去吃饭了。 把昨晚没调试出来的分块调好了。 没错就是蒲公英，经典例题。 吃完饭就回来继续颓废。 想写点东西，又不太想写点东西。 于是补补月记。 $7$ 月 $19$ 日$7$​ 月 $20$​​ 日$7$​ 月 $21$​ 日$7$​ 月 $22$​ 日$7$​ 月 $23$​ 日$7$​ 月 $24$​ 日$7$​ 月 $25$​ 日$7$​ 月 $26$​ 日$7$​ 月 $27$​ 日$7$​ 月 $28$​ 日$7$​ 月 $29$​ 日今日有学弟在群里问有没有物品清单。 于是突发奇想想要写一份。 貌似这次信竞生大放光芒？给新高一的同学们提供了一条龙式的开学前服务。 之后就是写啊写啊写啊写啊写。 可以负责任的告诉大家一边看奥运一边听歌一边写一些文字这种感觉是很爽的。 $7$​ 月 $30$​ 日$7$​ 月 $31$​​ 日今天回石家庄。 上午在家颓废地躺着。 于是等着爸爸回来出发去石家庄。 于是他拖了一整个上午。 然后出发的时候已经是 $11$ 点了。 上了车听了会歌。 然后睡着了。 睡醒了之后体验了一下残疾人生活（指浑身连手带脚都是麻的） 我以后一定要在车里准备一张床！ 然后就开始乱跑了。 去了县医院。 期间了解了一些事情。 之后打疫苗。 大老远看到了很多同龄的孩子。 其中有几个比较眼熟。 月底总结这是写月记的第二个月，于是可以发现这个月非常的摸啊。 好几天的月记全都摸掉了，之后就是追悔莫及的大力补月记。 按照传统月底总结是应该有一句话的。 $\\color{Blue}{有客自远方来，眉间有远方的风雨。}$ $\\color{Blue}{——余光中}$​​ 过路人，希望你能够快乐。 那么，向前走吧~","path":"2021/07/01/2021年7月月记/","date":"07-01","excerpt":"","tags":[]},{"title":"动态区间第 k 小 （树套树）","text":"P2617 Dynamic Rankings前言这是一道已经咕了很久的题。 第一次想写是因为 luan 讲了这道题。 直到她又出现在了我的智能推荐里。 我知道我不能再等了！ 我要去和她表白！！ 类题总结关于各种第 k 大问题肯定已经见过很多了。 反正各种奇奇怪怪的解法都是有的。 比较主流的有： 静态整体第 k 大（小）这玩意有两种解法。 首先是显而易见的 std::sort. sort(a+1,a+1+n); //reverse(a+1,a+1+n); cout&lt;&lt;a[k]&lt;&lt;endl; 生怕你不会写这玩意 时间复杂度 $\\text{O(nlogn)}$。 之后这玩意是存在 $\\text{O(n)}$ 做法的。 考虑魔改快排。 每次选择基准值的时候记录一些大于基准值的个数 $cnt$ ，之后根据 $cnt$ 选择一半进入，就可以在平均线性之间内统计出第 k 大（小）。 int getk(int *v, int l, int r, int k)&#123; if(l&lt;r)&#123; int i=l,j=l; for(;j&lt;r;j++)&#123; if(v[j]&lt;v[r])&#123; swap(v[i++],v[j]); &#125; &#125; swap(v[i],v[r]); if(k==i) return v[i]; else if(k&lt;i) return getk(v,l,i-1,k); else return getk(v,i+1,r,k); &#125; else return v[l]; &#125; 动态整体第 k 大（小）权值线段树，插入直接在树上插入，然后查询也直接查就行,像个桶一样。 值域小一点的话直接建树就行了，大一点就动态开点。 namespace SegmentTree&#123; struct SegmentTree&#123; int v; #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 &#125;st[maxn&lt;&lt;2]; inline void push_up(int rt)&#123; st[rt].v=st[ls].v+st[rs].v; &#125; void modify(int rt,int l,int r,int pos,int val)&#123; if(l==r)&#123; st[rt].v+=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)modify(ls,l,mid,pos,val); else modify(rs,mid+1,r,pos,val); push_up(rt); &#125; int ask(int rt,int l,int r,int val)&#123;//查询第 k 大 if(l==r)return l; int mid=(l+r)&gt;&gt;1; if(val&lt;=st[rs].v)ask(rs,mid+1,r,val); else ask(ls,l,mid,val-st[rs].v); &#125; &#125; 复杂度 $\\text{O(nlogn)}$ 静态区间第 k 大（小）也就是主席树板子题了。 具体看这个就行：p3834 可持久化线段树模板（主席树） 动态区间第 k 大（小）就是本题了。 考虑修改操作。 由于常规的主席树是依靠前缀和的思想来求解区间第 k 大的，于是可以想到求解动态区间第 k 大首要问题是如何维护前缀和的问题。 对于维护前缀和，我们通常有如下几种方式： 暴力，树状数组，线段树。 于是有一个思路：加一个数据结构来维护前缀和。 加上去的数据结构放在什么位置呢？ 由于主席树需要前缀和来作差，于是可以发现树状数组是要套在主席树外面的。 于是明白树状数组每个节点都维护一个线段树的根节点。 分开考虑修改以及查询操作。 修改操作树状数组每次单点修改复杂度 $\\text{O(logn)}$ ，对应 $\\text{O(logn)}$ 棵权值线段树会受到影响，又因为每次修改需要对应到线段树内，线段树内每次又会有 $\\text{O(logn)}$ 个节点需要修改。于是单次复杂度 $\\text{O}(log^2n)$ 每次修改需要用树状数组定位到需要修改的线段树的根节点位置，之后进行修改即可： void modify(int &amp;rt,int l,int r,int pos,int val)&#123; if(!rt)rt=++node; if(l==r)&#123; st[rt].v+=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)modify(ls(rt),l,mid,pos,val); else modify(rs(rt),mid+1,r,pos,val); push_up(rt); &#125; void update(int pos,int x,int val)&#123; for(re int i=pos;i&lt;=n;i+=lowbit(i))&#123;//处理涉及到的 log(n) 个根节点，就是对应的主席树 modify(root[i],1,tmp,x,val);//线段树上修改log(n) 个节点 &#125; &#125; int main() &#123; ... for(re int i=1;i&lt;=m;i++)&#123; if(q[i].op)&#123;//modify update(q[i].pos,a[q[i].pos],-1);//把原数删去 a[q[i].pos]=q[i].val;//换成现在要的数 update(q[i].pos,q[i].val,1);//在树上修改 &#125; &#125; &#125; 查询操作对于查询操作，依然是要用到前缀和。 由于使用了树状数组维护前缀和，于是我们直接在树状数组上取出对应的 $\\text{O(logn)}$ 个根节点，也就是对应的主席树根节点，取的时候直接体现作差就行。 之后就和普通的主席树查询区间第 k 大一样，根据作差得到的值直接递归进入左子树或者右子树即可。 复杂度 $\\text{O}(log^2n)$ int query(int l,int r,int k)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; int xx=0; for(re int i=1;i&lt;=cnt1;i++)xx-=st[ls(ct1[i])].v;//作差得到cnt值 for(re int i=1;i&lt;=cnt2;i++)xx+=st[ls(ct2[i])].v; if(xx&gt;=k)&#123;//左递归，连带着log(n)棵主席树一起进入左儿子 for(re int i=1;i&lt;=cnt1;i++)ct1[i]=ls(ct1[i]); for(re int i=1;i&lt;=cnt2;i++)ct2[i]=ls(ct2[i]); return query(l,mid,k); &#125; else &#123;////右递归，连带着log(n)棵主席树一起进入右儿子 for(re int i=1;i&lt;=cnt1;i++)ct1[i]=rs(ct1[i]); for(re int i=1;i&lt;=cnt2;i++)ct2[i]=rs(ct2[i]); return query(mid+1,r,k-xx); &#125; &#125; inline void located(int l,int r)&#123;//取出对应的log(n)个线段树的根节点。 cnt1=cnt2=0; for(re int i=l-1;i;i-=lowbit(i))ct1[++cnt1]=root[i];//取l-1和r，用于作差 for(re int i=r;i;i-=lowbit(i))ct2[++cnt2]=root[i]; &#125; int main() &#123; ... for(re int i=1;i&lt;=m;i++)&#123; else &#123; located(q[i].l,q[i].r); ans=b[query(1,tmp,q[i].k)]; printf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125; 复杂度分析查询操作 $\\text{O}(log^2n)$，修改操作 $\\text{O}(log^2n)$，总体复杂度 $\\text{O}(mlog^2n)$ 由于动态开点，所以空间复杂度就是对应的查询和修改所需要的空间。 于是 空间复杂度和时间复杂度可以认为是同阶的。 线段树大小开 $400$ 倍就够了。 具体实现的时候建议封一个 namespace ，看着也好看调着也爽。 似乎代码没有想象的那么长？ CODE://#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; int n,m,ans; char op; int a[maxn],b[maxn&lt;&lt;1],tot,tmp; int ct1[maxn],ct2[maxn],cnt1,cnt2; struct QUERY&#123; int l,r,k,op; int pos,val; &#125;q[maxn]; namespace SegmentTree&#123; inline void Discretization()&#123; sort(b+1,b+1+tot); tmp=unique(b+1,b+1+tot)-b-1; for(re int i=1;i&lt;=n;i++)a[i]=lower_bound(b+1,b+1+tmp,a[i])-b; for(re int i=1;i&lt;=m;i++)&#123; if(q[i].op==1)q[i].val=lower_bound(b+1,b+1+tmp,q[i].val)-b; &#125; &#125; struct SegmentTree&#123; int lc,rc,v; #define ls(x) st[x].lc #define rs(x) st[x].rc &#125;st[maxn*400]; int node,root[maxn]; inline void push_up(int rt)&#123; st[rt].v=st[ls(rt)].v+st[rs(rt)].v; &#125; void modify(int &amp;rt,int l,int r,int pos,int val)&#123; if(!rt)rt=++node; if(l==r)&#123; st[rt].v+=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)modify(ls(rt),l,mid,pos,val); else modify(rs(rt),mid+1,r,pos,val); push_up(rt); &#125; int query(int l,int r,int k)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; int xx=0; for(re int i=1;i&lt;=cnt1;i++)xx-=st[ls(ct1[i])].v; for(re int i=1;i&lt;=cnt2;i++)xx+=st[ls(ct2[i])].v; if(xx&gt;=k)&#123; for(re int i=1;i&lt;=cnt1;i++)ct1[i]=ls(ct1[i]); for(re int i=1;i&lt;=cnt2;i++)ct2[i]=ls(ct2[i]); return query(l,mid,k); &#125; else &#123; for(re int i=1;i&lt;=cnt1;i++)ct1[i]=rs(ct1[i]); for(re int i=1;i&lt;=cnt2;i++)ct2[i]=rs(ct2[i]); return query(mid+1,r,k-xx); &#125; &#125; &#125; using namespace SegmentTree; namespace BIT&#123; #define lowbit(x) (x&amp;-x) void update(int pos,int x,int val)&#123; for(re int i=pos;i&lt;=n;i+=lowbit(i))&#123; modify(root[i],1,tmp,x,val); &#125; &#125; inline void located(int l,int r)&#123; cnt1=cnt2=0; for(re int i=l-1;i;i-=lowbit(i))ct1[++cnt1]=root[i]; for(re int i=r;i;i-=lowbit(i))ct2[++cnt2]=root[i]; &#125; &#125; using namespace BIT; template &lt;typename T&gt; inline void read(T &amp;x)&#123; T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif read(n);read(m); for(re int i=1;i&lt;=n;i++)&#123; read(a[i]); b[++tot]=a[i]; &#125; for(re int i=1;i&lt;=m;i++)&#123; //cin&gt;&gt;op; scanf(&quot; %c&quot;,&amp;op); if(op==&#39;C&#39;)&#123; q[i].op=1,read(q[i].pos),read(q[i].val),b[++tot]=q[i].val; &#125; else q[i].op=0,read(q[i].l),read(q[i].r),read(q[i].k); &#125; Discretization(); for(re int i=1;i&lt;=n;i++)&#123; update(i,a[i],1); &#125; for(re int i=1;i&lt;=m;i++)&#123; if(q[i].op)&#123; update(q[i].pos,a[q[i].pos],-1); a[q[i].pos]=q[i].val; update(q[i].pos,q[i].val,1); &#125; else &#123; located(q[i].l,q[i].r); ans=b[query(1,tmp,q[i].k)]; printf(&quot;%d\\n&quot;,ans); &#125; &#125; return 0; &#125;","path":"2021/06/30/动态区间第 k 小 （树套树）/","date":"06-30","excerpt":"","tags":[]},{"title":"P4363 [九省联考2018]一双木棋chess（轮廓线状压）","text":"P4363 [九省联考2018]一双木棋chess 这两天学了这个。 是轮廓线状压的或许算是裸题。 关键在于怎么压状态。 题意 有一个 $n \\times m$ 的棋盘，两个人轮流下棋。 一个位置可以落子当且仅当这个位置的左侧和上面都有棋子。 两个人落在对应的位置会收获各自的贡献值。 最大化自己的得分减去对方的得分。 做法博弈论？ 是有 max_min搜索还有一些别的做法的。 max_min搜索 看眼数据范围，都是 $10$ 以内的。 于是考虑状压。 问题随之而来：如何存状态？ 由于落子是有限制的，所以需要考虑在什么情况下可以落子。 由于落子是合法的需要满足左边和上边都有棋子，于是在整个过程中必然会有这样的情况： 可以发现这样的轮廓一定是连续的。 于是这就是我们需要的轮廓线。 可以考虑存储右下角的轮廓线作为状态。 如何存储呢？ 首先这个轮廓线的长度肯定是 $n+m$ 的。 我们用 $0$ 来表示横边，用 $1$ 来表示竖边。 可以举个例子： 对于当前的状态，从右上角开始，向左下角延伸，如果有横边那么当前位就是 $0$，有竖边就是 $1$； 所以状态串就是 $000101010101010101$ 之后对于状态的判断以及转移过程，都可以利用这个轮廓线。 可以发现，经过这样的状压之后，判断是否可以落子的条件就变成了：是否存在一个位置，满足串中有 $01$ 这样的两位，如果有，那么就可以落子。 落子以后，该位置的 $01$ 就会变成 $10$。 对于转移过程中的具体操作，由于需要判断状态串中是否存在 $01$，可以采用一种手法： if(((now&gt;&gt;i)&amp;3)!=1)continue; 由于 $3$ 的二进制是 $011$ ，如果也就是判断是否存在 $01$的情况。 之后改变状态： int nxt=now^(3&lt;&lt;i); 之后起始状态和终止状态就很明显了： 起始状态：$000…00111…11$ 终止状态：$111…11000…00$ 之后就是关于如何 DP 的问题了。 其实这个事情是不好办的。 首先这个题目要求我们两个人都要走最优策略。 如果按照我们常规的 DP 思路的话，自然是要设 $f[S]$ 为在 $S$ 这个状态下可以获得多少得分差。 但是对于这种博弈论 DP 的题目是不可以这样做的。 由于两方都要采取最优策略，所以我们不得不考虑将来的行动对现在现在的影响。 如果正序 dp 的话也许会发生当前确实取到了最大值但是其实并不是最优策略。 于是我们可以考虑倒过来 dp。 可以假装我们可以一步看到结局，然后选择对自己最有利的状态。 显然棋盘被布满的状态下没有人可以获得新的分数，那么如果我们用 $f[S]$ 表示从 $S$ 轮廓线的状态距离游戏结束还能得多少分。 那么我们会发现，如果这个局面是先手下完以后形成的，那么如何这个局面如何转移的主动权显然是攥在后手的手里，所以此时这个 dp 值应该由所有后继状态的相对于先手最劣的状态转移过来，也就是所有的后继状态取个 $\\min$。 如果是后手的话，dp值就应该是对于后手最劣的状态转移过来，也就是所有的后继状态取个 $\\max$。 也就是第一个人想要最大化两者的差值，第二个人想要最小化这个差值。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=1e5+5; #define INF 0x3f3f3f3f int n,m; int f[1&lt;&lt;21]; int a[15][15],b[15][15]; bool vis[1&lt;&lt;21]; int dfs(int now,int who)&#123; if(vis[now])return f[now];//记忆化搜索 vis[now]=true; f[now]= who?-INF:INF;//先手取max，所以初始最小，后手取min，所以初始最大 int x=n,y=0; for(re int i=0;i&lt;n+m-1;i++)&#123; if((now&gt;&gt;i)&amp;1)x--; else y++; if(((now&gt;&gt;i)&amp;3)!=1)continue; int nxt=now^(3&lt;&lt;i); if(who)f[now]=max(f[now],dfs(nxt,0)+a[x][y]); else f[now]=min(f[now],dfs(nxt,1)-b[x][y]); &#125; return f[now]; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); for(re int i=0;i&lt;n;i++)&#123; for(re int j=0;j&lt;m;j++)&#123; a[i][j]=read(); &#125; &#125; for(re int i=0;i&lt;n;i++)&#123; for(re int j=0;j&lt;m;j++)&#123; b[i][j]=read(); &#125; &#125; vis[((1&lt;&lt;n)-1)&lt;&lt;m]=true;//倒过来DP，即从结束状态开始 f[((1&lt;&lt;n)-1)&lt;&lt;m]=0; dfs((1&lt;&lt;n)-1,1); printf(&quot;%d\\n&quot;,f[(1&lt;&lt;n)-1]);//最后找到开始状态下对应的答案 return 0; &#125;","path":"2021/06/22/P4363 [九省联考2018]一双木棋chess（轮廓线状压）/","date":"06-22","excerpt":"","tags":[]},{"title":"Kruskal 重构树总结","text":"Kruskal 重构树前言听了 @Wankupi 学长讲了这个东西。 于是就爬过来学了。 确实是很有意思的东西。 不过貌似也很小众，几乎不咋用。 但是性质确实很优美。 特殊的题目也有奇效。 前置知识 Kruskal 算法求解最小生成树。 倍增 主席树 至于为什么需要这些玩意，其实并不必要 在题目里会用到的。 定义这个东西我找遍了各大词条，并没有一个合适的定义。 于是可以跳过。 实现过程在执行 kruskal 的过程中，我们先将边进行排序（排序的方式决定了重构树的性质），之后遍历每一条边，查看这条边的两个端点是否在同一个并查集之内。如果不在，那么就新建一个节点 $node$,这个点的点权等于这条边的边权。 有一张图画的好啊！ 图片来源：@asd369 具体做法： 首先找到两个端点在并查集中的根，之后检查是否在一个并查集中。然后连边就可以了。 namespace Kruskal&#123; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; struct node&#123; int u,v,dis; inline bool operator &lt; (const node &amp;a)const&#123; return dis&lt;a.dis; &#125; &#125;e[maxm&lt;&lt;1]; int ff[maxn]; inline void init()&#123; for(re int i=1;i&lt;maxn;i++)&#123; ff[i]=i; &#125; &#125; int find(int x)&#123; return x==ff[x]?x:ff[x]=find(ff[x]); &#125; int val[maxn&lt;&lt;1],tot; inline void kruskal()&#123; sort(e+1,e+1+m); init(); for(re int i=1;i&lt;=m;i++)&#123; int x=find(e[i].u),y=find(e[i].v); if(x!=y)&#123; val[++tot]=e[i].dis; ff[x]=ff[y]=ff[tot]=tot; add(tot,x);add(tot,y); fa[x][0]=fa[y][0]=tot; &#125; &#125; &#125; &#125; 性质 Kruskal 重构树是一棵树（这不是废话？！ 而且他还是一棵二叉树（虽然看上去也是废话 还是一棵有根树，根节点就是最后新建的节点。 若原图不连通，那么建出来的 Kruskal 重构树就是一个森林。 如果一开始按照边权升序排序，那么建出的 Kruskal 重构树就是一个大根堆，反之就是小根堆。 若一开始按照边权升序排序，那么 lca(u,v) 的权值代表了原图中 $u$ 到 $v$ 路径上最大边权的最小值。反之就是最小边权的最大值。 Kruskal 重构树中的叶子结点必定是原图中的节点，其余的节点都是原图的一条边。 Kruskal 重构树建好以后会比原图多出 $n-1$ 个节点（如果原图联通的话） 一条一条来看： 对于性质 $1$ 和 $2$，比较显然，我们就不说了。 对于性质 $3$ 和 $4$，由于一开始对边权升序排序，所以我们首先遍历到的边一定是权值最小的。 于是对于 Kruskal 重构树中的某一个节点，它的子树中任意一个节点的权值一定小于它本身。 那么可以知道，权值越小的深度越大，权值越大的深度越小。 于是这是大根堆性质。 有了大根堆性质，我们可以发现，由于边权升序，其实就是求解最小生成树的过程，于是能出现在 Kruskal 重构树中的节点必然是要满足也出现在原图的最小生成树中的，那么在找 LCA 的过程中，找到的必然是在 Kruskal 重构树上这条路径中深度最小的点，也就是权值最大的。对于原图来说，这个权值最大的恰好是从 $u$ 到 $v$ 最小值。 若一个点能通过一条路径到达，那么我们走最小生成树上的边也一定能到达该节点。 于是满足了最大值最小的性质。 同理降序也能够得出最小值最大的性质。 对于性质 $5$，可以画图解决。 对于性质 $6$，可以发现，建出 Kruskal 重构树的过程其实也就是求解最小生成树的过程，那么 Kruskal 重构树中新增加的节点数也就是最小生成树中的边数。而最小生成树中的边数最多是 $n-1$ 条，于是 Kruskal 重构树中新增加的节点数也就是 $n-1$ 个。 应用根据上面的性质们，Kruskal 重构树有几种常见用法： u-&gt;v路径上的最大值最小 or u-&gt;v路径上的最小值最大这就是上面的性质 $3$ 和 $4$ 了。 于是直接套板子就行了。 也给我们一个提示，遇到这种最大值最小或者最小值最大这种类似的语句，可以不急着想二分，还可以想想 Kruskal 重构树。 例题就是 P1967 [NOIP2013 提高组] 货车运输 求解路径上最小值最大。 将边降序排序，建出 Kruskal 重构树，注意处理一下有可能是个森林。 lca 怎么搞都行，不过我喜欢树剖，比较优雅。 查询在 Kruskal 重构树中 lca(u,v） 的权值就好了。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=1e5+5; #define INF 0x3f3f3f3f int n,m,tot,q; struct node&#123; int u,v,dis; inline bool operator &lt; (const node &amp;a)const&#123; return dis&gt;a.dis; &#125; &#125;a[maxn&lt;&lt;1]; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; int val[maxn&lt;&lt;1]; inline void add(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt; &#125; int dep[maxn],size[maxn],fa[maxn],son[maxn],top[maxn]; bool vis[maxn]; void dfs1(int u,int f)&#123; size[u]=1; vis[u]=true; fa[u]=f; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u]||v==son[u])continue; dfs2(v,v); &#125; &#125; inline int lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y; &#125; int ff[maxn]; int find(int x)&#123; return x==ff[x]?x:ff[x]=find(ff[x]); &#125; inline void init()&#123; for(re int i=1;i&lt;maxn;i++)&#123; ff[i]=i; &#125; &#125; inline void Kruskal()&#123; sort(a+1,a+1+m); init(); for(re int i=1;i&lt;=m;i++)&#123; int x=find(a[i].u),y=find(a[i].v); if(x!=y)&#123; val[++tot]=a[i].dis; ff[tot]=ff[x]=ff[y]=tot; add(tot,x); add(tot,y); &#125; &#125; for(re int i=1;i&lt;=tot;i++)&#123; if(!vis[i])&#123; int f=find(i); dfs1(f,0); dfs2(f,f); &#125; &#125; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read();tot=n; for(re int i=1;i&lt;=m;i++)&#123; a[i].u=read();a[i].v=read();a[i].dis=read(); &#125; Kruskal(); q=read(); while(q--)&#123; int u=read(),v=read(); if(find(u)!=find(v))puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;,val[lca(u,v)]); &#125; return 0; &#125; 从 u 出发只经过边权不超过 x 的边能到达的节点根据性质 $3$，可以发现，只需要找到边权升序的 Kruskal 重构树中找到深度最小的，点权不超过 $x$ 的节点，那么这个节点的子树即为所求。 找这个点一般用树上倍增 我不要！！！！树剖党声嘶力竭 没办法这玩意还是倍增好 我们考虑当前我们找到的这个节点为 $x$，然后我们倍增枚举它的祖先，由于是升序排序，所以它祖先的点的点权必然大于等于它的点权，于是，我们倍增的时候只要判断如果它的祖先的点权就好了。 inline void kruskal()&#123; sort(e+1,e+1+m); init(); for(re int i=1;i&lt;=m;i++)&#123; int x=find(e[i].u),y=find(e[i].v); if(x!=y)&#123; val[++tot]=e[i].dis; ff[x]=ff[y]=ff[tot]=tot; add(tot,x);add(tot,y); fa[x][0]=fa[y][0]=tot; &#125; &#125; dfs(tot); &#125; namespace BIN&#123; int fa[maxn&lt;&lt;1][21],range[maxn&lt;&lt;1][2]; void dfs(int u)&#123; for(re int i=1;i&lt;=20;i++)&#123; fa[u][i]=fa[fa[u][i-1]][i-1]; &#125; ... &#125; &#125; int main()&#123; while(q--)&#123; int u=read(),x=read(); for(re int i=20;~i;i--)&#123; if(fa[u][i]&amp;&amp;val[fa[u][i]]&lt;=x)v=fa[u][i]; &#125; &#125; &#125; 大概就是这样的。 例题：P4197 Peaks 这个题其实也能用线段树合并做。 其实这个题在题单里躺了好久了，本来是打算线段树合并做的，然后学了重构树于是就用重构树了。 主体思路是裸的，多出来的就是一个第 $k$ 大。 这就是为啥我说需要主席树当做前置知识 然后子树区间第 $k$ 大，dfs 序 + 主席树大力维护就行了。 码农题，不好，思维题，好！ 但是思维题不会做嘤嘤嘤 其实还是有很多细节问题的。 首先问题就是关于无解情况的判断。 肯定是对于一个满足条件的子树，子树中节点个数不足 $k$ 个。 需要注意的是，由于 Kruskal 重构树的性质 $5$，我们知道在 Kruskal 重构树中只有叶子节点才是会对答案产生贡献的，于是我们需要统计的子树大小并不是我们以往统计的那样，而是只统计叶子节点。 实现也很简单： void dfs(int u)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u][0])continue; fa[v][0]=u; dfs(v); size[u]+=size[v]; &#125; if(!size[u])size[u]=1; &#125; 剩下的部分其实就好说很多了。 注意一下离散化就行了。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=2e5+5; const int maxm=5e5+5; #define INF 0x3f3f3f3f int n,m,q,tmp,num; int a[maxn],b[maxn]; int head[maxn&lt;&lt;1],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; namespace SegmentTree&#123; inline void Discretization()&#123; sort(b+1,b+1+n); tmp=unique(b+1,b+1+n)-b-1; for(re int i=1;i&lt;=n;i++)a[i]=lower_bound(b+1,b+1+tmp,a[i])-b; &#125; struct SegmentTree&#123; int lc,rc,v; #define ls(x) st[x].lc #define rs(x) st[x].rc &#125;st[maxn&lt;&lt;6]; int segtot,root[maxn&lt;&lt;1]; void build(int &amp;rt,int l,int r)&#123; rt=++segtot; if(l==r)return; int mid=(l+r)&gt;&gt;1; build(ls(rt),l,mid); build(rs(rt),mid+1,r); &#125; int modify(int rt,int l,int r,int x)&#123; int t=++segtot; ls(t)=ls(rt),rs(t)=rs(rt); st[t].v=st[rt].v+1; if(l==r)return t; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)ls(t)=modify(ls(t),l,mid,x); else rs(t)=modify(rs(t),mid+1,r,x); return t; &#125; int query(int x,int y,int l,int r,int k)&#123; int xx=st[rs(y)].v-st[rs(x)].v; if(l==r)return l; int mid=(l+r)&gt;&gt;1; if(k&lt;=xx)return query(rs(x),rs(y),mid+1,r,k); else return query(ls(x),ls(y),l,mid,k-xx); &#125; &#125; using namespace SegmentTree; namespace BIN&#123; int fa[maxn&lt;&lt;1][30],pos[maxn&lt;&lt;1],st1[maxn&lt;&lt;1],ed[maxn&lt;&lt;1],size[maxn&lt;&lt;1]; void dfs(int u)&#123; pos[++num]=u;st1[u]=num; for(re int i=1;i&lt;=25;i++)&#123; fa[u][i]=fa[fa[u][i-1]][i-1]; &#125; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u][0])continue; fa[v][0]=u; dfs(v); size[u]+=size[v]; &#125; if(!size[u])size[u]=1; ed[u]=num; &#125; &#125; using namespace BIN; namespace Kruskal&#123; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; struct node&#123; int u,v,dis; inline bool operator &lt; (const node &amp;a)const&#123; return dis&lt;a.dis; &#125; &#125;e[maxm]; int ff[maxn&lt;&lt;1]; inline void init()&#123; for(re int i=1;i&lt;maxn;i++)&#123; ff[i]=i; &#125; &#125; int find(int x)&#123; return x==ff[x]?x:ff[x]=find(ff[x]); &#125; int val[maxn&lt;&lt;1],tot; inline void kruskal()&#123; sort(e+1,e+1+m); init(); for(re int i=1;i&lt;=m;i++)&#123; int x=find(e[i].u),y=find(e[i].v); if(x!=y)&#123; val[++tot]=e[i].dis; ff[x]=ff[y]=ff[tot]=tot; add(tot,x);add(tot,y); &#125; &#125; dfs(tot); &#125; &#125; using namespace Kruskal; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read();q=read();tot=n; for(re int i=1;i&lt;=n;i++)&#123; a[i]=b[i]=read(); &#125; Discretization(); for(re int i=1;i&lt;=m;i++)&#123; e[i].u=read(); e[i].v=read(); e[i].dis=read(); &#125; kruskal(); for(re int i=1;i&lt;=tot;i++)&#123; root[i]=root[i-1]; if(pos[i]&lt;=n)root[i]=modify(root[i-1],1,tmp,a[pos[i]]); &#125; while(q--)&#123; int v=read(),x=read(),k=read(); for(re int i=25;~i;i--)&#123; if(fa[v][i]&amp;&amp;val[fa[v][i]]&lt;=x)v=fa[v][i]; &#125; if(size[v]&lt;k)&#123; puts(&quot;-1&quot;); continue; &#125; else printf(&quot;%d\\n&quot;,b[query(root[st1[v]-1],root[ed[v]],1,tmp,k)]); &#125; return 0; &#125; 看了题解以后发现这题也可以不使用 dfs 序，由于每个节点直接对应一个区间，所以可以直接处理。 注意区间是左开右闭的。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=1e5+5; const int maxm=5e5+5; #define INF 0x3f3f3f3f int n,m,q,tmp,num; int a[maxn],b[maxn]; int head[maxn&lt;&lt;1],to[maxm&lt;&lt;1],nxt[maxm&lt;&lt;1],cnt; namespace SegmentTree&#123; inline void Discretization()&#123; sort(b+1,b+1+n); tmp=unique(b+1,b+1+n)-b-1; for(re int i=1;i&lt;=n;i++)a[i]=lower_bound(b+1,b+1+tmp,a[i])-b; &#125; struct SegmentTree&#123; int lc,rc,v; #define ls(x) st[x].lc #define rs(x) st[x].rc &#125;st[maxn&lt;&lt;5]; int segtot,root[maxn]; void build(int &amp;rt,int l,int r)&#123; rt=++segtot; if(l==r)return; int mid=(l+r)&gt;&gt;1; build(ls(rt),l,mid); build(rs(rt),mid+1,r); &#125; int modify(int rt,int l,int r,int x)&#123; int t=++segtot; ls(t)=ls(rt),rs(t)=rs(rt); st[t].v=st[rt].v+1; if(l==r)return t; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)ls(t)=modify(ls(t),l,mid,x); else rs(t)=modify(rs(t),mid+1,r,x); return t; &#125; int query(int x,int y,int l,int r,int k)&#123; int xx=st[rs(y)].v-st[rs(x)].v; if(l==r)return l; int mid=(l+r)&gt;&gt;1; if(k&lt;=xx)return query(rs(x),rs(y),mid+1,r,k); else return query(ls(x),ls(y),l,mid,k-xx); &#125; &#125; using namespace SegmentTree; namespace BIN&#123; int fa[maxn&lt;&lt;1][21],range[maxn&lt;&lt;1][2]; void dfs(int u)&#123; for(re int i=1;i&lt;=20;i++)&#123; fa[u][i]=fa[fa[u][i-1]][i-1]; &#125; range[u][0]=num; if(!head[u])&#123; range[u][1]=++num; root[num]=modify(root[num-1],1,tmp,a[u]); return; &#125; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; dfs(v); &#125; range[u][1]=num; &#125; &#125; using namespace BIN; namespace Kruskal&#123; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; struct node&#123; int u,v,dis; inline bool operator &lt; (const node &amp;a)const&#123; return dis&lt;a.dis; &#125; &#125;e[maxm&lt;&lt;1]; int ff[maxn]; inline void init()&#123; for(re int i=1;i&lt;maxn;i++)&#123; ff[i]=i; &#125; &#125; int find(int x)&#123; return x==ff[x]?x:ff[x]=find(ff[x]); &#125; int val[maxn&lt;&lt;1],tot; inline void kruskal()&#123; sort(e+1,e+1+m); init(); for(re int i=1;i&lt;=m;i++)&#123; int x=find(e[i].u),y=find(e[i].v); if(x!=y)&#123; val[++tot]=e[i].dis; ff[x]=ff[y]=ff[tot]=tot; add(tot,x);add(tot,y); fa[x][0]=fa[y][0]=tot; &#125; &#125; build(root[0],1,tmp); dfs(tot); &#125; &#125; using namespace Kruskal; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read();q=read();tot=n; for(re int i=1;i&lt;=n;i++)&#123; a[i]=b[i]=read(); &#125; Discretization(); for(re int i=1;i&lt;=m;i++)&#123; e[i].u=read(); e[i].v=read(); e[i].dis=read(); &#125; kruskal(); while(q--)&#123; int v=read(),x=read(),k=read(); for(re int i=20;~i;i--)&#123; if(fa[v][i]&amp;&amp;val[fa[v][i]]&lt;=x)v=fa[v][i]; &#125; if(range[v][1]-range[v][0]&lt;k)&#123; puts(&quot;-1&quot;); continue; &#125; else printf(&quot;%d\\n&quot;,b[query(root[range[v][0]],root[range[v][1]],1,tmp,k)]); &#125; return 0; &#125;","path":"2021/06/21/Kruskal 重构树总结/","date":"06-21","excerpt":"","tags":[]},{"title":"树上差分总结","text":"是时候总结一下树上差分一类题目的套路了。 树上差分像差分一样，树上差分也有前缀和思想。 一个点的真实权值是一个点子树内所有差分后的权值之和总的来说就是一个点的差分数组最后的值是整个子树内差分数组的和，再加进点的权值里。 至于差分和前缀和的关系那就不必明说了。 树上差分可以分为两种（如果是一条链上都加 $1$）： 对于点的覆盖：$u++$ $v++$ $LCA- -$ $fa[LCA]- -$ 对于边的覆盖：$u++$ $v++$ $LCA-=2$ 之后就是例题： 点差分例题：P3128 [USACO15DEC]Max Flow P 其实第一眼看上去这个名字我还以为是个网络流 点差分裸题，没有任何细节可言。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=5e4+5; #define INF 0x3f3f3f3f int n,k,maxx; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int size[maxn],dep[maxn],fa[maxn],son[maxn],top[maxn]; void dfs1(int u,int f)&#123; size[u]=1; fa[u]=f; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u]||v==son[u])continue; dfs2(v,v); &#125; &#125; inline int lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y; &#125; int cntt[maxn]; void sum(int u,int f)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; sum(v,u); cntt[u]+=cntt[v]; &#125; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();k=read(); for(re int i=1,u,v;i&lt;n;i++)&#123; u=read();v=read(); add(u,v); add(v,u); &#125; dfs1(1,0); dfs2(1,1); for(re int i=1,s,t;i&lt;=k;i++)&#123; s=read();t=read(); int LCA=lca(s,t); cntt[s]++; cntt[t]++; cntt[LCA]--; cntt[fa[LCA]]--; &#125; sum(1,0); for(re int i=1;i&lt;=n;i++)&#123; maxx=max(maxx,cntt[i]); &#125; printf(&quot;%d\\n&quot;,maxx); return 0; &#125; P3258 [JLOI2014]松鼠的新家 依然是点差分的裸题，只不过这一次有一些细节了。 唯一的细节是把即是起点也是终点的点算了两边。 最后减掉就行了。 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=3e5+5; const int maxm=1; int n; int a[maxn]; int head[maxn],fr[maxn&lt;&lt;1],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; fr[cnt]=u; to[cnt]=v; head[u]=cnt; &#125; int dep[maxn],fa[maxn],son[maxn],top[maxn],size[maxn]; void dfs1(int u,int f)&#123; fa[u]=f; size[u]=1; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(top[v])continue; dfs2(v,v); &#125; &#125; inline int lca(int u,int v)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); u=fa[top[u]]; &#125; return dep[u]&lt;dep[v]?u:v; &#125; int cntt[maxn]; void sum(int u,int f)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; sum(v,u); cntt[u]+=cntt[v]; &#125; &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read(); for(re int i=1;i&lt;=n;i++)&#123; a[i]=read(); &#125; for(re int i=1,u,v;i&lt;n;i++)&#123; u=read();v=read(); add(u,v); add(v,u); &#125; dfs1(1,0); dfs2(1,1); for(re int i=1,u,v;i&lt;n;i++)&#123; u=a[i],v=a[i+1]; int LCA=lca(u,v); cntt[u]+=1; cntt[v]+=1; cntt[LCA]-=1; cntt[fa[LCA]]-=1; &#125; sum(1,0); for(re int i=2;i&lt;=n;i++)&#123; cntt[a[i]]--; &#125; for(re int i=1;i&lt;=n;i++)&#123; printf(&quot;%d\\n&quot;,cntt[i]); &#125; return 0; &#125; P1600 [NOIP2016 提高组] 天天爱跑步 这个题就有点意思了。 题目简述：给定一棵树和 $m$ 个节点，然后给定一些路径，对于树上的点 $i$，问有多少路径的 从起点出发，经过 $w_j$ 以后恰好到达这个点。 首先第一反应也许是每一条路径一条一条看。 但是数据中显然有一条链的数据，于是 $O(nm)$的复杂度只能喝西北风。 于是可以考虑换一个角度。 我们能不能对于每一个点，看一看路径对他的贡献？ 对于一个任意的路径 $s-&gt;t$ ，在树上显然地可以拆成 $s-&gt;LCA,LCA-&gt;t$，两个部分来看。 对于 $s-&gt;LCA$ 的路径，明显地可以发现，当这条路径对当前节点 $x$ 有贡献当且仅当 $dep[s]-dep[x]=w[x]$，通过移项得到 $dep[s]=dep[x]+w[x]$。 对于 $LCA-&gt;t$ 的路径，需要满足：$dep[s]+dep[x]-2 \\times dep[LCA(s,t)]=w[x]$ 依旧通过移项得到：$2 \\times dep[LCA(s,t)]-dep[s]=dep[x]-w[x]$。 这里运用到了一种把 $s$ 关于 $LCA$ 翻上去的方法。其实这种思想小学或者初中就已经学过了移项的手法是把带 $x$ 的都扔在一边，把已知的量扔在另一边。 于是这直接启示我们，可以在每个节点以 $dep$ 为下标进行统计。 之后对于 $s-&gt;LCA$ 路线，查询 $dep[x]+w[x]$ 出现多少次，对于 $LCA-&gt;t$ 路线，统计 $dep[x]-w[x]$ 出现多少次即可。 需要单点更改，单点查询。还要答案合并？ 直接祭出线段树合并吧。 简单好写，思路清晰。 于是对于每一条路径，我们直接在起点位置的线段树 $dep[s]$ 下标 $++$，$LCA(s,t)$ 位置 $dep[s]$ 下标 $–$，在终点位置的线段树 $2 \\times dep[LCA(s,t)]-dep[s]$ 下标 $++$，$fa[LCA]$位置 $2 \\times dep[LCA(s,t)]-dep[s]$ 下标 $–$； for(re int i=1,x,y;i&lt;=m;i++)&#123; x=read();y=read(); int LCA=lca(x,y); modify(root[x],1,n&lt;&lt;1,n+dep[x],1); modify(root[y],1,n&lt;&lt;1,n+2*dep[LCA]-dep[x],1); modify(root[LCA],1,n&lt;&lt;1,n+dep[x],-1); modify(root[fa[LCA]],1,n&lt;&lt;1,n+2*dep[LCA]-dep[x],-1); &#125; 最后合并线段树，然后上行路线查询 $dep[u]+w[u]$，下行路线查询 $dep[u]-w[u]$ 就可以了。 void dfs(int u)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u])continue; dfs(v); root[u]=merge(root[u],root[v],1,n&lt;&lt;1); &#125; if(w[u]&amp;&amp;n+dep[u]+w[u]&lt;=(n&lt;&lt;1))&#123;//判断越界 ans[u]+=query(root[u],1,n&lt;&lt;1,n+dep[u]+w[u]);//s-&gt;LCA &#125; ans[u]+=query(root[u],1,n&lt;&lt;1,n+dep[u]-w[u]);//LCA-&gt;t &#125; 需要注意的是，由于我们把 $s$ 关于 $LCA$ 翻上去的时候深度可能变成负数，所以我们可以直接把值域平移一下。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=3e5+5; #define INF 0x3f3f3f3f int n,m,w[maxn]; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; namespace Tree_chain_partition&#123; int size[maxn],son[maxn],dep[maxn],fa[maxn],top[maxn]; void dfs1(int u,int f)&#123; fa[u]=f; size[u]=1; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(top[v])continue; dfs2(v,v); &#125; &#125; inline int lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y; &#125; &#125; namespace SegmentTree&#123; #define ls st[rt].lc #define rs st[rt].rc int root[maxn],tot; struct SegmentTree&#123; int lc,rc,v; &#125;st[maxn&lt;&lt;6]; void modify(int &amp;rt,int l,int r,int pos,int val)&#123; if(!rt)rt=++tot; if(l==r)&#123; st[rt].v+=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)modify(ls,l,mid,pos,val); else modify(rs,mid+1,r,pos,val); &#125; int query(int rt,int l,int r,int pos)&#123; if(!rt)rt=++tot; if(l==r)return st[rt].v; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)return query(ls,l,mid,pos); else return query(rs,mid+1,r,pos); &#125; int merge(int p,int q,int l,int r)&#123; if(!p||!q)return p|q; if(l==r)&#123; st[p].v+=st[q].v; return p; &#125; int mid=(l+r)&gt;&gt;1; st[p].lc=merge(st[p].lc,st[q].lc,l,mid); st[p].rc=merge(st[p].rc,st[q].rc,mid+1,r); return p; &#125; &#125; using namespace Tree_chain_partition; using namespace SegmentTree; int ans[maxn]; void dfs(int u)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u])continue; dfs(v); root[u]=merge(root[u],root[v],1,n&lt;&lt;1); &#125; if(w[u]&amp;&amp;n+dep[u]+w[u]&lt;=(n&lt;&lt;1))&#123; ans[u]+=query(root[u],1,n&lt;&lt;1,n+dep[u]+w[u]);//s-&gt;LCA &#125; ans[u]+=query(root[u],1,n&lt;&lt;1,n+dep[u]-w[u]);//LCA-&gt;t &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; #define debug cout&lt;&lt;&quot;warning!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); for(re int i=1,u,v;i&lt;n;i++)&#123; u=read();v=read(); add(u,v); add(v,u); &#125; dfs1(1,0); dfs2(1,1); for(re int i=1;i&lt;=n;i++)&#123; w[i]=read(); &#125; for(re int i=1,x,y;i&lt;=m;i++)&#123; x=read();y=read(); int LCA=lca(x,y); modify(root[x],1,n&lt;&lt;1,n+dep[x],1); modify(root[y],1,n&lt;&lt;1,n+2*dep[LCA]-dep[x],1); modify(root[LCA],1,n&lt;&lt;1,n+dep[x],-1); modify(root[fa[LCA]],1,n&lt;&lt;1,n+2*dep[LCA]-dep[x],-1); &#125; dfs(1); for(re int i=1;i&lt;=n;i++)&#123; printf(&quot;%d &quot;,ans[i]); &#125; return 0; &#125; 边差分例题P2680 [NOIP2015 提高组] 运输计划 这个题也挺好玩。 很容易就想到一个假思路。 直接找被经过次数最多的路径，然后删掉就行了。 错误性其实也很好想 如果有一条巨大的边权，比如 $1e3$，然后别的边都是 $1$，然后这个做法就直接没了。 于是重新审视这道题目：由于我们工作是同时开展的，于是所需要的总时间就是需要时间最长的那个。 于是要求删掉一条边以后最长的路径权值最小。 二分的模型？ 然后自然而然地想到要二分这个值。 对于一条路，如果花费一段时间可以走完，那么如果给他更长的时间，他肯定也是可以走完的。 单调性显然。 于是可以二分去除这个边以后最大剩余路径的最小值。 并且需要判断，树上是否存在一条边，被比目前二分值更大的边全部覆盖。 然后我们需要找到需要被清除的边。 这条边理应是被所有大于等于当前二分值的路径都经过且长度尽量长的边。 int num[maxn],res,sum; void get_sum(int u,int f)&#123;//树上前缀和统计经过次数 for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; get_sum(v,u); num[u]+=num[v]; &#125; if(num[u]==sum&amp;&amp;val[u]&gt;res)res=val[u];//被所有大于mid的路径经过并且长度最长 &#125; inline bool check(int x)&#123; memset(num,0,sizeof(num)); sum=res=0; for(re int i=1;i&lt;=m;i++)&#123; if(q[i].d&gt;x)&#123; num[q[i].x]++; num[q[i].y]++; num[q[i].lca]-=2; sum++; &#125; &#125; get_sum(1,0); if(road-res&lt;=x)return true;//如果最长路径减去路径上最长的边可以比二分值更小，满足条件。 //容易想到，如果最长路径都可以，那么别的路径一定也可以 return false; &#125; 关于 $dis$（节点到根节点路径的边权和），用树上前缀和，树剖的时候顺便就搞出来了。 d(x,y)=dis[x]+dis[y]-2*dis[LCA(x,y)] //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=3e5+5; #define INF 0x3f3f3f3f int n,m,Max,road; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],w[maxn&lt;&lt;1],cnt; inline void add(int u,int v,int val)&#123; nxt[++cnt]=head[u]; to[cnt]=v; w[cnt]=val; head[u]=cnt; &#125; namespace Tree_chain_partition&#123; int size[maxn],dep[maxn],top[maxn],fa[maxn],son[maxn]; int dis[maxn],val[maxn],tot; void dfs1(int u,int f)&#123; size[u]=1; fa[u]=f; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; val[v]=w[i]; dis[v]=dis[u]+w[i]; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==son[u]||v==fa[u])continue; dfs2(v,v); &#125; &#125; inline int lca(int u,int v)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); u=fa[top[u]]; &#125; return dep[u]&lt;dep[v]?u:v; &#125; &#125; struct node&#123; int x,y,lca,d; &#125;q[maxn]; using namespace Tree_chain_partition; int num[maxn],res,sum; void get_sum(int u,int f)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; get_sum(v,u); num[u]+=num[v]; &#125; if(num[u]==sum&amp;&amp;val[u]&gt;res)res=val[u]; &#125; inline bool check(int x)&#123; memset(num,0,sizeof(num)); sum=res=0; for(re int i=1;i&lt;=m;i++)&#123; if(q[i].d&gt;x)&#123; num[q[i].x]++; num[q[i].y]++; num[q[i].lca]-=2; sum++; &#125; &#125; get_sum(1,0); if(road-res&lt;=x)return true; return false; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); for(re int i=1,u,v,val;i&lt;n;i++)&#123; u=read();v=read();val=read(); add(u,v,val); add(v,u,val); Max=max(Max,val); &#125; dfs1(1,0); dfs2(1,1); for(re int i=1;i&lt;=m;i++)&#123; q[i].x=read();q[i].y=read(); q[i].lca=lca(q[i].x,q[i].y); q[i].d=dis[q[i].x]+dis[q[i].y]-2*dis[q[i].lca]; road=max(road,q[i].d); &#125; int l=road-Max,r=road; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))r=mid; else l=mid+1; &#125; printf(&quot;%d\\n&quot;,l); return 0; &#125;","path":"2021/06/14/树上差分总结/","date":"06-14","excerpt":"","tags":[]},{"title":"CF545E Paths and Trees（最短路径树）","text":"CF545E Paths and Trees前言：学这个的时候看了一些博客，感觉其实这一块网上很多博客和题解其实一些细节没有说太清楚。于是今天主要想说一下关于最短路径树的一些细节与处理问题。 最短路径树$SPT$，就是从一张连通图中，有树满足从根节点到任意点的路径都为原图中根到任意点的最短路径的树。 $SBT$ 有以下特点： 树上任意不属于根的节点 $x$，$dis(root,x)=$ 原图走到 $x$ 的最短路。 全图联通，且有 $n-1$ 条边。 与最小生成树的区别：最小生成树只需要满足全图联通就可以了。 这个问题这篇日报写的很清楚。 一般用 Dijkstra 实现。 大家都知道， Dijkstra 实现过程就像是一条一条把边拉进来，于是我们只需要在松弛操作的时候记录一下前驱就可以了。 这个与一般的 Dijkstra 无异。 int pre[maxn]; bool vis[maxn]; ll dis[maxn],ans[maxn]; #define P pair&lt;ll,int&gt; #define mp make_pair inline void Dijkstra(int s)&#123; priority_queue &lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; memset(vis,0,sizeof(vis)); memset(dis,0x3f,sizeof(dis)); dis[s]=0; q.push(mp(0,s)); while(!q.empty())&#123; int x=q.top().second;q.pop(); if(vis[x])continue; vis[x]=true; for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(dis[v]&gt;=dis[x]+w[i])&#123; dis[v]=dis[x]+w[i]; pre[v]=i;//记录前驱 q.push(mp(dis[v],v)); &#125; &#125; &#125; &#125; 复杂度 $O((n+m)logn)$ 细节部分$1$：关于这道题的题目要求（权值和最小）：如何考虑 给定一张带正权的无向图和一个源点，求边权和最小的最短路径树。 要求我们求出边权和最小的。 可以画图理解： 显然，从节点 $1$ 到 节点 $5$ 有两条路径都是最短的。 如果选择 $1-&gt;2-&gt;3-&gt;5$ 这一条，那么最短路树长这个样子： 权值和是 $1+1+1+1=4$. 如果选择 $1-&gt;4-&gt;5$ 这一条，最短路树长这样： 权值和是 $1+1+1+2=5$. 根据题意，选择上面那一种。 为什么？ 我们反向考虑： 当我们找到一个节点，发现有两条路径都是最短路，为了求最短路径树，必然只有一条路能被选到，也就是说，一个边会成为树边，另一个就是非树边，而最短路径树权值和最小是针对树边而言的，于是我们选择的问题就集中在连接这个点的两条边哪一个更小，并使之成为树边。 有的题解会这么写： 为了满足本题的要求，还要生成树边权最小。自然是两点间路程相等情况下，经过的边数越多越好 其实这是不正确的。 通过一张图来看： 可以发现，从节点 $1$ 到节点 $4$ 的最短路有两条。 路线一 $1-&gt;2-&gt;3-&gt;4$ ，边数是 $3$， 路线二 $1-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;4$ ， 边数是 $6$. 若选择路线一： 最短路树： 权值和为 $10+10+10+2+2+2+2+2=40$. 若选择路线二： 最短路树： 权值和为 $10+10+2+2+2+2+2+20=50$. 代码实现在满足这个问题的时候，大部分题解都会这么写： for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(dis[v]&gt;dis[x]+w[i])&#123; dis[v]=dis[x]+w[i]; pre[v]=i; q.push(mp(dis[v],v)); &#125; else if(dis[v]==dis[x]+w[i]&amp;&amp;w[i]&lt;w[pre[v]])pre[v]=i; &#125; 就是说他们把权值相等时单独拿出来进行判断，进行松弛的时候如果松弛前的结果与松弛后的结果相等即 $dis[now]=dis[next]+w$，比较连接这条点的边的大小，即 $w[i]$ 与 $w[pre[next]]$ ，如果 $w[i]&lt;w[pre[next]]$，那么更新当前的 $pre$ 。 其实这是完全没必要的。 画图理解： 假如现在只有一个点没有在最短路树中。 由于我们使用的是堆优化的 Dijkstra ，所以率先被扩展出来的点的 $dis$ 一定是更小的。 比如上图中，如果想要扩展到 $5$ ，那么只能从 $3$ 或者 $4$ 而来。 $dis[4]=1$ ,$dis[3]=2$ ，$dis[4]&lt;dis[3]$， 显然是 $4$ 先扩展出来，然后才能扩展 $5$ 。 又因为他们的路径权值是一样的，这只能说明 连接 $3,5$ 的边的权值是小于连接 $4,5$ 的边的权值的。 根据上面的内容，我们需要选择 $3-&gt;5$ 这个边。 于是可以发现： 在最短路相等的情况下，扩展到同一个节点，后出堆的点连的边权值一定更小 所以我们直接就可以省去分类讨论的功夫，直接把他们写在一起： for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(dis[v]&gt;=dis[x]+w[i])&#123;//这里加上等号 dis[v]=dis[x]+w[i]; pre[v]=i; q.push(mp(dis[v],v)); &#125; //else if(dis[v]==dis[x]+w[i]&amp;&amp;w[i]&lt;w[pre[v]])pre[v]=i; //上面这行直接删掉 &#125; $2$：关于边的 $id$ 记录也有一些同志写的时候喜欢记录一下边的 $id$ ，虽然这样做也可以，但是我个人更喜欢另外一种方式：在循环的时候直接用 $i$ 来作为 $id$ ，这样做会省下一些空间虽然这些空间完全没有省下的必要 单独开 $id$ ： int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],id[maxn&lt;&lt;1],cnt; ll w[maxn&lt;&lt;1]; inline void add(int u,int v,ll val,int i)&#123; nxt[++cnt]=head[u]; to[cnt]=v; w[cnt]=val; id[cnt]=i; head[u]=cnt; &#125; int main()&#123; n=read();m=read();k=read(); for(re int i=1,u,v;i&lt;=m;i++)&#123; ll val; u=read();v=read();val=read(); add(u,v,val,i); add(v,u,val,i); &#125; ... &#125; 用循环变量索引： int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; ll w[maxn&lt;&lt;1]; inline void add(int u,int v,ll val)&#123; nxt[++cnt]=head[u]; to[cnt]=v; w[cnt]=val; head[u]=cnt; &#125; int main()&#123; n=read();m=read();k=read(); for(re int i=1,u,v;i&lt;=m;i++)&#123; ll val; u=read();v=read();val=read(); add(u,v,val); add(v,u,val); &#125; ... &#125; 但是需要注意的是，如果单独开一个 $id$ 数组用来记录 $id$ 的话，那么最后 $dfs$ 的时候 $id$ 就直接是答案了。 但是如果使用循环变量 $i$ 来进行索引，那么最后得出答案时需要 $(ans[i]+1)/2)$. 具体原因也很好想。 单独记录 $id$ 的话，双向边的 $id$ 是一样的，而循环变量索引却导致两条双向边 $id$ 不一样。 单独开 $id$ ： void dfs(int u)&#123; if(tot&gt;=k)return; vis[u]=true; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i],pos=id[i]; if(vis[v])continue; if(dis[v]==dis[u]+w[i])&#123; ans[++h]=pos; tot++; dfs(v); if(tot&gt;=k)return; &#125; &#125; &#125; int main()&#123; ... dfs(1); for(re int i=1;i&lt;=h;i++)&#123; printf(&quot;%d &quot;,ans[i]); &#125; &#125; 用循环变量索引： void dfs(int u)&#123; if(tot&gt;=k)return; vis[u]=true; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(vis[v])continue; if(dis[v]==dis[u]+w[i])&#123; ans[++h]=i; tot++; dfs(v); if(tot&gt;=k)return; &#125; &#125; &#125; int main()&#123; ... dfs(1); for(re int i=1;i&lt;=h;i++)&#123; printf(&quot;%d &quot;,(ans[i]+1)/2); &#125; &#125; $3$：关于输出问题这个题完全不用排序啊。 You may print the numbers of the edges in any order. If there are multiple answers, print any of them. 虽然题目翻译没说这个问题，但是关于输入输出的英文原文还是要看看的吧。 不太懂为什么别的题解要排一遍序。 long long 还是要开的。 CODE://#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=3e5+5; #define INF 0x3f3f3f3f3f3f3f3f int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; ll w[maxn&lt;&lt;1]; inline void add(int u,int v,ll val)&#123; nxt[++cnt]=head[u]; to[cnt]=v; w[cnt]=val; head[u]=cnt; &#125; int pre[maxn]; bool vis[maxn]; ll dis[maxn],ans[maxn]; #define P pair&lt;ll,int&gt; #define mp make_pair inline void Dijkstra(int s)&#123; priority_queue &lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; memset(vis,0,sizeof(vis)); memset(dis,0x3f,sizeof(dis)); dis[s]=0; q.push(mp(0,s)); while(!q.empty())&#123; int x=q.top().second;q.pop(); if(vis[x])continue; vis[x]=true; for(re int i=head[x];i;i=nxt[i])&#123; int v=to[i]; if(dis[v]&gt;=dis[x]+w[i])&#123; dis[v]=dis[x]+w[i]; pre[v]=i; q.push(mp(dis[v],v)); &#125; //else if(!vis[v]&amp;&amp;dis[v]==dis[x]+w[i]&amp;&amp;w[i]&lt;w[pre[v]])pre[v]=i; &#125; &#125; &#125; int n,m,s; inline ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); for(re int i=1,x,y;i&lt;=m;i++)&#123; ll val; x=read();y=read();val=read(); add(x,y,val); add(y,x,val); &#125; s=read(); Dijkstra(s); ll sum=0,tot=0; for(re int i=1;i&lt;=n;i++)&#123; if(i==s)continue; int pos=pre[i]; sum+=w[pos]; ans[++tot]=pos; &#125; printf(&quot;%lld\\n&quot;,sum); for(re int i=1;i&lt;=tot;i++)&#123; printf(&quot;%lld &quot;,(ans[i]+1)/2); &#125; return 0; &#125;","path":"2021/06/07/CF545E Paths and Trees（最短路径树）/","date":"06-07","excerpt":"","tags":[]},{"title":"悦读","text":"还没想好写什么","path":"2021/06/05/悦读/","date":"06-05","excerpt":"","tags":[{"name":"悦读","slug":"悦读","permalink":"https://lawrencesivan.github.io/tags/%E6%82%A6%E8%AF%BB/"}]},{"title":"P4111 [HEOI2015]小 Z 的房间（矩阵-树定理）","text":"矩阵-树定理（Kirchhoff’s matrix tree _theorem_） 前言：首先这个玩意集训的时候就已经讲过了。 但是当时并没有认真听。 现在回头看这玩意…… 前置知识：$1$：拉普拉斯矩阵 极其重要 $2$：行列式 极其重要 $3$：高斯消元 极其重要 $4$：矩阵树定理 这个了解一下这个名字就行了，要不然你直接看会了还看我的博客干屁 不重要 $5$：柯西–比内公式 这个其实不用掌握 $6$：一些奇怪的人名： 基尔霍夫 拉普拉斯 矩阵-树定理内容：官方定义：矩阵-树定理是一个计数定理.若连通图 $G$ 的邻接矩阵为 $A$ ，将 $A$ 的对角线 $(i,i)$ 元素依次换为节点 $i$ 的度 $d(i)$，其余元素 $(i,j) (j!=i)$ 取 $A(i,j)$ 的相反数，所得矩阵记为 $M$ ，则 $M$ 的每个代数余子式相等，且等于 $G$ 的生成树的数目.这就是矩阵一树定理.我们常常称矩阵 $M$ 为基尔霍夫矩阵。 其实这玩意还有一些其他的说法： 比如比较阳间的说法一：将拉普拉斯矩阵去掉任意的一行和一列，得到的矩阵求行列式，即是原图的生成树数量。（拉普拉斯矩阵下面会说到） 还有更通俗易懂的说法二：（度数矩阵（对角线矩阵）-邻接矩阵）的行列式等于该图生成树个数（行列式下面也会说到）。 还有一些奇奇怪怪的说法三：对于一个无向图 $G$ ，它的生成树个数等于其基尔霍夫 Kirchhoff 矩阵任何一个 $N−1$ 阶主子式的行列式的绝对值。 其实他们说的是一回事，完全一样。 随便记一个就行了。 拉普拉斯矩阵 （Laplacian _Matrix_）其实，它还有一个别的名字：基尔霍夫矩阵（基尔霍夫就是矩阵-树定理的提出者）。 设无向图 $G$（允许重边，可以扩展到加权，但是不能有自环） 有 $n$ 个节点。拉普拉斯矩阵 $L:=(l_{i,j})_{n\\times n}$ 定义如下： 若 $i==j$ 则 $l_{i,j}=\\deg(v_i)$ , $\\deg(v_i)$ 为定点 $v_i$ 的度。（如果是有向图，那么我们只考虑出度或者入度中的一个）. 若 $i\\neq j $ ，但是顶点 $v_i$ 和 $v_j$ 之间有边相连，那么 $l_{i,j}=-1$. 其他情况 $l_{i,j}=0$. 根据说法一，我们去掉拉普拉斯矩阵的最后一列和最后一行，然后求行列式就得到了问题的解。 说白了，我们首先求出度数矩阵 $D$（也就是对角线矩阵，具体意义是这个点有多少个另外的点与他相连，那么对应位置就是几）。 然后求出邻接矩阵 $A$（就是表明点与点的连接关系的那个，具体可以参考一些矩阵快速幂的题或者联想一下 _floyd_）。 之后求出拉普拉斯矩阵（基尔霍夫矩阵） $W=D-A$. 然后将 $W$ 去掉任意一行和一列得到 $K’$ （一般为了方便我们直接去除最后一行和最后一列）。 那么生成树的个数就等于 $\\det(K’)$ （就是 $K’$ 的行列式）。 下面还会提到有向图的拉普拉斯矩阵以及如何推广到到带权。 行列式一个矩阵对应一个行列式（就是一个数字）。 计算行列式就是需要矩阵化成上三角或下三角，然后观察对角线的元素，如果其中有个一元素为 $0$ 则整体为 $0$，否则行列式的值就是对角线上各个元素的乘积。 首先需要知道一些性质： 一个行列式和它的转置行列式相等. 互换行列式的两行或者两列，行列式的值变号. 如果行列式中有两行或者两列完全相同，那么行列式为零. 行列式中某一行或者一列中所有元素同乘同一个数 $k$ ，等于用 $k$ 乘以行列式. 行列式中如果有两行或者或者两列元素对应成比例，那么行列式为零. 把行列式的某一行或者某一列的各个元素乘以同一个数以后加到另外一行或者一列的对应元素上去，行列式的值不变. 以上加黑部分提示我们应该使用高斯消元来转化成三角，然后求得行列式。 需要注意的是一定是三角而不是对角线矩阵。 于是特别喜欢 高斯-约旦 消元的同学还是要学一学经典高斯的。 在把矩阵化成三角时需要注意，在题目中模数可能为任意，这样在剩余系就不一定存在逆元，所以需要使用辗转相除法。 或者如果这道题的模数是质数的话也可以使用乘法逆元。 消元结束以后直接算出行列式的值就好了。 int ans=1; for(re int i=1;i&lt;=tmp;i++)&#123; for(re int j=i+1;j&lt;=tmp;j++)&#123; while(a[j][i])&#123; int t=a[i][i]/a[j][i]; for(re int k=i;k&lt;=tmp;k++)a[i][k]=(a[i][k]-a[j][k]*t%mod+mod)%mod; swap(a[i],a[j]); ans*=-1; &#125; &#125; ans=(ans*a[i][i]%mod+mod)%mod; &#125; return (ans%mod+mod)%mod; 这里同时给出对于模数是质数时，求解行列式的方法： inline int det()&#123; int ans=1; for(re int i=1;i&lt;=tmp;i++)&#123; for(re int j=i;j&lt;=tmp;j++)&#123; if(a[j][i])&#123; swap(a[i],a[j]); if(i!=j)ans=mod-ans; break; &#125; &#125; int t=qpow(a[i][i],mod-2); for(re int j=i+1;j&lt;=tmp;j++)&#123; if(a[j][i])&#123; for(re int k=tmp;k&gt;=i;k--)&#123; a[j][k]=(a[j][k]-a[i][k]*t%mod*a[j][i]%mod+mod)%mod; &#125; &#125; &#125; &#125; for(re int i=1;i&lt;=tmp;i++)ans=ans*a[i][i]%mod; return ans; &#125; 需要处理一下负数情况，否则会出问题： inline void check()&#123; for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=n;j++)&#123; if(a[i][j]&lt;0) a[i][j]+=mod; &#125; &#125; &#125; 对于本题，并不是所有的点都可以用来求行列式，只有不是墙的点才能放进矩阵。 否则根据上面的性质：如果其中有个一元素为 $0$ 则整体为 $0$ 。 就会直接 WA 了。 对于加边，只加向下或者向右的边，可以保证不重复。 for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]==&#39;.&#39;)id[i][j]=++cnt;//用cnt来重新编号 &#125; &#125; 本题相关：$1$：这个题需要注意，一定要开 long long. 我们可以观察一下这个题的样例一： 构建出来拉普拉斯矩阵之后并且去掉最后一行和最后一列，矩阵是这样的： $\\begin{bmatrix} -1&amp;0&amp;2\\\\0&amp;1&amp;1\\\\0&amp;0&amp;999999996\\end{bmatrix}$​ 然后 ，不开 long long 就没有然后了。 $2$：构建完拉普拉斯矩阵以后千万不要忘记减掉最后一行和最后一列（不要上头。 $3$：上三角，上三角，上三角！（针对某些高斯-约旦党。 $4$：取 $mod$ 的时候注意处理负数。 复杂度分析：由于我们使用了辗转相除法来进行高斯消元，所以原来 $O(n^3)$ 的高斯消元被加了一个 $log$ ，时间复杂度 $O(n^3m^3log(nm))$ CODE：//#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int N=150; const int mod=1e9; #define INF 0x3f3f3f3f #define int long long//记得long long struct matrix &#123;//这里是矩阵的板子 int n,m; int tmp; int a[N][N]; matrix()&#123;&#125; matrix(const int &amp;_n,const int &amp;_m):n(_n+1),m(_m+1)&#123; memset(a,0,sizeof(a)); &#125; inline void clear()&#123; memset(a,0,sizeof(a)); for(int i=0;i&lt;=n;i++)&#123; a[i][i]=1; &#125; &#125; inline void id()&#123; for(int i=0;i&lt;=n;i++)&#123; a[i][i]=1; &#125; &#125; inline matrix operator + (const matrix &amp;b)const&#123; matrix res(n,b.m); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; res.a[i][j]=(a[i][j]+b.a[i][j])%mod; &#125; &#125; return res; &#125; inline matrix operator - (const matrix &amp;b)const&#123; matrix res(n,b.m); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; res.a[i][j]=(a[i][j]-b.a[i][j])%mod; &#125; &#125; return res; &#125; inline matrix operator * (int c)const&#123; matrix res(n,m); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; res.a[i][j]=(c*a[i][j])%mod; &#125; &#125; return res; &#125; inline matrix operator * (const matrix &amp;b)const&#123; matrix res(n,b.m); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=b.m;j++)&#123; for(int k=0;k&lt;=m;k++)&#123; res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j])%mod; &#125; &#125; &#125; return res; &#125; inline matrix operator ^ (int p)const&#123; matrix res(n,m),x = *this; res.clear(); for(;p;p&gt;&gt;=1,x=x*x)&#123; if(p&amp;1)res=res*x; &#125; return res; &#125; inline matrix trans()&#123; matrix res(m,n); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; res.a[i][j]=a[j][i]; &#125; &#125; return res; &#125; inline int det()&#123;//高斯消元与求行列式 int ans=1; for(re int i=1;i&lt;=tmp;i++)&#123; for(re int j=i+1;j&lt;=tmp;j++)&#123; while(a[j][i])&#123;//辗转相除 int t=a[i][i]/a[j][i]; for(re int k=i;k&lt;=tmp;k++)&#123; a[i][k]=(a[i][k]-a[j][k]*t%mod+mod)%mod; &#125; swap(a[i],a[j]); ans*=-1;//交换以后需要变号 &#125; &#125; ans=(ans*a[i][i]%mod+mod)%mod;//勤处理负数 &#125; return (ans%mod+mod)%mod; &#125; &#125;W,D,A; //W 基尔霍夫矩阵（拉普拉斯矩阵） //D 度数矩阵（对角线矩阵） //A 邻接矩阵 int n,m; char a[15][15]; int id[15][15],cnt;//id 用于重新编号 inline void add(int u,int v)&#123; A.a[u][v]=1; A.a[v][u]=1; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; signed main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]==&#39;.&#39;)id[i][j]=++cnt; &#125; &#125; W=matrix(cnt,cnt);//初始化矩阵 D=matrix(cnt,cnt); A=matrix(cnt,cnt); for(re int i=1;i&lt;=n;i++)&#123;//构造邻接矩阵 for(re int j=1;j&lt;=m;j++)&#123; if(id[i][j]&amp;&amp;id[i][j-1])add(id[i][j],id[i][j-1]); if(id[i][j]&amp;&amp;id[i-1][j])add(id[i][j],id[i-1][j]); &#125; &#125; for(re int i=1;i&lt;=cnt;i++)&#123;//构造度数矩阵 for(re int j=1;j&lt;=cnt;j++)&#123; if(A.a[i][j]) D.a[i][i]++; &#125; &#125; W=D-A;//两者作差得到基尔霍夫矩阵（拉普拉斯矩阵） W.tmp=--cnt;//除掉最后一行与最后一列 /*for(re int i=1;i&lt;=cnt;i++)&#123; for(re int j=1;j&lt;=cnt;j++)&#123; cout&lt;&lt;W.a[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;*/ printf(&quot;%lld\\n&quot;,W.det());//求行列式 return 0; &#125; 关于拉普拉斯矩阵的有向图情况：像我们上面所说的，只考虑入度或者出度就可以了。 但是考虑这两种是不一样的。 设有向图 $G$（允许重边，可以扩展到加权，但是不能有自环） 有 $n$ 个节点。出度矩阵 $D=(l_{i,j})_{n\\times n}$ 定义如下： 若 $i==j$ 则 $l_{i,j}=\\deg^{out}(v_i)$ , $\\deg^{out}(v_i)$ 为定点 $v_i$ 的出度。 若 $i\\neq j $ ，则 $l_{i,j}=0$ 类似地可以定义入度矩阵。 定义 $edge(i,j)$ 为点 $i$ 指向点 $j$ 的有向边数。 定义邻接矩阵 $A=(l_{i,j})_{n\\times n}$ 若 $i\\neq j$ , $l_{i,j}=edge(i,j)$ 于是 就可以定义 $Laplace$ 矩阵 $L^{out}$ 和 $L^{in}$ 。 当为 $L^{in}$ 时，统计的是外向树。（所有边指向叶节点） 当为 $L^{out}$ 时，统计的是内向树。（所有边指向根节点） 内向是出度，外向是入度（一定要记牢，不要混淆） 如果指定了根节点为$root$ 那么要在计算行列式的时候要去掉的就不是任意一行和一列了，而是第 $root$ 行和第 $root$ 列。 inline void add(int t,int u,int v,int w)&#123; if(t==0)&#123;//内向树，出度矩阵 (D.a[u][u]+=w)%=mod; (A.a[u][v]+=w)%=mod; &#125; else&#123;//外向树，入度矩阵 (D.a[v][v]+=w)%=mod; (A.a[u][v]+=w)%=mod; &#125; &#125; 因此如果要统计一张图所有的内向树形图，只要枚举所有的根 $root$ 并对所有的行列式求和即可。 如果要统计一张图所有的外向树形图，只要枚举所有的根 $root$ 并对所有的行列式求和即可。 关于拉普拉斯矩阵扩展到带权 求生成树边权积之和 将上述中的 $D$ , $A$ 改为记录相应边边权和，则行列式从生成树个数变为对应的生成树所有边权之积的和。 于是可以发现，只要把边权全都看成 $1$ ，就是上面这道题我们解决的情况：求生成树个数。","path":"2021/06/04/P4111 [HEOI2015]小 Z 的房间（矩阵-树定理）/","date":"06-04","excerpt":"","tags":[]},{"title":"2021年6月月记","text":"$2021$ 年 $6$ 月月记前言这个文章其实鸽了很久了，早就想发来着。 心里想着怎样怎么样也应该给自己的生活留下一些印记。 正好博客刚搞好了生活专区。 多么好的时机啊！ $6$ 月 $1$ 日今天第一次写月记呢~ 今天是我当值日班长。这是因为前几次我都旷工了，导致一笔恶账终于降临到我的头上 不跑操的感觉真爽！ $by$ 老师祝大家儿童节快乐了 /cy 啊对了，今天测试了刚买的电脑散热器。 实在是太sb了 包装一开 $XYY$ 和 $wiki$ 立刻就开始阴阳怪气：“哇！炫酷灯光，超大风扇！” (当时我还没有意识到事情的严重性 等到我插上了电，我艹！ 直接阴间灯光就整起来了。 给大家看看情况： 我心里想着：“问题不大，这灯光肯定能关。” 然后我一边笑着一边摁下了灯光调节键。 然后我笑不出来了。 这他妈比刚才还诡异啊！ 艹一个散热器nm给我整7种灯光？ 然后在大家的哄笑当中我无奈的 $typing$. $CG$: “ $LawrenceSivan$ !你的散热器怎么又添新灯光了！“ 艹 不过确实散热效果比较好，如图 qwqwqwqwq 吃午饭的时候十分惊险 我骄傲地拿出饭卡一刷：”19.42￥” ??? 靠，这么点钱怎么养活我和 $wiki$ ? (钱耗得这么快完全是因为 $wiki$ 蹭了我一周的饭，导致我 $500$￥ 一周没了) 幸亏大叔少收了几毛钱，让我们吃上了饭。 好以后多来这家吃 下午一直在调回滚莫队的一道魔改题，然而并不知道出了什么问题。（来自未来：问题出在数组没有初始化。wssb） 只能晚上睡觉的时候想了。 去机房的路上发现了诡异的事情 一群高一的孩子在高二的女生宿舍门口跳集体舞 存真楼下那么大地方你们就不喜欢？视野又开阔 今天还得知了三胎政策的放开。 然后晚上的时候我就祝了大家早生贵子 其实是对着 $msb$ 说的（此老师刚刚结婚 不知道他有没有听出来 大熊猫由濒危变成易危啦！ 比较快乐的一天 $6$ 月 $2$ 日艹昨天刚说完不跑操好爽今天就跑操了 开过光的嘴实锤了 今天上午一直在调那道莫队题 逐步确定问题 发现是同块的暴力统计出了问题。 然后去看题解发现和人家的不一样。 然后我傻乎乎的问 $RenaMoe$ 为什么这两种写法不等价。 然后 $RenaMoe$ 直接指点了一个链表搞法，把我的桶给否了 然后一个偶然的机会，我发现把函数拎进主函数就没事了。 于是！！ 突发奇想，是不是没有初始化。 艹 两天时间白费 就因为一个不初始化的数组。 脑瘫实锤 上午比较无聊，没啥可说的。 下午真的是太艹了！！ 好端端的非要练什么集体舞。 白白丢掉一节大自习。 主要 $llf$ 还把 $U$ 盘给弄丢了 于是着急忙慌给大家下音乐。 等到下去了以后 $llf$ 问我为什么带着电脑和硬盘下去 What the Fuck！！ 难道不是您把 $U$ 盘弄丢了？？ 好吧姑且当我白白带下来电脑。 可谁料到 过程中音响居然没电了！！ 艹 只得请出我的神机！ 然后发现声音太小了。 $hhhhh$ 赶紧去借小蜜蜂 借来了，声音还是小。 又借一个。 然后我直接一手端电脑，一手拿小蜜蜂 来世不当工具人！！（怒吼 然后电脑直接变成生草机（大家可以想象，操场上掉草严重，然后满电脑都是草，每一次踢腿动作都是对我电脑的考验 草 然后经过一番工具人的不当人的折磨，我的裤子报废了。 好！ “看奇妙落在这一瞬间” 也许我真的需要一个“ $medical\\ surprise$” 晚自习效率还行 睡了好觉 完。 $6$ 月 $3$ 日今天比较平淡 唯一可说的就是学校的反复横跳： 要占宿舍，又不占了，又要占了…… 要搬到 $F$ 座了。 今天 $wiki$ 终于有了自己的饭卡，可是还是要嫖我的饭…. 淦 今天作业巨少，下午大自习不到半个小时就颓完了。 然后看了一个小时红楼梦 晚上怎么能不颓呢？ 晚一就去！ 然后一晚上过得也很充实。 大概对矩阵-树定理也有了点认识。 明天还要继续搞。 $6$ 月 $4$ 日大家好，我走路又撞墙了。 吃完早饭坐在这里，我意识到自己又忘记买笔芯了。 他们一直在讨论出去集训的事情，只有人下人的 $OIer$ 们孤苦伶仃 “快乐是他们的，我们什么都没有” 上午感觉活得很颓唐，没干什么正事。 果然一到临近放假的时候大家就都很兴奋。 下午终于补完了矩阵树定理的博客 可是然而 居然要社区维护？？ 啊这居然还交不了！ 淦 气得要死。 不过借这个机会学会了点实打实的东西，确实并不亏。 接下来会非常痛苦的， 毕竟是一次长达 $5$ 天的集训生活 似乎可爱的杰哥安排了很多考试呢 我似乎看见了光明的未来 晚上的时候 $CG$ 突然跑过来 然后娇羞地对我说： “我要上厕所” ？？？ 你上厕所跟我说干屁 这么大个男生还让我跟着一起去？ 据说 $CG$ 从小女装长大 自然上面那句是我杜撰的 “除四书外杜撰的太多” 果然晚上是颓废的大好时光！ 晚上也很快乐 就是晚三回班感到很不爽 $good\\ day$ （来自未来：这个 $sb$ 晚上洗澡的时候把撞墙的伤用毛巾直接擦掉掉掉了（带着肉的那种）） $bad\\ day!$ $6$ 月 $5$ 日今日果真算得上是个好日子。 一上午课都不上了，直接来颓废。 社区终于能用了，赶紧交题解。 $waiting$ 上午 $10$ 点的时候得知了许瑞航神仙破了三阶平均世界纪录，我直接大呼牛逼。 今年这位神仙就一路开挂，先后破了亚洲纪录，拿了世界第四，亚洲记录被抢以后又抢回了亚洲纪录，成了世界第二，现在这孩子又破了世界纪录。 他才刚刚13岁啊！后生可畏！ 仅凭一己之力，将中国三阶平均拉到世界级水平！ 自愧不如。 中午有个小插曲 $llf$ 把我的手机没收了 原因是我把它借给同学听歌。 于是期待了很久的 $leancloud$ 只能再拖一拖。 日 然后下午在机房颓了一下午 卷了几道矩阵树定理的题。 加深了对行列式的认识。 还是很值得的。 原以为要被杰哥骂了，没想到杰哥心情还挺好。 晚饭挺难吃的。 人还巨多。 烦 晚上是板子大赛。 一晚上 $15$ 道题。 然后写的有点头晕了。 不过一直敲键盘不思考的感觉好爽！！ 明早还有线性代数的考试。 明天不会这么好过了呜呜呜 今天并不是一个好日子。 期待明天吧 （后记：晚上要睡觉的时候，一直在等着熄灯，然后在床上抱着电脑等。 然后直到快 $11$ 点,居然还没有熄灯。 于是我们抱着电脑在床上颓废了起来。 突然宿管阿姨的声音传来 吓得我们赶紧关掉了电脑。 可是 $123hh2$ 出去看了一眼， 发现阿姨只是在查宿，并不是熄灯 然后吕大文豪直接当场发表重要讲话， 而且十分接地气： *木皆兵 由于刚才很害怕所以关了灯，所以这一段是盲打的。 看来盲打水平还不错 /cy 可以睡觉了。 晚安。 $6$ 月 $6$ 日今天是建强弟弟的生日！ 祝他生日快乐！ 早上起床看了一眼洛谷， 发现题解过了。 好事情啊！！ 不过貌似我的题解没有新手保护，于是直接被压到下面去了。 在 i207M 巨佬的正下方，我感到害怕极了 上午直接开始了线性代数大战 $7$ 点 $50$ ，开题了 看了一眼 $T1$ ，瞟了一眼数据范围。 位运算。 可是我没看内存限制。 突然 $XYY1411$ 大喊靠这个题就给 $1M$ ，我猛回头发现确实是。 但是对我的做法似乎没什么影响，只要稍微小心一点就行了。 然后去看 $T2$ ,题还没读完：这不是高斯消元裸题？？？ 然后就开始敲键盘了。 然后看了一眼 $T3$: 异或高斯消元？ 仔细一看确实是。 为啥杰哥要出两道高斯消元啊 然后我满怀期待的开了 $T4$ ,希望能出矩阵树定理。 然后一看是矩乘。 而且是原题 杰哥这次模拟赛究竟放了多少水啊 午饭去早了，等。 饭依旧不太好吃。 然后碰到了 $R$ 他一边看着我们，一边捂着脸向身旁的老师说“这是信竞的” 感觉有被冒犯到 下午出分了。 果不其然，又挂分了。 草啊我就不能有一次不挂分的时候？ $T1$ 位运算少处理了一位：$100-&gt;70$ $T4$ 直接括号套错了。 $100-&gt;30$ 最后 $70+100+100+30$ 抱憾而归。 不过因为错误都很傻逼的原因，下午改题时间没干什么事情。（也没什么可以改的了） 逛逛博客，看看题解啥的。 晚饭依旧很难吃。 但是今天食堂直接布置起了大红横幅。 有种过年的感觉 晚上研究了最短路径树。 确实有很多收获。 还引发了很多思考。 疑似发现了一些题解的错误？ 明天继续研究，或者再发个题解啥的。 今晚 $wiki$ 睡得很早，于是我顺理成章地继承了网卡。 于是我现在还可以在这里 $bb$ 。 目前为止，集训生活貌似比我想象的要快乐一些。 或者只是貌似 截至目前 $whk$ 作业还是一点没动。 或许直接等死效果更好 爬了 $6$ 月 $7$ 日高考了高考了 祝学长学姐们成功 但是早饭实在是太草了 我们七点起床。 然后去了食堂 却被告知人家高三六点半就吃完饭了。。。 然后直接饿死在机房。 到了机房发现洛谷上昨晚 $CF$ 的题了。 赶紧水上去。 然后正准备提交翻译骗一些贡献分 然后 $XYY1411$ 一脸猥琐地告诉我他已经提交完了。 $hhhhhhc$ 没办法了，只能接着搞昨天晚上的最短路径树。 不一会 $123hh2$ 说他交题解了正在审核。 然后不出 $10min$ 他就通过了。 然后 $XYY1411$ 的翻译也通过了、 草为什么今天洛谷的管理这么勤奋啊 然后开始和 $wiki$ 细细地研究最短路径树。 然后发现很多题解都是错的。 现在的孩子们写题解都这么不认真的吗 然后我就码了一个题解用以指出他们的错误并且重新讲解。 大概 $11:20$ 左右，我点了提交。 提交以后不到半分钟 有一声惊天巨雷。 然后 停电了！！ 全校停电，高考考场也停电了！！ （$wiki$ :”靠这一波作弊的大好时机啊，摄像头和信号屏蔽器全都 $GG$ 了“ 然后大家噪起来了。 其实此时已经考完了大概。 $11:33$ ，来电了。 看一眼题解提交:通过了。 全机房交的题解全都通过了。 这是个好日子！！ 下午大家题解交疯了啊。 不过管理确实没有上午那么勤奋了。 下午继续写最短路径树。 晚上发现自己的题解被驳回了。 可恶 改改改 然后一下午管理就没再审核过。 下午之后干了什么事情就不太记得了。 下午 $CG$ 回来了。 可是他变成了精神小伙。 可悲。 晚上听 $i207M$ 讲课。 听了一会突然想起来自己博客的搜索功能还没有做好。 于是赶紧跑过去开始做搜索。 刚好 $i207M$ 讲的是搜索，我现在在搞搜索 然后直接用了 $Hexo$ 的插件， $local$ 运行的可好了，效果非常不错。 然后非常开心啊，直接就开始提交了。 提交的过程中我和 $wiki$ 说：“你说本地运行的这么好 $d\\ -g$ 以后会不会直接炸掉” 然后它就炸了。 草 之后开始慌慌忙忙的恢复数据，找存档备份。 然后就什么都没干，只恢复了半天数据。 然后这一波直接把我仓库搞得昏天黑地。 差点就重建仓库了 幸亏比较理智。 再也不敢乱搞了 可是还有好多功能没有写啊 $RSS$，手机客户端还有留言板都没弄好(这个要怪 $llf$ 只能找个机会搞了， 哎，生活困苦啊 给大家见识一下什么叫做真正的开光嘴： 那会宿舍突然停电了。 然后大家在黑夜中呆着。 大家都在为连不上网而无法颓废而感到惶恐时， 炮哥说了一句：”靠，这大晚上的谁给咱们修电去啊”。 然后电就来了。 就来了 来了 了。 之后是经久不息的掌声。 $6$ 月 $8$ 日今天确实过的很颓唐。 一上午就写了一篇题解，质量并不算高。 虽然通过了，但其实自己并不算满意。 今天 $wiki$ 的 $CF1005F$ 终于调出来了。 终于见识到 $CF$ $hack$ 数据的毁天灭地了。 真的是把我们卡的连我妈都不认得。 看来确实应该多打一打 $CF$ . 突然发现有很多博客文章没有来得及搬运。 搬运他们也是个大工程啊 谔谔。 今天搜索功能依旧没有做好。 $RSS$ 和客户端已经打算放弃了。 给主题原作者发了 $issue$ 但是杳无音讯。 感觉自己上了大当。 晚上 $21:27$ 分，洛谷炸了两秒。 估计是阿里云又 $100$% 了。 $hhhhhhc$ 对了今天发现了神帖 《日了》 然后就开始和 $CG$ 快乐地 $bb$ ： 行了不多 $bb$ 了，明天还有一场考试。 希望别再挂分了（祈祷 $6$ 月 $9$ 日早上 $XYY1411$ 又过来拆门了。 门的质量确实很好。 然后我在床上睡得很香。 $7:30$ 的时候宿管阿姨过来问我们：“你们怎么还不走啊？” 于是我从睡梦中醒了过来。 看了一眼表。 然后又看了一眼。 草！这么晚了！！！ 赶紧穿衣服。 然后迟到了 $15min$ . 上午有一场模拟赛。 打得并不爽。 出题人居然把 $n^4q$ 的算法放过去了。 虽然我的 $n^3q$ 也应该被卡 可是还是很不爽！ 今天很颓废，没干任何正事。 下午看到了高三考完试了。 然后发现高三楼门口有很多顺丰快递车。 好奇、 走过去看一眼，有一个横幅 上书：“诗和远方你去闯，行李顺丰负责抗” 下雨了。 冷。 $6$ 月 $10$ 日今天要开学了。 上午搬教室。 累。 然后在宿舍洗了洗一堆衣服 下午去了班里。 惊奇的发现大家都没有来。 于是大家一起摆考场。 晚上直接去了机房。 $6$ 月 $11$ 日一整天的训练。 水了几道题目。 其实我觉得NOIP2016天天爱跑步没有那么难吧 下午大扫除。 和 zyb 干起来了。 全机房都已经厌恶他了，但是他还浑然不觉。 具体内容下次再补。 扫除完了以后杰哥显得尤为高兴。 ：“最整洁的机房！” 还拍了照片。 对于zyb 把共享文件夹都删掉，然后恢复极为困难这件事，杰哥显得更为高兴。 也许内心戏是：”哈哈哈哈，干了这么多年，考验我技术实力的时候终于到了！“ 于是满脸笑容。 然后问 $wiki$ 密码是不是他改的，文件是不是他删的。 晚上 $wiki$ 成功用 $win hex$ 把文件修复以后。 杰哥更为高兴，直接大喊 :”$good!$” 阳光大男孩。 晚上听了四谎的 $op$ 。 $6$ 月 $12$ 日今天效率应该说非常高。 切了很多拖了很久的题目。 基本上树上差分练熟练了。 我真的好喜欢树剖啊 然后近乎打了一整天的树剖板子。 感觉很爽。 博客题解方面也很高效。 总结帖也写了不少。 树上问题基本上不慌了。 然后突然发现搜索没咋动 果不其然。 突然有点虚文化课。。。 毕竟已经这么多天没有碰过了。 但是只要我够卷！！！ 显然还不够 接下来就是努努力准备回一回搜索，毕竟这玩意可不能成为弱项。 下午收拾了东西，考了英语。 英语考的并不太好 有朝一日听力成为了我的弱项》 这辈子想不到 不过今天也确实发生了一些让我感到很寒心的事情。 算了，这些事情本就不该发生在我身边。 让它过去吧。 $6$ 月 $13$ 日是个周日。 上午依旧是照例的模拟赛。 比较惊人的是这次居然出了 $4$ 道原题。 然后就是一阵敲键盘。 $T4$ 虽然是原题，但是太毒瘤了，根本写不下去。 骗了 $20$ 的部分分就走掉了。 在考场上亲眼目击了某人去洛谷上粘代码，希望这个人好自为之 如果真的不想学了就赶紧退役，不要总是浑水摸鱼 果然搜索真的是一大块心病啊。 看来还真的是代码能力不行？还是逻辑不够清晰？ 找个时间补补。 不过我以前写的点分治貌似假掉了？过不了杰哥的数据。 靠看来树上问题也不行啊，我真是个废物。 然后发现自己还有一堆一堆的衣服没有洗。 啊啊啊啊 虽然洗衣服这件事情确实让我感到十分快乐 甚至是在学校期间最为快乐的事情之一。 另一件是在机房听着交换机的轰鸣声。 下午发了这周最后一片题解。 然后晚二就过了。 于是这一周有了 $5$ 篇题解。 希望明天就红名了吧。应该够呛，毕竟据说一篇题解只涨 $4$ 分，还差的很远呢 晚上调过了最后一道题，学了 $Kruskal$ 重构树 。 挺有意思的。 高高兴兴去睡觉 $6$ 月 $14$ 日红名了！！！ 早上吃完早饭赶紧来看看洛谷。 然后惊奇的发现自己直接 $236$ 咕值了。 社区贡献直接涨了 $30$ 多分。 挺出乎意料的。 看来时不时地卷一卷还是很有帮助的 下午： 菜死了啊草我怎么连个搜索都不会写！！！ 我有没有脑子！ 烦死了。 效率低，没脑子， 菜死实锤。 啊对了，点分治没有假掉，只是因为没有开 $long\\ long$. 这更印证了菜的事实。 $6$ 月 $15$ 日今天听说有个什么集体舞大录像。 然后强制穿了夏季礼服。 在班里还挺凉快的。 $10:30$ 就出去站队了。 然后在外面站了一个多小时。 热的要死。 于是在脑子里播放四谎的 $op$. 然后就热血沸腾了。 不过还是被晒醒了。 啊对了，被 $lby$ 拔了一根腿毛。 我感觉很淦。 主席台上爆粗口。 确实是校园应有的独特景观。 大草为什么现在打校园出来的第一个是消元啊 最后累到最后的动作不跟着做直接罚站了。 不过还是要说一说四谎的事情。 找到了宝藏图片。 扔在下面了可以看看。 晚上来了五楼，然后就开始搞事情了。 一个题调了一节课。 果然诸事不顺。 不过好在今天蓝题百 $A$ 了。 唯一值得欣慰的一点。 还要更卷！！ 我要当卷王！！！ 菜死了只有菜的人才需要当卷王 今天下课早，洗洗睡了。 $6$ 月 $16$ 日今天下雨了。 确实有一点冷。 回宿舍的时候手又出现了刺痛的感觉。 $6$ 月 $17$ 日今天神州十二发射。 于是上午下了第二节课赶紧飞奔上楼准备看直播。 正好第二节课 $20$ 下课，神舟 $22$ 发射。 然后大家注视着神州十二上天。 真是太美妙了！ 就有一种非常激动的感觉。 啊啊啊 Kruskal 重构树的博客已经咕了很久了！ 今晚一定要写完。 然后晚上可爱的 $123hh2$ 让我帮他调树剖。 于是调了一晚上。 博客又咕咕咕了 不过帮一帮同学也是好的！ 至少证明了我的树剖学的很娴熟 $123hh2$ 表现出十分感谢。 就差没跪下喊爸爸了 这确实是我的杜撰 希望他不要看到 $6$ 月 $18$ 日今天非常痛快！ 和 $wiki$ 一起深刻地研究了线段树优化 $DP$ 确实发现了很多细节。 也有了很多收获。 首先加深了对 $DP$ 优化的认识。 然后又学习了新的技能。 下午也终于是搞定了重构树的博客。 效率很高的一天呢~ 晚上写作业也贼快。 然后 $123hh2$ 又在写树剖。 然后又挂了。 于是我又帮他调了一晚上。。 最后居然发现他的线段树就开了一倍空间？？ 这孩子果然基础没打好。 然后我就去干自己的事情了。 最后要回宿舍的时候，我依稀听到了一些 $top$ ，$size$ 之类的单词。 这孩子居然还在写树剖！？！？ 已经写了好几遍了。 真的是太勤奋了。 于是看在 $123hh2$ 如此可怜的份上，在回宿舍的路上还给他细致地讲解了这些玩意。 虽然我觉得这玩意也许人均切 然后错过了妈妈的电话 挺不错的 $6$ 月 $19$ 日今天搬进了高二教学楼。 草好热啊 总感觉来了这边地方变小了。 楼也感觉很挤，不如原来的宽敞。 升高二了又大了一点。 学弟学妹们要来了。 赶紧忽悠他们来学 OI 下午去了快递站然后发现没开门？ 感觉自己像个 sb 晚上和大家一起颓了 MC 确实比较快乐。 这里给大家推荐一个挑战自我的好方法。 如果你实在是闲的没点屁事干了，不妨叫上一堆小伙伴去打一把 MC，开困难，无死亡不掉落 然后感受一下痛苦。 草因为一次死亡然后过去收尸，为了这屁事又死了好几次 $6$ 月 $20$ 日依旧是上午模拟赛。 早退了去理发。 然后我就变成了精神小伙。 这里是一个被处刑的 $LawrenceSivan$. 自然结果大家应该也能想象的到。 图片就不放了。 不过似乎我本身不太注意这方面的事情。 下午去拿了鞋。 然后由于这是一个没有经验的傻孩子。 于是那个鞋把我的跟腱快 磨 断 了。 然后习惯了运动鞋的我很喜欢一下跳下台阶。 自然现在也是极其痛苦。 好了不说了，我去捂一会脚。 $6$ 月 $21$ 日是被热死的一天。 来了这边以后再也体会不到原来一个班两台空调的快乐了。 困死了数学课睡着了。 然后我十分惶恐生怕拉下什么东西。 然后看了几眼知识点发现老白又在水课。 然后又安心的睡了。 晚上很痛苦。 我为什么这么废物啊。 什么都不会。 然后睡眠质量也很草 一直想一个问题。 之后想到了 $4$ 点多. 最可怕的是第二天起来以后还忘记昨晚在想什么了。 一点都记不得。 浪费生命。 $6$ 月 $22$ 日又干了傻逼事。 给大家欣赏一个迷惑行为： inline bool operator &lt; (const node &amp;a)const&#123; return id^a.id?sum&lt;a.sum:id&lt;a.id; &#125; 因为这个傻逼错误调了很久甚至就要捶打自己了。 气愤。 果真是自己太菜了。 和大庆聊了天。 似乎他没怎么变，还是很开朗。 这也很不错。 这还是我认识的样子。 心里获得了些许安慰。 生活还要继续啊。 啊对了 自从剪了头发以后大家都说我的胡子比头发还长了。 确有此事。 看来似乎应该修整一下？ 算了不修边幅也挺好的。 $6$ 月 $23$ 日困困困啊。 好几天没睡好了。 化学课直接睡傻了。 下午研究了整数划分但是发现并不太明白。 尝试了手推但是不太理解。 然后回看了 $zrt$ 的讲课视频，终于明白一些了。 抽个时间写个总结？ 作业多死了啊！！！ 草一张 sb 数学烦死了，又难算又多。 晚上和 $CG$ 回宿舍的时候在路上讨论主席树版本问题。 “就是每次修改的时候都要开一个副本，然后把信息转移过来维护副本，然后***副本” 然后路过了主任。 主任：“都几点了还聊呢？聊游戏呢吧。” ？？？？ 我和 $CG$ 面面相觑。。 就挺有意思的 $6$ 月 $24$ 日今天面基到了猫猫！！！！！！ $HE$ 的队爷们都来了，赶紧去凑凑热闹。 见到了 $zzz,jzp,chr,xyh$ . 倒也真是十分热闹。 心情也算不错。 chr真的好友善 活得不错。 $6$ 月 $25$ 日听说昨天晚上 $win\\ 11$ 发布了。 然后赶紧来装上试试。 于是和 $wiki$ 搞了一晚上才弄好。 给大家看看效果： 说句实话其实感觉除了任务栏变了其他的貌似都么怎么变 改了改图标？ 提示音更厚重了。 据说自带安卓？ 由于是预览版所以现在还没有中文包。 为了防止自己的电脑炸掉于是安在了虚拟机上。 草虚拟机卡死了 勉强用。 不过有些特效做的还行。 $6$ 月 $26$ 日今天被告知不考期末了。 事情是这样的。 在上数学课之前，我们在隔壁认真地颓废学习，上课铃响的时候我们匆匆忙忙赶回了教室。 一进教室发现大家神情激动地大喊：“老师再见” 我们一脸迷惑，但是又不是很迷惑。 以前老白也干过这种事情。 可是大家喊完了老师再见居然都开始往外冲！ 往外冲！ 我们几个哪见过这世面啊，直接都吓傻了。 我们弱弱的问人家，为啥往外跑。 对曰：“淦tm的，学nm！” 然后人家头也不回的走了。 草我们不会遇上了新一波罢工停学吧 这时有一个和善的凯凯告诉我们： “不考期末了哦” 我们：“？？？？？” 过了一会我们反应过来了。 ：“淦tm的，学nm！” 然后我们也跑了。 于是几乎一整天都搞了竞赛。 这算是停课吧。 可是就在下午。 亲爱的 $llf$ 告诉我们：“我们可没有停课哦” 于是爬回去上语文。 于是闹出了这种笑话： 说句实话，其实我还挺期待期末考试的 $6$ 月 $27$ 日窝火。 不想多说。 $6$ 月 $28$ 日今天可怜的 $wiki$ 被 d 了。 原因是** 狠心的 $llf$ 居然要叫 $wiki$ 的家长把他领回去。 太可怜了。 上午和某人对线了。 很爽。 但是需要学习辩论艺术。 晚上很快乐。 机房上演了大戏。 先放个预告片： 不言而喻。 细节及其多。 情况就是这样的： 突然间一只马蜂钻进了窗户。 大家惶恐极了，生怕自己会被咬死（？ 这是杰哥高兴地冲了出来 ：“我来！” 脸上洋溢着前所未有的快乐笑容。 （似乎以前有过，那就是在机房共享空间被删掉的时候。 之后杰哥表演了各种抓虫绝技。 包括但不限于 “高射炮精准打击（用纸团扔）”，“激光剑（其实是扫把）水平扫描”，“平地起高楼（其实是踩椅子爬桌子）”，“无敌DJ（就是来回开关灯）”，“心灵引领（言语辱骂）”，“心灵感应（其实就是站着发呆）”。 之后直接开启羽毛球运动员模式。 突然之间，啪的一下很快啊，杰哥抽出拍子就是一拍（自然还是扫把），然后击中了！ 马蜂直接掉在了地上。 快乐的 $123hh2$ 赶紧跑过去读秒：“1，2，3” 坚强的马蜂又飞起来了！ 杰哥立刻一个左刺拳，一个右边腿，马蜂全都防下来了啊。 突然杰哥偷袭，找准机会又来了一拍子。 球划出了精准的弧线。 球进了！ 杰哥赢了！ 时隔三年，杰哥又一次战胜了雄蜂队！（不知道马蜂是不是雄性，这里姑且当他是吧） 之后杰哥又变成了滚铁圈国家队队员。 然后快乐地把小马蜂滚出去了。 于是就有了这一篇文章： 记一只小傻蜂 - 燃烧的冰块_husky 的博客 - 洛谷博客 (luogu.org) 事实证明，二南什么都有可能发生： 给大家看一个先前的案例（就发生在不久之前）： 记一只小傻鸟 - RenaMoe’s blog - 洛谷博客 (luogu.com.cn) 啊对了，打马蜂的时候还拆了灯管： 过了一会 $webnie$ 走了进来，迷惑地问我们：“这个灯管发生甚麽事了” 我说：“没什么，就是死了个马蜂’’ 不过看起来 $webnie$ 惶恐极了，然后他离开了。 updated：听说那个马蜂没死透，后来还飞回来了。 $6$ 月 $29$ 日似乎没什么大事发生？ 相较于昨天确实平淡多了。 今天 $wiki$ 成为了机房第一个在物理机上装 Win11 的人！ 热烈祝贺！ $6$ 月 $30$ 日$6$ 月的最后一天啦！ 时间过得真的好快啊。 不过这一个月过的确实很充实。 白天一切正常。 下午又一场小小的模拟赛。 一道二分图裸题，另一道是树剖。 但是树剖的那个不会。 $RenaMoe$ 直接指点了一个点分树做法。 不会啊不会啊。 嘤嘤嘤还是弱啊。 晚上和 $BF$ 聊啦 对明天充满了期待。 但是关于什么管道堵塞然后热晕什么的还是挺害怕的。 完结。 月底总结写月记的第一个月过去了。 回看这一个月生活确实很美妙。 以前不写月记的时候也许完全记不住自己的生活经历了什么。 确实是很美好的回忆。 也明白了一些事情。 就算生活有再大的问题，总要学会自我反思，自我思考。 总会好起来的。 $\\color{Purple}{愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。\\\\ 能做事的做事，能发声的发声。\\\\ 有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。\\\\ 此后如竟没有炬火：我便是唯一的光。}$ $\\color{Purple}——鲁迅 《热风·随感录四十一》$","path":"2021/06/01/2021年6月月记/","date":"06-01","excerpt":"","tags":[]},{"title":"替罪羊树学习笔记","text":"替罪羊树模板题地址 前言：首先平衡树写法真的是太多了 据不完全统计 比较知名的有 红黑树 （$RB_Tree$）,替罪羊树，$Treap$，$fhq_Treap$ , $Splay$ , $AVL$ , $SBT$ , $0/1\\ Trie$ 等等 自然我是没有时间把这些玩意都学一遍的 而且有些不当人的玩意确实不是人学的 今天要说说替罪羊，也是近期学会的。 简介替罪羊树是计算机科学中，一种基于部分重建的自平衡二叉搜索树。在替罪羊树上，插入或删除节点的平摊最坏时间复杂度是 $O(log n)$ ，搜索节点的最坏时间复杂度是 $O(log n)$。——百度百科 首先我们都知道，$Treap$ , $Splay$ ，等平衡树都是需要旋转操作来维持树的平衡结构。 带旋转的平衡树一般存在以下问题： 可持久化几乎就是不可能（$Treap$ 可以用 $fhq_Treap$ 来搞，而且貌似还很主流）（虽然替罪羊树可持久化也极其困难，貌似就算实现了复杂度也是假的） 对于一个平衡树的每个节点上维护一个集合，存储子树内所有的数。此时一次旋转操作的代价可能会达到 $O(n)$ ，传统的旋转平衡树就无法发挥作用 于是，我们就需要一些不带旋转操作的平衡树。 作为重量平衡树的一种的替罪羊树就满足这样的条件。 原理替罪羊是一种基于暴力重构来维持树的平衡的数据结构。 我们定义一个平衡树因子 $\\alpha$ ，对替罪羊树的每个节点 $t$ ，我们都需要满足：$\\max(l-&gt;size,r-&gt;size )&lt;=\\alpha\\times t-&gt;size$其中 $l$ , $r$ 分别是 $t$ 的左右子树。这个性质称为平衡性质。 一旦出现了违背这个满足性质，就把这棵子树暴力拍扁重构。 （图片来自百度） 实现方法重构拍扁具体是什么意思呢？ 我们只需要对需要进行重构的子树执行一次中序遍历，然后把它存到一个数组里（为了方便下面我们使用了$std::vector$） 然后我们再每次取中点，向左右两边递归建树就好了。 代码实现很简单： void dfs(node* o,vector&lt;node*&gt; &amp;v)&#123; if(o==null)return; dfs(o-&gt;l,v); if(!o-&gt;del)v.push_back(o); dfs(o-&gt;r,v); if(o-&gt;del)delete o; &#125; node* build(vector&lt;node*&gt; &amp;v,int l,int r)&#123; if(l&gt;=r)return null; int mid=(l+r)&gt;&gt;1; node *o=v[mid]; o-&gt;l=build(v,l,mid); o-&gt;r=build(v,mid+1,r); o-&gt;update(); return o; &#125; void rebuild(node* &amp;o)&#123; vector&lt;node*&gt; v; dfs(o,v); o=build(v,0,v.size()); &#125; 关于复杂度这样重构一次的时间复杂度为 $O(n)$（n为子树大小），但是实际上替罪羊树的单次插入时间复杂度并不会达到 $O(nlogn)$，因为一个 $size=t$ 的子树需要插入 $Ω(t)$ 个点才会被重构，所以可以通过势能分析来证明替罪羊树的单次操作的均摊时间复杂度为 $O(logn)$，具体证明这里不详细展开。 关于势能分析可以参考这篇文章. 关于 $\\alpha$ 的取值一般来说，$\\alpha$ 的取值一般在 $0.5 - 1$ 之间。 根据定义我们可以发现，当 $\\alpha$ 太小可能会导致重构次数太多，当 $\\alpha$ 太大可能会导致重构次数太少，导致树高度不平衡，在查找操作的时候会导致浪费大量的时间。 一般取 $7$ 或者 $7.5$ 就足够了。 关于写法没错，我个 $SB$ 又写了指针。 刚开始学的时候是跟着洛谷板子题第一页写的，但是那个题解有一些缺点，这个问题我们在下面会进行说明。 其实指针也蛮好写的。 结构体的定义如下： struct node&#123; node *l,*r; int val,size,cnt;//val 值 size存在的节点数 cnt 全部的节点数 bool del; bool isbad()&#123; return l-&gt;cnt&gt;alpha*cnt||r-&gt;cnt&gt;alpha*cnt; &#125; void update()&#123; size=!del+l-&gt;size+r-&gt;size; cnt=l-&gt;cnt+r-&gt;cnt+1; &#125; &#125;; 在上面的片段中，出现了存在的节点数和全部的节点数这样的变量，这也是一个需要强调的点，至于为什么这么写，这需要涉及到替罪羊树的一种基本操作。 至于使用了 $new$ 来动态申请内存很慢这件事，我们可以使用手写内存池的方式，这样既快而且还可以节约空间 node mempol[maxn]; //内存池 node *tail; //tail为指向内存池元素的指针 node *bc[maxn]; //内存回收池（栈） int bc_top; //内存回收池（栈）顶指针 node* newnode(int val) &#123; //返回一个新节点 node* p=bc_top?bc[--bc_top]:tail++; //分配内存 p-&gt;l=p-&gt;r=null; p-&gt;cnt=p-&gt;size=1; p-&gt;val=val; p-&gt;del=0; return p; &#125; 不过最终我还是没有使用，如果有需要的话可以自行添加。 删除操作我们在替罪羊树中的删除操作并不是把它真的从替罪羊树中删除，而是给要删除的节点打上一个标记，代表我们要把他删除了。 在统计的时候我们要分开统计。 真正的节点数（用于查排名之类的操作） 全部的节点数（用来判断是否需要重构） 其实网上还有很多写法，比如当一个子树中坏点太多了严重影响树的平衡，就也需要重构之类的事情。 这么写其实在一定程度上可以减少这种情况的发生。 值得一提的是，我这里写的删除操作并不是把某个值为 $x$ 的节点删去，而是把排名为 $x$ ，的节点删去，所以在 $remove$ 之前，我们首先要进行一次查排名的操作。 void remove(node *o,int k)&#123; if(!o-&gt;del&amp;&amp;k==o-&gt;l-&gt;size+1)&#123; o-&gt;del=1; o-&gt;size--; return; &#125; o-&gt;size--; if(k&lt;=o-&gt;l-&gt;size+!o-&gt;del)remove(o-&gt;l,k); else remove(o-&gt;r,k-o-&gt;l-&gt;size-!o-&gt;del); &#125; int main()&#123; null=new node; root=null; n=read(); while(n--)&#123; op=read();x=read(); if(op==2)remove(root,Rank(root,x)); &#125; &#125; 插入操作对于插入操作，一般来讲是没什么可说的 void Insert(node* &amp;o,int x)&#123; if(o==null)&#123; o=new node; o-&gt;l=o-&gt;r=null; o-&gt;del=false; o-&gt;size=o-&gt;cnt=1; o-&gt;val=x; return; &#125; else&#123; o-&gt;size++; o-&gt;cnt++; if(x&gt;=o-&gt;val)insert(o-&gt;r,x); else insert(o-&gt;l,x); if(o-&gt;isbad())rebuild(o); &#125; &#125; 但其实这样是稍微有点问题的（虽然这并不影响你通过模板题） 我们可以发现这个片段： else&#123; o-&gt;size++; o-&gt;cnt++; if(x&gt;=o-&gt;val)insert(o-&gt;r,x); else insert(o-&gt;l,x); if(o-&gt;isbad())rebuild(o); &#125; 意思是如果发现了坏点我们就是直接重构。 其实会带来一些问题 如果在一颗子树内有很多坏点，而我们恰好最早发现的却是深度最大的一棵，于是我们很鸡儿蠢的从最底下开始一点一点一点的往上爬，一次一次一次的重构，导致其实这一个子树这么大一棵我们要重构到昏天黑地，直接导致有可能 $T$ 飞。（然而模板题并不会） 于是我们可以考虑用一个指针记录一下深度最小的坏点，然后重构的时候直接把一整棵树全都重构了，这样就省下了大把的时间用来颓废 这里我的实现方式是用一个指向指针地址的指针来记录。 虽然这样看起来很鸡儿蠢 node *null,*root,**badtag; void Insert(node* &amp;o,int x)&#123; if(o==null)&#123; o=new node; o-&gt;l=o-&gt;r=null; o-&gt;del=false; o-&gt;size=o-&gt;cnt=1; o-&gt;val=x; return; &#125; else&#123; o-&gt;size++; o-&gt;cnt++; if(x&gt;=o-&gt;val)Insert(o-&gt;r,x); else Insert(o-&gt;l,x); if(o-&gt;isbad())badtag=&amp;o; else if(badtag!=&amp;null) o-&gt;cnt-=(*badtag)-&gt;cnt-(*badtag)-&gt;size; &#125; &#125; void insert(node* &amp;o,int x)&#123; badtag=&amp;null; Insert(o,x); if(badtag!=&amp;null)rebuild(*badtag); &#125; int main()&#123; null=new node; root=null; n=read(); while(n--)&#123; op=read();x=read(); if(op==1)insert(root,x); &#125; &#125; 前驱与后继操作这里的求前驱和求后继与别的平衡树略有不同 对于查找前驱，我们可以直接查找比它的排名低一位的元素； 对于后继，我们可以查找比它大1的元素的排名，再查找该排名所对的元素。 然后这样模板题的所有操作我们就都资瓷了！ int Rank(node *o,int x)&#123; int ans=1; while(o!=null)&#123; if(o-&gt;val&gt;=x)o=o-&gt;l; else&#123; ans+=o-&gt;l-&gt;size+!o-&gt;del; o=o-&gt;r; &#125; &#125; return ans; &#125; int kth(node *o,int x)&#123; while(o!=null)&#123; if(!o-&gt;del&amp;&amp;o-&gt;l-&gt;size+1==x)return o-&gt;val; if(o-&gt;l-&gt;size&gt;=x)o=o-&gt;l; else&#123; x-=o-&gt;l-&gt;size+!o-&gt;del; o=o-&gt;r; &#125; &#125; &#125; int main()&#123; null=new node; root=null; n=read(); while(n--)&#123; op=read();x=read(); if(op==5)printf(&quot;%d\\n&quot;,kth(root,Rank(root,x)-1)); if(op==6)printf(&quot;%d\\n&quot;,kth(root,Rank(root,x+1))); &#125; return 0; &#125; 要说的就这么多了。 放一下模板题的代码： CODE：//#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const double alpha=0.7; #define INF 0x3f3f3f3f int n,op,x; struct node&#123; node *l,*r; int val,size,cnt;//val 值 size存在的节点数 cnt 全部的节点数 bool del; bool isbad()&#123; return l-&gt;cnt&gt;alpha*cnt||r-&gt;cnt&gt;alpha*cnt; &#125; void update()&#123; size=!del+l-&gt;size+r-&gt;size; cnt=l-&gt;cnt+r-&gt;cnt+1; &#125; &#125;; node *null,*root,**badtag; void dfs(node* o,vector&lt;node*&gt; &amp;v)&#123; if(o==null)return; dfs(o-&gt;l,v); if(!o-&gt;del)v.push_back(o); dfs(o-&gt;r,v); if(o-&gt;del)delete o; &#125; node* build(vector&lt;node*&gt; &amp;v,int l,int r)&#123; if(l&gt;=r)return null; int mid=(l+r)&gt;&gt;1; node *o=v[mid]; o-&gt;l=build(v,l,mid); o-&gt;r=build(v,mid+1,r); o-&gt;update(); return o; &#125; void rebuild(node* &amp;o)&#123; vector&lt;node*&gt; v; dfs(o,v); o=build(v,0,v.size()); &#125; void Insert(node* &amp;o,int x)&#123; if(o==null)&#123; o=new node; o-&gt;l=o-&gt;r=null; o-&gt;del=false; o-&gt;size=o-&gt;cnt=1; o-&gt;val=x; return; &#125; else&#123; o-&gt;size++; o-&gt;cnt++; if(x&gt;=o-&gt;val)Insert(o-&gt;r,x); else Insert(o-&gt;l,x); if(o-&gt;isbad())badtag=&amp;o; else if(badtag!=&amp;null) o-&gt;cnt-=(*badtag)-&gt;cnt-(*badtag)-&gt;size; &#125; &#125; void insert(node* &amp;o,int x)&#123; badtag=&amp;null; Insert(o,x); if(badtag!=&amp;null)rebuild(*badtag); &#125; int Rank(node *o,int x)&#123; int ans=1; while(o!=null)&#123; if(o-&gt;val&gt;=x)o=o-&gt;l; else&#123; ans+=o-&gt;l-&gt;size+!o-&gt;del; o=o-&gt;r; &#125; &#125; return ans; &#125; int kth(node *o,int x)&#123; while(o!=null)&#123; if(!o-&gt;del&amp;&amp;o-&gt;l-&gt;size+1==x)return o-&gt;val; if(o-&gt;l-&gt;size&gt;=x)o=o-&gt;l; else&#123; x-=o-&gt;l-&gt;size+!o-&gt;del; o=o-&gt;r; &#125; &#125; &#125; void remove(node *o,int k)&#123; if(!o-&gt;del&amp;&amp;k==o-&gt;l-&gt;size+1)&#123; o-&gt;del=1; o-&gt;size--; return; &#125; o-&gt;size--; if(k&lt;=o-&gt;l-&gt;size+!o-&gt;del)remove(o-&gt;l,k); else remove(o-&gt;r,k-o-&gt;l-&gt;size-!o-&gt;del); &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif null=new node; root=null; n=read(); while(n--)&#123; op=read();x=read(); if(op==1)insert(root,x); if(op==2)remove(root,Rank(root,x)); if(op==3)printf(&quot;%d\\n&quot;,Rank(root,x)); if(op==4)printf(&quot;%d\\n&quot;,kth(root,x)); if(op==5)printf(&quot;%d\\n&quot;,kth(root,Rank(root,x)-1)); if(op==6)printf(&quot;%d\\n&quot;,kth(root,Rank(root,x+1))); &#125; return 0; &#125;","path":"2021/05/31/替罪羊树学习笔记/","date":"05-31","excerpt":"","tags":[]},{"title":"P5494 【模板】线段树分裂","text":"刚写了线段树分裂的板子。 线段树分裂传送门 前置知识1.权值线段树 有一个很好的博客可以看看：传送门 2.动态开点线段树：传送门 3.线段树合并：传送门 4.主席树：传送门 简介线段树分裂，顾名思义就是将线段树分裂开。为了维护线段树合并所维护的可重集，我们需要将权值线段树中前 $k$ 小的数和其余数分在两颗权值线段树上进行维护。 具体操作其实很简单，线段树分裂是线段树合并的逆操作。对于待分裂区域与其他区域的公有节点，复制一份；对于独有节点，直接拿过来挂上去；最后记得 pushup。 其实和主席树是有很高相似度的。 int split(int rt,int l,int r,int ql,int qr)&#123; int o=++tot; if(ql==l&amp;&amp;qr==r)&#123; st[o]=st[rt]; st[rt].v=ls(rt)=rs(rt)=0; return o; &#125; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid)&#123; ls(o)=split(ls(rt),l,mid,ql,qr); &#125;else if(ql&gt;mid)&#123; rs(o)=split(rs(rt),mid+1,r,ql,qr); &#125;else&#123; ls(o)=split(ls(rt),l,mid,ql,mid); rs(o)=split(rs(rt),mid+1,r,mid+1,qr); &#125; push_up(rt);push_up(o); return o; &#125; 然后这玩意就讲完了 这么说其实权值线段树的操作啥的几乎就都搞定了，再结合别的东西就可以把权值线段树放在手里把玩了运用得得心应手了。 复杂度分析单点修改和区间修改和普通线段树是一样的，都是 $O(logn)$. 找第 k 小每层只会访问 $1$ 个节点，时间复杂度为 $O(logn)$. 线段树合并仅当两颗线段树在相同的节点都有值时，合并才需要花费时间，否则可以直接返回有值的一边. $O(nlogn)$ 这玩意复杂度确实很玄学，大家的说法也不太一样，于是我摘取了几位大佬的说法： @gxy001:显然，我们每次只会访问重合节点，那么单次合并的时间复杂度就可以认为是较小树的节点个数，那么显然，多次合并的总复杂度为总点数级别，$O(nlogn)$ 注：不能简单的认为其复杂度为单次合并的最坏复杂度乘询问次数。感性理解，在本题中，显然我们可以花费一次询问使树的节点加一条链，让合并的复杂度增大，但也会失去一次进行线段树合并的机会，这样就保证了其总复杂度不会过高。 @chenxinyang2006: 仅当两颗线段树在相同的节点都有值时，合并才需要花费时间，否则可以直接返回有值的一边 也就是说，合并一次，总节点数量减少1 一操作会在新线段树上，增加 $logn$ 个节点 三操作会增加一条链的节点，也是 $logn$ 个 所以总节点数不超过 $n+mlogn$，合并总复杂度不超过 $n+mlogn$ 线段树分裂我们可以看到，这个操作访问的节点和区间查询是一致的，复制边缘节点，直接拿走完整节点。时间复杂度 $O(logn)$ 之后就是本题： 本题：对于每个操作我们分着看： 操作零就是分裂了： int split(int rt,int l,int r,int ql,int qr)&#123; int o=++tot; if(ql==l&amp;&amp;qr==r)&#123; st[o]=st[rt]; st[rt].v=ls(rt)=rs(rt)=0; return o; &#125; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid)&#123; ls(o)=split(ls(rt),l,mid,ql,qr); &#125;else if(ql&gt;mid)&#123; rs(o)=split(rs(rt),mid+1,r,ql,qr); &#125;else&#123; ls(o)=split(ls(rt),l,mid,ql,mid); rs(o)=split(rs(rt),mid+1,r,mid+1,qr); &#125; push_up(rt);push_up(o); return o; &#125; 操作一合并两棵树即可： int merge(int p,int q)&#123; if(!p||!q)return p|q; int rt=++tot; st[rt].v=st[p].v+st[q].v; ls(rt)=merge(ls(p),ls(q)); rs(rt)=merge(rs(p),rs(q)); return rt; &#125; 操作二单点修改 void modify(int rt,int l,int r,int pos,int val)&#123; if(l==r)&#123; st[rt].v+=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)&#123; if(ls(rt)==0)ls(rt)=++tot; modify(ls(rt),l,mid,pos,val); &#125; else &#123; if(rs(rt)==0)rs(rt)=++tot; modify(rs(rt),mid+1,r,pos,val); &#125; push_up(rt); &#125; 操作三区间查询 ll query(int rt,int l,int r,int ql,int qr)&#123; if(ql&gt;r||qr&lt;l)return 0; if(ql&lt;=l&amp;&amp;qr&gt;=r)&#123; return st[rt].v; &#125; int mid=(l+r)&gt;&gt;1; return query(ls(rt),l,mid,ql,qr)+query(rs(rt),mid+1,r,ql,qr); &#125; 操作四查找第 $k$ 小，直接线段树上二分就行了 int kth(int rt,int l,int r,int k)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; if(st[ls(rt)].v&gt;=k)return kth(ls(rt),l,mid,k); else return kth(rs(rt),mid+1,r,k-st[ls(rt)].v); &#125; 这么来看这题没啥技术含量，充其量就是学了个分裂函数 CODE//#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=2e5+5; #define INF 0x3f3f3f3f #define ls(x) st[x].l #define rs(x) st[x].r int n,m,tot,op,p,c=1; int root[maxn]; ll a[maxn]; struct SegmentTree&#123; ll v; int l,r; &#125;st[maxn&lt;&lt;6]; inline void push_up(int rt)&#123; st[rt].v=st[ls(rt)].v+st[rs(rt)].v; &#125; int build(int l,int r)&#123; int rt=++tot; if(l==r)&#123; st[rt].v=a[l]; return rt; &#125; int mid=(l+r)&gt;&gt;1; ls(rt)=build(l,mid); rs(rt)=build(mid+1,r); push_up(rt); return rt; &#125; int split(int rt,int l,int r,int ql,int qr)&#123; int o=++tot; if(ql==l&amp;&amp;qr==r)&#123; st[o]=st[rt]; st[rt].v=ls(rt)=rs(rt)=0; return o; &#125; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid)&#123; ls(o)=split(ls(rt),l,mid,ql,qr); &#125;else if(ql&gt;mid)&#123; rs(o)=split(rs(rt),mid+1,r,ql,qr); &#125;else&#123; ls(o)=split(ls(rt),l,mid,ql,mid); rs(o)=split(rs(rt),mid+1,r,mid+1,qr); &#125; push_up(rt);push_up(o); return o; &#125; int merge(int p,int q)&#123; if(!p||!q)return p|q; int rt=++tot; st[rt].v=st[p].v+st[q].v; ls(rt)=merge(ls(p),ls(q)); rs(rt)=merge(rs(p),rs(q)); return rt; &#125; void modify(int rt,int l,int r,int pos,int val)&#123; if(l==r)&#123; st[rt].v+=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)&#123; if(ls(rt)==0)ls(rt)=++tot; modify(ls(rt),l,mid,pos,val); &#125; else &#123; if(rs(rt)==0)rs(rt)=++tot; modify(rs(rt),mid+1,r,pos,val); &#125; push_up(rt); &#125; ll query(int rt,int l,int r,int ql,int qr)&#123; if(ql&gt;r||qr&lt;l)return 0; if(ql&lt;=l&amp;&amp;qr&gt;=r)&#123; return st[rt].v; &#125; int mid=(l+r)&gt;&gt;1; return query(ls(rt),l,mid,ql,qr)+query(rs(rt),mid+1,r,ql,qr); &#125; int kth(int rt,int l,int r,int k)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; if(st[ls(rt)].v&gt;=k)return kth(ls(rt),l,mid,k); else return kth(rs(rt),mid+1,r,k-st[ls(rt)].v); &#125; inline ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); for(re int i=1;i&lt;=n;i++)&#123; a[i]=read(); &#125; root[1]=build(1,n); for(re int i=1;i&lt;=m;i++)&#123; op=read();p=read(); if(op==0)&#123; int x=read(),y=read(); root[++c]=split(root[p],1,n,x,y); &#125; if(op==1)&#123; int x=read(); root[p]=merge(root[p],root[x]); &#125; if(op==2)&#123; int x=read(),y=read(); modify(root[p],1,n,y,x); &#125; if(op==3)&#123; int x=read(),y=read(); printf(&quot;%lld\\n&quot;,query(root[p],1,n,x,y)); &#125; if(op==4)&#123; ll k=read(); if(query(root[p],1,n,1,n)&lt;k)printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,kth(root[p],1,n,k)); &#125; &#125; return 0; &#125;","path":"2021/05/25/P5494 【模板】线段树分裂/","date":"05-25","excerpt":"","tags":[]},{"title":"P5490 【模板】扫描线","text":"P5490 【模板】扫描线 求 $n$ 个矩形的面积并。 我们可以用一根竖直的或者水平的线扫过坐标系，这样的话我们可以发现，面积的变化只会出现在两端线段的位置上。（这里我倾向于竖直的） （图片是 @Gu_Pigeon 的） 也就是说，我们只需要记录一个矩形的左右两条竖直的边，也就是把一个矩形分成 $2 \\times n$ 段，每一段在扫描线上覆盖的长度乘上这一段的宽度就是这一段的矩形面积，把所有的矩形面积都加起来就可以获得面积并了。 。在本题中，题目会给出左下角和右上角的坐标，于是我们可以记录左右两条边。分别用一个四元组来记录： $(x_1,y_1,y_2,1)$ $(x_2,y_1,y_2,-1)$ struct Line&#123; ll x,low,high; int mark; bool operator &lt; (const Line &amp;a)const&#123; return x &lt; a.x; &#125; &#125;line[maxn&lt;&lt;1]; 其中我们假设 $x_1&lt;x_2,y_1&lt;y_2$ ，并且用 $1/-1$ 来表示这个边是左边还是右边。 之后我们可以对这些四元组按照 $x$ 递增排序。 之后要对这些线段进行离散化。 ll y[maxn&lt;&lt;1]; int main()&#123; n=read(); n&lt;&lt;=1; for(re int i=1;i&lt;=n;i+=2)&#123; xx=read();yy=read();x2=read();y2=read(); y[i]=yy,y[i+1]=y2; &#125; sort(y+1,y+n+1); int tot=unique(y+1,y+n+1)-y-1; &#125; （@CYJian提供了一种不需要离散化的做法，可以用标记永久化和动态开点偷个懒） 离散化以后，会出现 $tot$ 个不同的纵坐标值，于是我们的扫描线最多会被分成 $tot-1$ 段。 我们开一个数组 $cnt[]$ 来记录每一段被覆盖的次数。 扫描的过程中，如果当前四元组是 $(x_1,y_1,y_2,k)$ ，我们就把 $cnt[y[y_1]],cnt[[y_1]+1],\\cdots,cnt[[y_2]-1]$ 都加上 $k$ 。 在扫到下一个四元组的过程中，被覆盖的长度就等于 $\\sum \\limits_{c[i]&gt;0} (y[i+1]-y[i])$ 对于 $cnt$ 数组，我们可以使用线段树来维护，这样就可以 $O(n^2)-&gt;O(nlogn)$ 线段树需要维护两个内容： 1.这个线段被覆盖了多少次 2.这个线段被整个矩形覆盖的长度 struct SegmentTree&#123; int v; ll len; &#125;st[maxn&lt;&lt;2]; 对于一个四元组，我们在 $[y_1,y_2-1]$ 上执行区间修改操作。 对于线段树中任意一个节点 $[l,r]$ ，如果 $sum&gt;0$ 那么 $len=y[r+1]-y[l]$, 否则， $len$ 等于两个子节点的 $len$ 之和。最后根节点的 $len$ 就是整个扫描线上被覆盖的区间长度。 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+5; typedef long long ll; #define re register #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 int n,cnt; ll xx,yy,x2,y2,y[maxn&lt;&lt;1]; struct Line&#123; ll x,low,high; int mark; bool operator &lt; (const Line &amp;a)const&#123; return x&lt;a.x; &#125; &#125;line[maxn&lt;&lt;1]; struct SegmentTree&#123; int v; ll len; &#125;st[maxn&lt;&lt;2]; void push_up(int rt,int l,int r)&#123; if(st[rt].v)st[rt].len=y[r+1]-y[l]; else st[rt].len=st[ls].len+st[rs].len; &#125; void modify(int rt,int l,int r,ll ql,ll qr,int c)&#123; if(ql&gt;=y[r+1]||qr&lt;=y[l])return; if(ql&lt;=y[l]&amp;&amp;y[r+1]&lt;=qr)&#123; st[rt].v+=c; push_up(rt,l,r); return; &#125; int mid=(l+r)&gt;&gt;1; modify(ls,l,mid,ql,qr,c); modify(rs,mid+1,r,ql,qr,c); push_up(rt,l,r); &#125; inline ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;horizon.in&quot;,&quot;r&quot;,stdin); freopen(&quot;horizon.out&quot;,&quot;w&quot;,stdout); #endif n=read(); n&lt;&lt;=1; for(re int i=1;i&lt;=n;i+=2)&#123; xx=read();yy=read();x2=read();y2=read(); y[i]=yy,y[i+1]=y2; line[i]=(Line)&#123;xx,yy,y2,1&#125;; line[i+1]=(Line)&#123;x2,yy,y2,-1&#125;; &#125; sort(line+1,line+n+1); sort(y+1,y+n+1); int tot=unique(y+1,y+n+1)-y-1; ll ans=0; for(re int i=1;i&lt;n;i++)&#123; modify(1,1,tot-1,line[i].low,line[i].high,line[i].mark); ans+=st[1].len*(line[i+1].x-line[i].x); &#125; printf(&quot;%lld\\n&quot;,ans); return 0; &#125;","path":"2021/05/17/P5490 【模板】扫描线/","date":"05-17","excerpt":"","tags":[]},{"title":"P2569 股票交易（单调队列优化DP）","text":"单调队列优化DP题目传送门 简明题意：你初始时有$∞$ 元钱，并且每天持有的股票不超过 $Maxp$ 。 有$T$ 天，你知道每一天的买入价格 $AP_i$ ，卖出价格 $Bp_i$， 买入数量限制 $AS_i$，卖出数量限制 $BS_i$。 并且两次交易之间必须间隔 $W$天。 现在问你 $T$ 天结束后，最大收益是多少。 我们这么来想，股票买入我们可以看作是负收入 看过数据范围，我们考虑用 $DP$ 来解决这个问题 状态设计：我们考虑用一个二维数组，显然我们首先需要记录天数，于是第一维就是天数 题目中还有一些限制，就是我们在满足收益最大的前提下，还要满足一些条件： 1，两次交易必须间隔$w$天 2，持有的股票数不得超过给定数 第一个限制条件我们很容易就可以解决，只需要在转移的时候控制一下天数就好了，我们可以直接用$DP$的第一维解决。 第二个限制呢？显然我们需要用一个新的维来记录这个问题，也就是我们需要用第二维来记录手里有多少股票。 于是设 $f[i][j]$ 为$i$天以后拥有$j$张股票所能获得的最大收益。 状态转移：显然地存在三种大情况： 1，买股票 2，啥也不干 3，卖股票 首先对于买股票，我们又可以有两种，分别是凭空买和本来就有我再买。 啥也不干就显然了，我们就直接把前一天的搞过来就好了 麦股票显然就一种，我只能手里有的时候卖 于是我们有四种情况 case 1: 凭空买因为直接买，我们就可以把这个初始状态直接赋值，其他的搞成 $-inf$. $f[i][j]=-ap_i \\times j \\ ,\\ ( 0\\le j \\le as_i)$ case 2:不买也不卖直接把上一天的继承过来就可以了 $f[i][j]=max(f[i][j],f[i-1][j]),\\ ( 0\\le j \\le maxp)$ case 3: 在之前的基础买股票首先关于上面的问题 $1$，我们要满足之间间隔 $w$天，也就是上一次交易一定是在 $i-w-1$天的时候。 为什么我们一定在这一天进行交易？原因是我们在上一个 $case$ 中就解决了这个问题，我们已经把之前某一天以前的最优答案转移到了这一天，所以就不需要考虑以前的天数了，在这一天转移一定是比以前任何一天转移都要优的。 我们已知在第 $i$ 天拥有 $j$ 张股票，假设在第 $i-w-1$ 天有 $k$ 张股票。 $k$ 显然要比 $j$ 小，因为我们要买入，还有一个限制，我们一天最多买 $as_i$ 张，于是我们的 $k$ 的下线就是 $j-as_i$ 。 交易一共买入了 $j-k$ 张股票，要花 $(j-k) \\times ap_i $ 元 那么方程就显而易见了： $f[i][j]=max(f[i-w-1][k]-(j-k) \\times ap_i) \\ ,\\ (j-as_i \\le k \\le j)$ case 4:卖股票这个情况和上面那个很类似，但是略有不同。 这次因为要卖股票，所以 $k&gt;j$,并且$k \\le j+bs_i$. 本次交易卖出了 $k-j$ 张股票，赚钱 $(k-j) \\times bp_i$ 元。 方程： $f[i][j]=max(f[i-w-1][k]+(k-j) \\times bp_i) \\ ,\\ (j \\le k \\le j+bs_i)$ 优化：对于 $case\\ 3$ 和 $case\\ 4$ ,如果我们直接计算，可以发现复杂度大概是 $O(n \\times maxp ^2 )$ 的，妥妥的 $T$ 飞。 仔细观察式子： $case\\ 3:$$f[i][j]=max(f[i-w-1][k]-(j-k) \\times ap_i) \\ ,\\ (j-as_i \\le k \\le j)$ $case\\ 4:$$f[i][j]=max(f[i-w-1][k]+(k-j) \\times bp_i) \\ ,\\ (j \\le k \\le j+bs_i)$ 先来看$case\\ 3$， 我们把括号拆开，得： $f[i][j]=max(f[i-w-1][k]-j \\times ap_i +k \\times ap_i) \\ ,\\ (j-as_i \\le k \\le j)$ 发现其中有一项是不带 $k$ 的，我们把它提出来，得： $f[i][j]=max(f[i-w-1][k]+k \\times ap_i)-j\\times ap_i \\ ,\\ (j-as_i \\le k \\le j)$ 在给定 $i,j$的时候，只有一个变量 $k$ ，也就是只有$k$ 的取值会影响答案。并且在 $j$ 的循环恰当的时候， $k$ 是具有平移关系的。 或者换句话说：这是符合单调性优化的条件的。 同样的，$case\\ 4$ 我们同样可以得出类似的式子： $f[i][j]=max(f[i-w-1][k]+k \\times bp_i)-j \\times bp_i \\ ,\\ (j \\le k \\le j+bs_i)$ 于是我们使用单调队列，每次排除过期元素，然后补上新的选择，最后从对头取出最优解更新即可。 之后就是关于 $j$ 的循环顺序问题，我们要保证上一个状态已经有了。 对于 $case \\ 3$ ，我们需要用到 $(j-k)$ 的状态,于是需要正序先算出小的。 对于 $case \\ 4$ ，我们需要用到 $(k-j)$ 的状态,于是需要倒叙先算出大的。 于是 $case\\ 3$ 正序， $case \\ 4$ 倒序。 要说的就这么多了 CODE: //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=2005; inline int mymax(int x,int y)&#123; return x&gt;y?x:y; &#125; int T,maxp,w,ans; int ap,bp,as,bs; int f[maxn][maxn]; int q[maxn],l=1,r=0; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif memset(f,0xcf,sizeof(f)); T=read();maxp=read();w=read(); for(re int i=1;i&lt;=T;i++)&#123; ap=read();bp=read();as=read();bs=read(); for(re int j=0;j&lt;=as;j++)&#123;//case 1 f[i][j]=-1*j*ap; &#125; for(re int j=0;j&lt;=maxp;j++)&#123;// case 2 f[i][j]=mymax(f[i][j],f[i-1][j]); &#125; if(i&lt;=w)continue;//如果i&lt;=w，那么i-w-1就是负的了 l=1;r=0;//case 3 for(re int j=0;j&lt;=maxp;j++)&#123;//low to high while(l&lt;=r&amp;&amp;q[l]&lt;j-as)l++;//排除过期元素 while(l&lt;=r&amp;&amp;f[i-w-1][q[r]]+q[r]*ap&lt;=f[i-w-1][j]+j*ap)r--;//更新元素 q[++r]=j;//插入最新元素 if(l&lt;=r)f[i][j]=mymax(f[i][j],f[i-w-1][q[l]]+q[l]*ap-j*ap);// 如果单调队列里有元素，即可转移 &#125; l=1;r=0;//case 4 for(re int j=maxp;j&gt;=0;j--)&#123;//high to low while(l&lt;=r&amp;&amp;q[l]&gt;j+bs)l++;//排除过期元素 while(l&lt;=r&amp;&amp;f[i-w-1][q[r]]+q[r]*bp&lt;=f[i-w-1][j]+j*bp)r--;//更新元素 q[++r]=j;//插入最新元素 if(l&lt;=r)f[i][j]=mymax(f[i][j],f[i-w-1][q[l]]+q[l]*bp-j*bp); &#125; &#125; for(re int i=0;i&lt;=maxp;i++)&#123;//手上可以留下一点 ans=mymax(ans,f[T][i]); &#125; printf(&quot;%d\\n&quot;,ans); return 0; &#125; 总结：1，对于决策转移时，有明显单调性的情况，对于状态移动时，转移决策重复度较大。都可用单调队列优化。（滑动窗口） 2，对于单调性要主动发现，主动往那方面想","path":"2021/05/02/P2569 股票交易（单调队列优化DP）/","date":"05-02","excerpt":"","tags":[]},{"title":"计算几何小结","text":"计算几何小结向量线段相关点积：$a.x * b.x+a.y*b.y$ 叉积：$a.xb.y-a.yb.x$ 转角公式：逆时针旋转角度$B$ 原：$(cosAr,sinAr)$ 现：$(cos(A+B)r,sin(A+B)r)=((cosAcosB-sinAsinB)r,(sinAcosB+cosAsinB)r)$ 即：$(x,y)-&gt;(xcosB-ysinB,xsinB+ycosB)$ 极角排序：两种方法： 方法一：$atan2()$这是一个给定三角形对边和邻边算角的函数，在$cmath$库中对每个向量求$angle=atan2(a.y,a.x)$后直接排序即可 方法二：叉积叉积的正负可以判断左右关系，所以在最大跨角不超过180度的时候可以非常好地实现，否则有可能随机一个起点绕好几圈（我比较倾向于这个） 两直线夹角：若两个向量都是从原点出发，则可以很方便地用$\\theta=atan2(x \\times y,x*y)$ 叉积是平行四边形，底乘高；点积是底乘投影。更特殊点，该夹角是有向夹角，从$x$向量旋转到$y$，逆时针是正角、顺时针是负角。 两直线交点：面积比-&gt;线段比-&gt;定比分点 node crosss(node a1,node a2,node b1,node b2)&#123; node a=a2-a1,b=b2-b1,c=b1-a1; if(fabs(b*a)&lt;1e-12) return (node)&#123;-1e9,-1e9&#125;;//平行 double t=(b*c)/(b*a); return a1+(a^t); &#125; 判断两直线是否相交：$a1,a2,b1,b2$为两条直线的两个端点如果满足$(b1-a1)×(b1-a2)$和$(b2-a1)×(b2-a2)$不同号，并且$(a1-b1)×(a1-b2)$和$(a2-b1)×(a2-b2)$不同号，则两线段相交，叫跨立实验。 多边形相关：凸包：找到最下的点设为原点，将剩下的点用叉积极角排序用单调栈维护凸包，当叉积为非负时需要弹栈 struct node&#123; double x,y; inline bool operator &lt; (node a)const&#123;return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);&#125; &#125;p[maxn],st[maxn]; inline double v_pro(node a,node b,node c)&#123; return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y); &#125; int main()&#123; sort(p+1,p+1+n); st[0]=p[1]; for(re int i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;v_pro(st[top],st[top-1],p[i])&gt;=0)--top; st[++top]=p[i]; &#125; st[top=0]=p[n]; for(re int i=n-1;i;i--)&#123; while(top&amp;&amp;v_pro(st[top],st[top-1],p[i])&gt;=0)--top; st[++top]=p[i]; &#125; &#125; 判断点是否在多边形内：从该点向右引射线，与多边形交奇数次即在其内。顺时针$+1$，逆时针$-1$，注意与顶点重合的情况 $CF375C\\ \\ \\ \\ \\ Circling Round Treasures$ 判断点是否在凸包内：先判定和边界的关系然后找到与其极角相邻的两点，凭此判断须保证$A[1]=(0,0)$ ll inside(node a)&#123; if(a*A[1]&gt;0||A[tot]*a&gt;0) return 0; ll pos=lower_bound(A+1,A+tot+1,a,cmp2)-A-1; return (a-A[pos])*(A[pos%tot+1]-A[pos])&lt;=0; &#125; 求多边形面积：逆时针极角排序后直接用叉积求 double CalcS()&#123; double res=0; for(int i=2;i&lt;node;i++) res+=(A[i]-A[1])*(A[i+1]-A[1]); return res/2; &#125; 三角形重心：三点各坐标的平均值$(\\frac{x_1+x_2+x_3}{3},\\frac{y_1+y_2+y_3}{3})$ 算法：旋转卡壳：利用凸包上一些奇妙的单调性，求解 多边形直径 多边形宽度 最小面积矩形覆盖 等等 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=5e4+5; #define INF 0x3f3f3f3f3f3f3f3f struct node&#123; int x,y; &#125;p[maxn],p0,s[maxn]; int n,top; ll ans=INF; inline bool cmp(node a,node b)&#123; double A=atan2(a.y-p0.y,a.x-p0.x); double B=atan2(b.y-p0.y,b.x-p0.x); if(A!=B)return A&lt;B; return a.x&lt;b.x; &#125; inline ll V_pro(int x1,int y1,int x2,int y2)&#123;//Vector product return (1ll*x1*y2-1ll*x2*y1); &#125; inline ll compare(node a,node b,node c)&#123; return V_pro((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y)); &#125; inline void find()&#123; p0=(node)&#123;INF,INF&#125;; int k=0; for(re int i=0;i&lt;n;i++)&#123; if(p0.y&gt;p[i].y||(p0.y==p[i].y&amp;&amp;p0.x&gt;p[i].x))&#123; p0=p[i]; k=i; &#125; &#125; swap(p[k],p[0]); sort(p+1,p+n,cmp); s[0]=p[0],s[1]=p[1]; top=1; for(re int i=2;i&lt;n;i++)&#123; while(top&amp;&amp;compare(s[top-1],p[i],s[top])&gt;=0)top--; s[++top]=p[i]; &#125; &#125; inline ll dis(node a,node b)&#123; return 1ll*(a.x-b.x)*(a.x-b.x)+1ll*(a.y-b.y)*(a.y-b.y); &#125; ll getmax()&#123; ll tmp=0; if(top==1)&#123; return dis(s[0],s[1]); &#125; s[++top]=s[0]; int j=2; for(re int i=0;i&lt;top;i++)&#123; while(compare(s[i],s[i+1],s[j])&lt;compare(s[i],s[i+1],s[j+1]))&#123; j=(j+1)%top; &#125; tmp=max(tmp,max(dis(s[i],s[j]),dis(s[i+1],s[j]))); &#125; return tmp; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read(); for(re int i=0;i&lt;n;i++)&#123; p[i].x=read();p[i].y=read(); &#125; find(); ans=getmax(); printf(&quot;%lld\\n&quot;,ans); return 0; &#125; 闵可夫斯基和:定义：闵可夫斯基和 $(Minkowski\\ sum)$是两个欧几里得空间的点集的和，也称为这两个空间的膨胀集，以德国数学家闵可夫斯基命名。点集A与B的闵可夫斯基和被定义为： $A+B={ a+b|a∈A,b∈B}$ 若推广至流形的连续集，闵可夫斯基和从几何上的直观体现即是A集合沿B的边际连续运动一周扫过的区域与B集合本身的并集，也可以是B沿着A的边界连续运动扫过区域与A自身的并集。 求法：通过几何直观体现我们可以发现，其实闵可夫斯基和上的每一个边都是由原来的凸包平移得来的。于是我们的闵可夫斯基和其实就是要合并两个凸包。 针对其中任意一个凸包，首先极角已经是有序的了，于是在合并过程中，我们只需要进行归并排序，将两个凸包进行合并就可以了。 例题：P4557 [JSOI2018]战争 题意：给出两个点集A,B，以及q次询问。对于每次询问，给出一个向量，然后点集B向向量平移，若平移后的点集A与点集B构成的两个多边形存在交点则输出1，否则输出0。 通过读题我们可以知道，如果平移其中一个凸包后与另一个凸包有交点，那么一定满足：$a∈A,b∈B$,若移动向量为$c$,则存在$b+c=a$,移项得到$c=a-b$,,于是我们可以构造出一个闵可夫斯基和$C={ a+(-b)}$，之后我们只需要判断移动向量是否在我们构造的$C$中就可以了。 判断向量是否在凸包内：判断方法：首先判断和边界的关系，之后找到与其极角相邻的两点，凭此判断即可。 需要注意的是，我们的原点$(0,0)$是A[1] ll inside(node a)&#123; if(a*A[1]&gt;0||A[tot]*a&gt;0) return 0; ll pos=lower_bound(A+1,A+tot+1,a,cmp2)-A-1; return (a-A[pos])*(A[pos%tot+1]-A[pos])&lt;=0; &#125; 求凸包：inline void convex(node *B,ll &amp;n)&#123; sort(B+1,B+1+n,cmp1); p=B[1]; st[top=1]=1; for(re ll i=1;i&lt;=n;i++)&#123; B[i]=B[i]-p; &#125; sort(B+2,B+1+n,cmp2); for(re ll i=2;i&lt;=n;i++)&#123; while(top&gt;1&amp;&amp;(B[i]-B[st[top-1]])*(B[st[top]]-B[st[top-1]])&gt;=0)top--; st[++top]=i; &#125; for(re ll i=1;i&lt;=top;i++)&#123; B[i]=B[st[i]]+p; &#125; n=top,B[n+1]=B[1]; &#125; 合并两个凸包：inline void Minkowski()&#123; for(re ll i=1;i&lt;n;i++)&#123; s1[i]=C1[i+1]-C1[i]; s1[n]=C1[1]-C1[n]; &#125; for(re ll i=1;i&lt;m;i++)&#123; s2[i]=C2[i+1]-C2[i]; s2[m]=C2[1]-C2[m]; &#125; A[tot=1]=C1[1]+C2[1]; ll cnt1=1,cnt2=1; while(cnt1&lt;=n&amp;&amp;cnt2&lt;=m)++tot,A[tot]=A[tot-1]+(s1[cnt1]*s2[cnt2]&gt;=0?s1[cnt1++]:s2[cnt2++]); while(cnt1&lt;=n)++tot,A[tot]=A[tot-1]+s1[cnt1++]; while(cnt2&lt;=m)++tot,A[tot]=A[tot-1]+s2[cnt2++]; &#125; CODE://#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; const int maxm=1; ll n,m,q; ll st[maxn],top=1,tot; struct node&#123; ll x,y; node operator - (node A) &#123;return (node)&#123;x-A.x,y-A.y&#125;;&#125; node operator + (node A) &#123;return (node)&#123;x+A.x,y+A.y&#125;;&#125; ll operator * (node A) const &#123;return x*A.y-y*A.x;&#125;//vector_product ll len() const &#123;return x*x+y*y;&#125; &#125;s1[maxn],s2[maxn],A[maxn],C1[maxn],C2[maxn],p; inline bool cmp1(node A,node B)&#123; return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x); &#125; inline bool cmp2(node A,node B)&#123; return A*B&gt;0||(A*B==0&amp;&amp;A.len()&lt;B.len()); &#125; inline void convex(node *B,ll &amp;n)&#123; sort(B+1,B+1+n,cmp1); p=B[1]; st[top=1]=1; for(re ll i=1;i&lt;=n;i++)&#123; B[i]=B[i]-p; &#125; sort(B+2,B+1+n,cmp2); for(re ll i=2;i&lt;=n;i++)&#123; while(top&gt;1&amp;&amp;(B[i]-B[st[top-1]])*(B[st[top]]-B[st[top-1]])&gt;=0)top--; st[++top]=i; &#125; for(re ll i=1;i&lt;=top;i++)&#123; B[i]=B[st[i]]+p; &#125; n=top,B[n+1]=B[1]; &#125; inline void Minkowski()&#123; for(re ll i=1;i&lt;n;i++)&#123; s1[i]=C1[i+1]-C1[i]; s1[n]=C1[1]-C1[n]; &#125; for(re ll i=1;i&lt;m;i++)&#123; s2[i]=C2[i+1]-C2[i]; s2[m]=C2[1]-C2[m]; &#125; A[tot=1]=C1[1]+C2[1]; ll cnt1=1,cnt2=1; while(cnt1&lt;=n&amp;&amp;cnt2&lt;=m)++tot,A[tot]=A[tot-1]+(s1[cnt1]*s2[cnt2]&gt;=0?s1[cnt1++]:s2[cnt2++]); while(cnt1&lt;=n)++tot,A[tot]=A[tot-1]+s1[cnt1++]; while(cnt2&lt;=m)++tot,A[tot]=A[tot-1]+s2[cnt2++]; &#125; ll inside(node a)&#123; if(a*A[1]&gt;0||A[tot]*a&gt;0) return 0; ll pos=lower_bound(A+1,A+tot+1,a,cmp2)-A-1; return (a-A[pos])*(A[pos%tot+1]-A[pos])&lt;=0; &#125; inline ll read()&#123; ll x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read();q=read(); for(re ll i=1;i&lt;=n;i++)&#123; C1[i].x=read();C1[i].y=read(); &#125; convex(C1,n); for(re ll i=1;i&lt;=m;i++)&#123; C2[i].x=-read();C2[i].y=-read(); &#125; convex(C2,m); Minkowski(); convex(A,tot); p=A[1]; for(re ll i=tot;i&gt;=1;i--)A[i]=A[i]-A[1]; while(q--)&#123; A[0].x=read();A[0].y=read(); printf(&quot;%lld\\n&quot;,inside(A[0]-p)); &#125; return 0; &#125;","path":"2021/04/29/计算几何小结/","date":"04-29","excerpt":"","tags":[]},{"title":"莫队全家桶","text":"今天学习了莫队实在是太有魅力了 来写个学习笔记 莫队普通莫队莫队讲解一，什么是莫队莫队其实就是一种优雅的暴力，它十分玄学巧妙地将分块和暴力结合在了一起，主要用来处理离线区间查询等问题 由于莫队算法是由莫涛队长提出的，因此我们称这种算法为莫队 二，莫队原理大概说一下，莫队就是对询问进行排序，然后通过左右端点的移动来维护区间信息。 那显而易见，莫队是离线算法 当然莫队还有一些神奇的拓展：带修莫队，回滚莫队等等（等我学会了再来补博客 三，莫队的操作过程1，对于多段区间的询问,先将询问离线存储下来,然后再从左到右扫一遍,在过程中维护一段区间,就可以得到每个询问的答案. 2，但暴力扫肯定不行，所以在扫的过程中,需要对 $l$ 进行排序,以求能够在移动次数最少的情况下,得到所有希望求出的区间.（就是说，我们要调整$m$次询问的顺序，使之有序，这样我们在移动时，就可以不反复来回移动，而单向的用较少的次数就可以进行维护与查询操作 3，首先对每个区间进行分块操作,再将左端点在一起的区间询问放在一起进行处理,对于每个块处理一遍,那么就可以得到所有询问的答案.（分块的结合就是在这里 最严格的顺序是每个区间求一次曼哈顿距离最小生成树 四，莫队的代码实现自然我们要记录原数组，还要开一个 $cnt$ （用于统计答案个数，还有一个答案数组 ll ans[maxn],sum; int a[maxn],cnt[maxn],lal=1,lar=0;//lal lar分别是上一次的左右端点 按照顺序如何处理呢？ 把 $[1,n]$ 分成$ \\sqrt n$ 块 还有一种奇妙而玄学的分法： block=n/sqrt(m*2/3); 这样会更快一些； 我们先把这些区间按照左端点 $l$ 所在的块从左往右排序 再把l所在块相同的区间按 $r$ 从小到大排序 结构体数组存储查询的区间以及下标 struct node&#123; int l,r,id;//l是左端点，r是右端点，id是下标 inline bool operator &lt; (const node &amp;a)const&#123; return (belong[l]==belong[a.l])?r&lt;a.r:belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn];//mo captain，即莫队 这里再提一种玄学的玩意，名曰：奇偶优化 按奇偶块排序。这也是比较通用的。如果区间左端点所在块不同，那么就直接按左端点从小到大排；如果相同，奇块按右端点从小到大排，偶块按右端点从大到小排。 inline bool operator &lt; (const node &amp;a)const&#123; return belong[l]^belong[a.l]?belong[l]&lt;belong[a.l]:((belong[l]&amp;1)?r&lt;a.r:r&gt;a.r); &#125; 排好了序自然就要开始进行询问和维护操作了 这里也正是莫队的精髓 for(re int i=1;i&lt;=m;i++)&#123; int l=mocap[i].l,r=mocap[i].r; while(lal&gt;l)lal--,add(a[lal]); while(lar&lt;r)lar++,add(a[lar]); while(lal&lt;l)del(a[lal]),lal++; while(lar&gt;r)del(a[lar]),lar--; ans[mocap[i].id]=sum; &#125; 想象一个区间的移动； $add$ 和 $del$ 函数 inline void add(int x)&#123; sum+=2*cnt[x]+1; cnt[x]++; &#125; inline void del(int x)&#123; sum-=2*cnt[x]-1; cnt[x]--; &#125; 五，莫队的复杂度证明对于区间进行分块那么可以得到 $\\sqrt{n}$ 个块,那么对于就存在于 $\\sqrt{n}$ 个区间,而每次对于每个区间块中的 $l,r$ 的最坏情况是对于每个块都遍历到序列的最右端,共 $n$ 个点.每次移动指针复杂度为 $O(1)$ ,所以整个算法的复杂度 $O (n\\sqrt{n})$ 纠正：这东西是 $\\text O((n+m)\\sqrt n)$ 的，如果分成 $\\frac{n}{\\sqrt m}$ 是 $\\text O(n\\sqrt m)$ 的（感谢 YCS_GG） （真是太美妙了 例题：洛谷 P2709 小B的询问CODE：#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=5e5+5; int n,m,k,block; ll ans[maxn],sum; int a[maxn],cnt[maxn],lal=1,lar=0; struct node&#123; int l,r,id; inline bool operator &lt; (const node &amp;a)const&#123; return ((l-1)/block==(a.l-1)/block)?r&lt;a.r:l/block&lt;a.l/block; &#125; &#125;mocap[maxn]; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; inline void add(int x)&#123; sum+=2*cnt[x]+1; cnt[x]++; &#125; inline void del(int x)&#123; sum-=2*cnt[x]-1; cnt[x]--; &#125; int main()&#123; n=read();m=read();k=read(); block=sqrt(n); for(re int i=1;i&lt;=n;i++)&#123; a[i]=read(); &#125; for(re int i=1;i&lt;=m;i++)&#123; mocap[i].l=read(); mocap[i].r=read(); mocap[i].id=i; &#125; sort(mocap+1,mocap+1+m); for(re int i=1;i&lt;=m;i++)&#123; int l=mocap[i].l,r=mocap[i].r; while(lal&gt;l)lal--,add(a[lal]); while(lar&lt;r)lar++,add(a[lar]); while(lal&lt;l)del(a[lal]),lal++; while(lar&gt;r)del(a[lar]),lar--; ans[mocap[i].id]=sum; &#125; for(re int i=1;i&lt;=m;i++)&#123; printf(&quot;%lld\\n&quot;,ans[i]); &#125; return 0; &#125; 洛谷 P1494 [国家集训队]小Z的袜子首先我们明确莫队一般来讲是只能搞一个区间内某一些东西的出现次数的，如果让我们去求出概率该怎么办呢？ 我们用 $cnt$ 数组来记录区间 $[l,r]$ 内某种颜色的袜子出现的次数. 我们考虑在区间 $[l,r]$ 中取出两个相同颜色 $x$ 的情况有： $C_{cnt[x]}^2= \\dfrac{cnt[x] \\times (cnt[x]-1)}{2}$ 在区间 $[l,r]$ 中取出两个任意颜色的情况有： $C_{len}^2= \\dfrac{len \\times (len-1)}{2}$ 于是在区间 $[l,r]$ 中取出两个相同颜色 $x$ 的概率就可以搞得出来了： $C_{cnt[x]}^2= \\dfrac{cnt[x] \\times (cnt[x]-1)}{len \\times (len-1)}=\\dfrac{cnt[x] \\times (cnt[x]-1)}{(r-l+1) \\times (r-l)}=\\dfrac{cnt[x]^2-cnt[x]}{(r-l+1) \\times (r-l)}$ 于是在区间内抽到两个相同数字的概率就是： $\\sum\\limits_{i=1}^n \\dfrac{cnt[i]^2-cnt[i]}{(r-l+1) \\times (r-l)}= \\dfrac{\\sum\\limits_{i=1}^n cnt[i]^2-cnt[i]}{(r-l+1) \\times (r-l)}$ 对于区间 $[l,r]$ 我们有 $\\sum\\limits_{i=1}^n cnt[i]=r-l+1$ 所以答案为： $\\dfrac{\\sum\\limits_{i=1}^n cnt[i]^2-(r-l+1)}{(r-l+1) \\times (r-l)}$ 最后只需要用 $gcd$ 化简就可以了. 于是我们用 $cnt$ 数组维护平方和. CODE: //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=5e5+5; #define INF 0x3f3f3f3f int n,m,k,a[maxn],ans[maxn],lal=1,lar=0,sum,block,cnt[maxn]; ll l1[maxn],r1[maxn]; struct node&#123; int l,r,id; inline bool operator &lt; (const node &amp;a)const&#123; return ((l-1)/block==(a.l-1)/block)?r&lt;a.r:l/block&lt;a.l/block; &#125; &#125;mocap[maxn]; ll gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b); &#125; inline void add(int x)&#123; sum-=cnt[x]*(cnt[x]-1)/2; cnt[x]++; sum+=cnt[x]*(cnt[x]-1)/2; &#125; inline void del(int x)&#123; sum-=cnt[x]*(cnt[x]-1)/2; cnt[x]--; sum+=cnt[x]*(cnt[x]-1)/2; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); block=n/sqrt(m*2/3); for(re int i=1;i&lt;=n;i++)&#123; a[i]=read(); &#125; for(re int i=1;i&lt;=m;i++)&#123; mocap[i].l=read();mocap[i].r=read();mocap[i].id=i; l1[i]=mocap[i].l,r1[i]=mocap[i].r; &#125; sort(mocap+1,mocap+1+m); for(re int i=1;i&lt;=m;i++)&#123; int l=mocap[i].l,r=mocap[i].r; while(lal&gt;l)lal--,add(a[lal]); while(lar&lt;r)lar++,add(a[lar]); while(lal&lt;l)del(a[lal]),lal++; while(lar&gt;r)del(a[lar]),lar--; ans[mocap[i].id]=sum; &#125; for(re int i=1;i&lt;=m;i++)&#123; int tmp; tmp=gcd((ll)ans[i],(ll)(r1[i]-l1[i]+1)*(r1[i]-l1[i])/2); if(l1[i]==r1[i])printf(&quot;0/1\\n&quot;); else printf(&quot;%d/%lld\\n&quot;,ans[i]/tmp,(ll)((r1[i]-l1[i]+1)*(r1[i]-l1[i])/2)/tmp); &#125; return 0; &#125; 带修莫队P1903 [国家集训队]数颜色 / 维护队列 其实这道题在智能推荐里躺了很久了，但是我一直没有打开他，然后还一直大喊lj洛谷为什么没有带修莫队的板子题 wssb 首先我们知道普通的莫队是不能修改的。 因为我们每个询问的答案都是根据上一次询问的答案稍加调整得出来的，于是每一次修改操作就会导致对答案产生了严重的影响。 于是我们想办法消除这种影响。 考虑把查询操作和修改操作分别记录下来。 在记录查询操作的时候，需要增加一个变量来记录离本次查询最近的修改的位置（这种玩意其实类似于 $HH$ 的项链) 然后需要用一个变量记录当前已经进行了几次修改. 对于查询操作，如果上一次改的比本次查询需要改的少，就改过去 反之如果改多了就改回来。 简单来说，就是比较这次与上一次修改的操作次数不一样，我们就暴力的搞成一样的就行了。 也有一种说法是，在原有的 $l$ , $r$ 的基础上，增加一个时间轴 $t$ ,如果 $t$ 在 $l$ , $r$ 之间就更新。 关于结构体的改进： struct MOCAP&#123;//其实结构体应该开两个，就是说查询和修改都开，但是为了简便，我直接开了一个，一表两用 int l,r,id,pre;//l和r分别是查询中的左右端点和更改中的位置以及权值 inline bool operator &lt; (const MOCAP &amp;a)const&#123;//改进后的排序 return belong[l]==belong[a.l]?(belong[r]==belong[a.r]?pre&lt;a.pre:belong[r]&lt;belong[a.r]):belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn],modi[maxn]; 排序的方法： 关于左右端点的排序，与原来是一样的。 关于修改的排序，修改位置在前面的就排在前面 之后还有一个问题，就是说虽然是存在修改操作的，但是之后再查询的区间内进行修改对答案才是有影响的。 所以在暴力调整修改的时候保证一下区间端点位置就行了 之后还有一个小细节：在每次修改操作之后，下一次的操作一定是与这步是相反的 也就是改后-&gt;还原-&gt;修改-&gt;还原 所以我们直接交换就行了： inline void update(int x,int t)&#123; if(mocap[x].l&lt;=modi[t].l&amp;&amp;mocap[x].r&gt;=modi[t].l)&#123; del(a[modi[t].l]); add(modi[t].r); &#125; swap(a[modi[t].l],modi[t].r); &#125; 于是最后的操作就是这样的： for(re int i=1;i&lt;=cntq;i++)&#123; while(l&gt;mocap[i].l)l--,add(a[l]); while(l&lt;mocap[i].l)del(a[l]),l++; while(r&gt;mocap[i].r)del(a[r]),r--; while(r&lt;mocap[i].r)r++,add(a[r]); while(t&lt;mocap[i].pre)t++,update(i,t);//改少了 while(t&gt;mocap[i].pre)update(i,t),t--;//改多了 ans[mocap[i].id]=sum; &#125; 最后优化块长： 时间上的优化：将块的大小从 $sqrt(n)$ 改为 $n $的二分之三次方: block=pow(n,(double)2/(double)3); 然后复杂度大概就是 $O( n^ \\frac {5}{3})$. CODE://#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=3e5+5; const int maxm=2e6+5; int n,m,block; int l=1,r,t; int sum,c[maxm],a[maxn],ans[maxn],belong[maxn]; char op[5]; struct MOCAP&#123; int l,r,id,pre; inline bool operator &lt; (const MOCAP &amp;a)const&#123; return belong[l]==belong[a.l]?(belong[r]==belong[a.r]?pre&lt;a.pre:belong[r]&lt;belong[a.r]):belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn],modi[maxn]; int cntq,cntc; inline void add(int x)&#123; sum+= (++c[x]==1); &#125; inline void del(int x)&#123; sum-= (--c[x]==0); &#125; inline void update(int x,int t)&#123; if(mocap[x].l&lt;=modi[t].l&amp;&amp;mocap[x].r&gt;=modi[t].l)&#123; del(a[modi[t].l]); add(modi[t].r); &#125; swap(a[modi[t].l],modi[t].r); &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read(); block=pow(n,(double)2/(double)3); for(re int i=1;i&lt;=n;i++)&#123; a[i]=read(); belong[i]=(i-1)/block+1; &#125; for(re int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;op; if(op[0]==&#39;Q&#39;)&#123; mocap[++cntq].l=read(); mocap[cntq].r=read(); mocap[cntq].pre=cntc; mocap[cntq].id=cntq; &#125; if(op[0]==&#39;R&#39;)&#123; modi[++cntc].l=read();//注意这里的l指的是修改位置pos modi[cntc].r=read();//注意这里的r是修改权值val &#125; &#125; sort(mocap+1,mocap+1+cntq); for(re int i=1;i&lt;=cntq;i++)&#123; while(l&gt;mocap[i].l)l--,add(a[l]); while(l&lt;mocap[i].l)del(a[l]),l++; while(r&gt;mocap[i].r)del(a[r]),r--; while(r&lt;mocap[i].r)r++,add(a[r]); while(t&lt;mocap[i].pre)t++,update(i,t); while(t&gt;mocap[i].pre)update(i,t),t--; ans[mocap[i].id]=sum; &#125; for(re int i=1;i&lt;=cntq;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0; &#125; 树上莫队SP10707 COT2 - Count on a tree II 这就是树上莫队板子题了。 顾名思义，树上莫队就是树上的莫队这不nm废话吗 所以显然我们的策略就是要首先对树进行树剖，然后转化成线性结构，然后我们大力搞莫队就行了。 那么问题就来了，如何把他变成线性结构？ 前置知识 欧拉序众所周知，我们对树的遍历通常是两种序。如果不知道那你现在知道了 分别是 $DFS$ 序和欧拉序。首先来区别一下这两种序。 DFS序如图，我们的 $dfs$ 一般是这样的 这张图的dfs序为A-B-D-E-G-C-F-H 好 $DFS$ 就说完了。 什么？？这就说完了？ 确实，毕竟咱这里主要不说这玩意 接下来进入正题，欧拉序！ 欧拉序欧拉序就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序 所以对于这棵树，他的欧拉序就是这样的： 欧拉序为A-B-D-D-E-G-G-E-B-C-F-H-H-F-C-A 其实欧拉序是有两种的，一种是记录入度个，另一个是入度和出度都记录。 树上莫队用的是第二种，也就是我们上面说到的这种。 本题为什么要用到欧拉序呢？ 首先回顾一下题意，要求我们找到一条路径上的颜色个数，也就是不同的数字个数。 从欧拉序的形式上看，我们其实可以借助欧拉序去找一找路径上究竟有哪些点，以及该如何记录。 这里我们设 $st[i]$ 表示访问到 $i$ 时加入欧拉序的时间，$ed[i]$ 表示回溯经过 $i$ 时加入欧拉序的时间 不妨设 $st[x]$&lt;$st[y]$（也就是先访问 $x$，再访问 $y$） 分情况讨论; 情况一：如果 $LCA(x,y)=x$ ，这显然说明 $x$,$y$ 在同一条路径上。 于是我们取出 $st[x]$ 到 $st[y]$ 这一段区间，有的点会出现两次，有的点出现一次，应该明确出现两次的点对答案是没有贡献的，因为它进入了递归又在回溯时出去了，这证明这条路径一定是不经过这个子树的，于是我们只需要统计路径上出现两次的点。 我们拿上面的图来举例子： 如果两个点分别是 $A$,$G$ ,那么 $st[A]-st[G]$ 显然是 $A-B-D-D-E-G$ 出现两次的点是 $D$。 于是我们发现我们的路径 $A-G$ 上恰好是没有点 $D$ 的，于是…… 懂了吧 情况二：如果 $LCA(x,y) \\ne x$ ，这显然说明 $x$,$y$ 在两棵不同的子树内。 于是我们取出 $ed[x]-st[y]$ 依然对于这张图，我们举例子： 如果两个点分别是 $D$,$C$ 于是 $ed[D]-st[C]$ 显然就是： $D-E-G-G-E-B-C$ 同样的，我们只统计出现一次的点，两次的点也不统计。 但是有这样一个问题，我们上面的过程是有一个小问题的。 我们没有统计 $LCA$ ！ 后果不太严重，加上就好了 /cy 至于如何判断第一次与第二次的问题，这个很简单，我们多记录一个 $use[x]$，表示 $x$ 这个点有没有被加入，每次处理的时候如果 $use[x]=0$ 则需要添加节点；如果 $use[x]=1$ 则需要删除节点，每次处理之后都对 $use[x]$ 异或 $1$ 就可以了. inline void calc(int x)&#123; used[x]?del(x):add(x); used[x]^=1; &#125; 下面是一些细节 欧拉序直接用树剖就行了，在 $dfs1$ 中顺便就搞出来了。 $LCA$ 顺便也就搞出来了，多香 void dfs1(int u,int f)&#123; fa[u]=f; size[u]=1; deep[u]=deep[f]+1; st[u]=++tot; pot[tot]=u; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; ed[u]=++tot;pot[tot]=u; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(top[v])continue; dfs2(v,v); &#125; &#125; inline int LCA(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return deep[x]&lt;deep[y]?x:y; &#125; 一定要记得，欧拉序的长度是节点长度的 $2$ 倍，所以分块的时候要分 $n&lt;&lt;1$ for(re int i=1;i&lt;=(n&lt;&lt;1);i++)&#123; belong[i]=i/block+1; &#125; 这个题要离散化。 inline void Discretization()&#123; sort(data+1,data+1+n); int len=unique(data+1,data+1+n)-data-1; for(re int i=1;i&lt;=n;i++) a[i]=lower_bound(data+1,data+1+len,a[i])-data; &#125; 其实我觉得还是挺恶心的 CODE：//#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=1e5+5; #define INF 0x3f3f3f3f int n,m,block; int a[maxn],data[maxn]; int st[maxn],ed[maxn],tot; int belong[maxn]; struct MOCAP&#123; int l,r,id,lca,ans; inline bool operator &lt; (const MOCAP &amp;a)const&#123; return belong[l]==belong[a.l]?r&lt;a.r:belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn]; int nxt[maxn&lt;&lt;1],to[maxn&lt;&lt;1],head[maxn],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int deep[maxn],fa[maxn],top[maxn],son[maxn],size[maxn],pot[maxn]; void dfs1(int u,int f)&#123; fa[u]=f; size[u]=1; deep[u]=deep[f]+1; st[u]=++tot; pot[tot]=u; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; ed[u]=++tot;pot[tot]=u; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(top[v])continue; dfs2(v,v); &#125; &#125; inline void Discretization()&#123; sort(data+1,data+1+n); int len=unique(data+1,data+1+n)-data-1; for(re int i=1;i&lt;=n;i++) a[i]=lower_bound(data+1,data+1+len,a[i])-data; &#125; inline int LCA(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return deep[x]&lt;deep[y]?x:y; &#125; int used[maxn],c[maxn],sum,ans[maxn]; int l=1,r=0; inline void add(int x)&#123; sum+=(++c[a[x]]==1); &#125; inline void del(int x)&#123; sum-=(--c[a[x]]==0); &#125; inline void calc(int x)&#123; used[x]?del(x):add(x); used[x]^=1; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); block=n/sqrt(m*2/3); for(re int i=1;i&lt;=n;i++)&#123; a[i]=data[i]=read(); &#125; for(re int i=1;i&lt;=(n&lt;&lt;1);i++)&#123; belong[i]=i/block+1; &#125; Discretization(); for(re int i=1,x,y;i&lt;n;i++)&#123; x=read();y=read(); add(x,y); add(y,x); &#125; deep[1]=1; dfs1(1,0); dfs2(1,1); for(re int i=1,x,y;i&lt;=m;i++)&#123; x=read();y=read(); if(st[x]&gt;st[y])swap(x,y); int lca=LCA(x,y); mocap[i].id=i; if(lca==x) mocap[i].l=st[x],mocap[i].r=st[y]; else mocap[i].l=ed[x],mocap[i].r=st[y],mocap[i].lca=lca; &#125; sort(mocap+1,mocap+1+m); for(re int i=1;i&lt;=m;i++)&#123; while(l&lt;mocap[i].l)calc(pot[l]),l++; while(l&gt;mocap[i].l)l--,calc(pot[l]); while(r&lt;mocap[i].r)r++,calc(pot[r]); while(r&gt;mocap[i].r)calc(pot[r]),r--; if(mocap[i].lca)calc(mocap[i].lca); mocap[i].ans=sum; if(mocap[i].lca)calc(mocap[i].lca); &#125; for(re int i=1;i&lt;=m;i++)&#123; ans[mocap[i].id]=mocap[i].ans; &#125; for(re int i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0; &#125; 练习题：P4074 [WC2013] 糖果公园好啦，你现在学到了带修莫队和树上莫队的精髓啦，快来做这道超级无敌傻逼二合一题目吧！ 想当年我第一次见他的时候他还是个黑的，几天不见这么拉了 首先可以注意到这玩意的题目真的是非常长，这就预示着这是一道非常非常非常毒瘤的题目。 其实也没有很毒瘤，只是因为我太菜调不出来而已 简要题意： 给定一张 $n$ 个节点的树形图，每个节点 $i$ 有一种颜色 $C_i$,权值是 $V_{C_i}$（各个节点可能会有同样的颜色）。 每次讯问（？一条路径，对于其中的每一个节点，经过时可以获得 $V_i\\times W_i$ 的贡献. 每次经过同样的颜色时，$W_i$ 会发生变化。 求路径上 $\\sum \\limits_{C} val_c \\sum \\limits_{i=1}^{cnt_c}W_i$ 于是这就是比较显然的莫队了。 只不过他不仅要查询，而且还要支持更改操作。 于是这要求我们的莫队还得要带修。 于是就可以发现这是一道树上莫队加带修莫队的题了。 还是一样的思路，首先解决莫队上树的问题。 参考上面的树上莫队，首先需要使用欧拉序将树上路径提取出来使之成为线性结构，之后再进行莫队操作 依然使用树剖，顺带过程中求出 LCA namespace Tree_chain_partition&#123; int fa[maxn],size[maxn],son[maxn],dep[maxn],top[maxn]; int st[maxn],ed[maxn],pot[maxn],dfn; //前括号序st，后括号序ed，存储欧拉序的pot，以及时间戳 void dfs1(int u,int f)&#123;//树剖同时记录欧拉序 st[u]=++dfn;pot[dfn]=u; size[u]=1; fa[u]=f; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; ed[u]=++dfn;pot[dfn]=u; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u]||v==son[u])continue; dfs2(v,v); &#125; &#125; inline int lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y; &#125; &#125; 之后考虑带修的问题。 回忆上面讲过的带修莫队，需要在莫队基础上增加一个维度。 排序依旧是先按照左端点，其次是右端点，最后是时间维度。 int belong[maxn]; struct Mocap&#123; int l,r,id,lca,ans,pre; int pos,val; inline bool operator &lt; (Mocap &amp;a)const&#123; return belong[l]==belong[a.l]? belong[r]==belong[a.r]? pre&lt;a.pre: belong[r]&lt;belong[a.r]: belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn],modi[maxn]; 修改操作和查询操作的记录完全可以使用同一个结构体，比较方便，缺点是一个结构体里面变量太多，可能不大好调试 读入操作的时候和普通的树上莫队与带修莫队差别并不算大，直接把他们融合一下。 别忘了记录时间维度 for(re int i=1,op;i&lt;=q;i++)&#123; read(op); if(op==0)&#123; read(modi[++cntm].pos); read(modi[cntm].val); &#125; if(op==1)&#123; int x,y; read(x),read(y); if(st[x]&gt;st[y])swap(x,y); int LCA=lca(x,y); mocap[++cntq].id=cntq,mocap[cntq].pre=cntm;//记录时间维度 if(LCA==x)mocap[cntq].l=st[x],mocap[cntq].r=st[y]; else mocap[cntq].l=ed[x],mocap[cntq].r=st[y],mocap[cntq].lca=LCA; &#125; &#125; 对于过程中的移动操作，依然需要借用欧拉序节点重复的原理，使用访问判断，而不能使用一般莫队的直接 add 与 del 操作。 ll c[maxn],sum; inline void add(int x)&#123; sum+= V[C[x]]*W[++c[C[x]]]; &#125; inline void del(int x)&#123; sum-= V[C[x]]*W[c[C[x]]--]; &#125; bool vis[maxn]; inline void calc(int x)&#123; vis[x]?del(x):add(x); vis[x]^=1; &#125; 移动完了区间别忘了还要把修改也暴力调整一下。 inline void update(int x)&#123; if(vis[modi[x].pos])&#123; calc(modi[x].pos); swap(C[modi[x].pos],modi[x].val); calc(modi[x].pos); &#125; else swap(C[modi[x].pos],modi[x].val); &#125; lca 的贡献不要忘记。 for(re int i=1;i&lt;=cntq;i++)&#123; while(l&gt;mocap[i].l)calc(pot[--l]);//常规莫队 while(l&lt;mocap[i].l)calc(pot[l++]); while(r&gt;mocap[i].r)calc(pot[r--]); while(r&lt;mocap[i].r)calc(pot[++r]); while(tim&lt;mocap[i].pre)update(++tim);//修改 while(tim&gt;mocap[i].pre)update(tim--); if(mocap[i].lca)calc(mocap[i].lca);//统计lca贡献 ans[mocap[i].id]=sum; if(mocap[i].lca)calc(mocap[i].lca); &#125; 大概到这里就算是结束了，虽然过程非常繁琐，码量也不算小，但是如果封装几个 namespace 其实还是会好调很多的。 强烈谴责搞这么多读入，还有这么长的题面 注意事项 由于使用了欧拉序来提出序列，所以一条路径会变成原来的两倍，在分块的时候千万不要忘记这个事情。 同理由于上面的原因，数组也需要开两倍空间（这就是我 WA 了这么长时间的原因 一定要记得开 long long ！ 就这么多。 留个代码吧 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=2e5+5; #define int ll #define debug cerr&lt;&lt;&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;&lt;&lt;endl; int n,m,q,block; int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int V[maxn],W[maxn],C[maxn]; namespace MOCAP&#123; int belong[maxn]; struct Mocap&#123; int l,r,id,lca,ans,pre; int pos,val; inline bool operator &lt; (Mocap &amp;a)const&#123; return belong[l]==belong[a.l]? belong[r]==belong[a.r]? pre&lt;a.pre: belong[r]&lt;belong[a.r]: belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn],modi[maxn]; int cntm,cntq,l=1,r,tim=0; ll c[maxn],sum; inline void add(int x)&#123; sum+= V[C[x]]*W[++c[C[x]]]; &#125; inline void del(int x)&#123; sum-= V[C[x]]*W[c[C[x]]--]; &#125; bool vis[maxn]; inline void calc(int x)&#123; vis[x]?del(x):add(x); vis[x]^=1; &#125; inline void update(int x)&#123; if(vis[modi[x].pos])&#123; calc(modi[x].pos); swap(C[modi[x].pos],modi[x].val); calc(modi[x].pos); &#125; else swap(C[modi[x].pos],modi[x].val); &#125; ll ans[maxn]; &#125; using namespace MOCAP; namespace Tree_chain_partition&#123; int fa[maxn],size[maxn],son[maxn],dep[maxn],top[maxn]; int st[maxn],ed[maxn],pot[maxn],dfn; void dfs1(int u,int f)&#123; st[u]=++dfn;pot[dfn]=u; size[u]=1; fa[u]=f; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])son[u]=v; &#125; ed[u]=++dfn;pot[dfn]=u; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==fa[u]||v==son[u])continue; dfs2(v,v); &#125; &#125; inline int lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y; &#125; &#125; using namespace Tree_chain_partition; template&lt;typename T&gt; inline void read(T &amp;x)&#123; x=0;T f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; x*=f; &#125; inline void init()&#123; read(n),read(m),read(q); block=pow(n,(double)2/(double)3); for(re int i=1;i&lt;=n&lt;&lt;1;i++)&#123; belong[i]=(i-1)/block+1; &#125; for(re int i=1;i&lt;=m;i++)&#123; read(V[i]); &#125; for(re int i=1;i&lt;=n;i++)&#123; read(W[i]); &#125; for(re int i=1,u,v;i&lt;n;i++)&#123; read(u),read(v); add(u,v);add(v,u); &#125; for(re int i=1;i&lt;=n;i++)&#123; read(C[i]); &#125; dfs1(1,0); dfs2(1,1); &#125; signed main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;, stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;, stdout); #endif init(); for(re int i=1,op;i&lt;=q;i++)&#123; read(op); if(op==0)&#123; read(modi[++cntm].pos); read(modi[cntm].val); &#125; if(op==1)&#123; int x,y; read(x),read(y); if(st[x]&gt;st[y])swap(x,y); int LCA=lca(x,y); mocap[++cntq].id=cntq,mocap[cntq].pre=cntm; if(LCA==x)mocap[cntq].l=st[x],mocap[cntq].r=st[y]; else mocap[cntq].l=ed[x],mocap[cntq].r=st[y],mocap[cntq].lca=LCA; &#125; &#125; sort(mocap+1,mocap+1+cntq); for(re int i=1;i&lt;=cntq;i++)&#123; while(l&gt;mocap[i].l)calc(pot[--l]); while(l&lt;mocap[i].l)calc(pot[l++]); while(r&gt;mocap[i].r)calc(pot[r--]); while(r&lt;mocap[i].r)calc(pot[++r]); while(tim&lt;mocap[i].pre)update(++tim); while(tim&gt;mocap[i].pre)update(tim--); if(mocap[i].lca)calc(mocap[i].lca); ans[mocap[i].id]=sum; if(mocap[i].lca)calc(mocap[i].lca); &#125; for(re int i=1;i&lt;=cntq;i++)&#123; printf(&quot;%lld\\n&quot;,ans[i]); &#125; return 0; &#125; 回滚莫队（不删除莫队（少删除莫队））首先这个玄学的名字是从题解里看到的。 P5906 【模板】回滚莫队&amp;不删除莫队 这个题让我们求的玩意就非常诡异。 给定一个序列，多次询问一段区间 $[l,r]$，求区间中相同的数的最远间隔距离。 序列中两个元素的间隔距离指的是两个元素下标差的绝对值。 对于普通的莫队操作，一般是需要支持增加和修改两种操作。 可是有这样的一类题目，在你进行完移动操作以后需要立即更新答案（例如本题） 于是可以发现一个问题：在删除左侧以后，我们需要知道次左，然后又需要知道次左的次左…… 于是这玩意就直接凉了。 于是有这么个玩意名字叫回滚莫队，就可以解决这样的问题。 既然我们删除操作不好搞，那我们就不删除！（或者是少删除（这也是不删除莫队名字的由来）） 就是说要用增加来代替删除操作。 右端点的增加很好说，我们在排序的时候已经保证右端点有序。 于是就是左端点的问题了。 我们可以把左指针强行拉到右端点，然后让左指针往左走。然后再拉回右端点，然后再往左走。 记录答案只需要先算一算右边的答案，然后再算一算左边的（ $add()$ ） 然后算完以后我们就把左端点拉回来，然后把左边的贡献删掉就行了。 本题我们记左指针为 $l$，右指针为 $r$，当前块的右边界（分界线）为 $mid$， $[l,mid]$ 为左区间，$[mid,r]$ 为右区间 然后答案会有三种情况出现： 答案完全在左区间中 答案完全在右区间中 答案一部分在左区间中，一部分在右区间中 首先答案的右端点是单调的，因此取个 $\\max$ 即可，与当前扫到的下标相减就解决了情况 $1$ 和 $3$, 对于情况 $2$，我们要额外记录一个值，记录一个数在右区间中第一次出现的位置 假如 $max$ 也在右区间中，相减，就得到了情况2的答案。 细节相关$1$：如果左右边界都在同一个块内就暴力计算 int calc(int l,int r)&#123; int last[maxn],res=0; for(re int i=l;i&lt;=r;i++)last[a[i]]=0; for(re int i=l;i&lt;=r;i++)&#123; if(!last[a[i]])last[a[i]]=i; else res=max(res,i-last[a[i]]); &#125; return res; &#125; $2$：本题需要离散化 inline void Discretization()&#123; sort(num+1,num+1+n); int tmp=unique(num+1,num+1+n)-num-1; for(re int i=1;i&lt;=n;i++)a[i]=lower_bound(num+1,num+1+tmp,a[i])-num; &#125; $3$ :由于回滚的原因，所以现在的左询问一定是小于上一次的左询问，现在的右询问一定大于上一次的右询问，所以原来莫队的四个 $while$ 只剩下了两个 while(r&lt;mocap[i].r)&#123; r++;mr[a[r]]=r; if(!ml[a[r]])ml[a[r]]=r; ans=max(ans,r-ml[a[r]]); &#125; while(l&gt;mocap[i].l)&#123; l--; if(mr[a[l]])ans=max(ans,mr[a[l]]-l); else mr[a[l]]=l; &#125; Ans[mocap[i].id]=ans; $4$：最后不要忘记把左端点再拉回来： 同时有这样一个问题，再左端点走过去的时候，会影响贡献，又因为我们每次都要把左端点拉回最右侧，所以这个贡献对以后的询问是没什么用的，于是我们需要先记录一下当前的答案，再统计完左侧，记录完答案以后，把左端点拉回最右侧的时候去掉左侧的贡献，再把 $ans$ 更新回来就好了。 while(l&lt;=nowr)&#123; if(mr[a[l]]==l)mr[a[l]]=0; l++; &#125; int tmp=ans;//在l,r之间 ans=tmp;//把左端点拉回来以后 $5$：其实还有一个细节，就是 $memset$ 也许会影响常数大小，于是我们不必要每次清空整个数组，只需要记录每次更改了哪些就可以了。 最后再把这些清零就行了。 for()&#123; while(r&lt;q[i].r)&#123; r++; mr[a[r]]=r; if(!st[a[r]]) st[a[r]]=r,clear[++cn]=a[r]; //就是这里 ans=max(ans,r-st[a[r]]); &#125; &#125; for(int i=1;i&lt;=cn;i++) ma[clear[i]]=st[clear[i]]=0;//在大循环外 不过我没用，其实 $memset$ 的常数并不算太大，常数瓶颈并不在这里。确信 细节大概就这么多了。 CODE://#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=2e5+5; #define INF 0x3f3f3f3f int n,m,block,tot,ans; int a[maxn],num[maxn],belong[maxn],Ans[maxn]; int ml[maxn],mr[maxn];//ml是最早出现的位置，mr是最晚出现的位置 int nowr,l,r; struct MOCAP&#123; int l,r,id; inline bool operator &lt;(const MOCAP &amp;a)const&#123; return belong[l]==belong[a.l]?r&lt;a.r:belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn]; inline void Discretization()&#123; sort(num+1,num+1+n); int tmp=unique(num+1,num+1+n)-num-1; for(re int i=1;i&lt;=n;i++)a[i]=lower_bound(num+1,num+1+tmp,a[i])-num; &#125; int calc(int l,int r)&#123; int last[maxn],res=0; for(re int i=l;i&lt;=r;i++)last[a[i]]=0; for(re int i=l;i&lt;=r;i++)&#123; if(!last[a[i]])last[a[i]]=i; else res=max(res,i-last[a[i]]); &#125; return res; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read(); block=sqrt(n); for(re int i=1;i&lt;=n;i++)&#123; a[i]=num[i]=read(); belong[i]=(i-1)/block+1; &#125; tot=belong[n]; Discretization(); m=read(); for(re int i=1;i&lt;=m;i++)&#123; mocap[i].l=read();mocap[i].r=read(); mocap[i].id=i; &#125; sort(mocap+1,mocap+1+m); for(re int j=1,i=1;j&lt;=tot;j++)&#123; int nowr=min(n,j*block),l=nowr+1,r=l-1,ans=0; memset(ml,0,sizeof(ml)); memset(mr,0,sizeof(mr)); for(;belong[mocap[i].l]==j;i++)&#123; if(belong[mocap[i].r]==j)&#123; Ans[mocap[i].id]=calc(mocap[i].l,mocap[i].r); continue; &#125; while(r&lt;mocap[i].r)&#123; r++;mr[a[r]]=r; if(!ml[a[r]])ml[a[r]]=r; ans=max(ans,r-ml[a[r]]); &#125; int tmp=ans; while(l&gt;mocap[i].l)&#123; l--; if(mr[a[l]])ans=max(ans,mr[a[l]]-l); else mr[a[l]]=l;//最后出现的位置可能在左区间中 &#125; Ans[mocap[i].id]=ans; while(l&lt;=nowr)&#123; if(mr[a[l]]==l)mr[a[l]]=0; l++; &#125; ans=tmp; &#125; &#125; for(re int i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,Ans[i]); &#125; return 0; &#125; 例题 AT1219 歴史の研究AT1219 歴史の研究 首先这个题比上一个好写一些 但是作为一个菜鸡还是调了很久。 总结了以下槽点： $1$：这个题依然要离散化。 离散化完了以后千万别忘记你已经离散化了！！！ 不要傻乎乎的再使用原来的数据了 这充分说明我是个傻逼，这么低级的错误也能犯 $2$：这个题要开 $long \\ long$ 开了 $int$ 然后 $WA$ 了，百思不得其解，然后发现要 $long \\ long$ 好了其实别的几乎没有了，都是我比较傻逼 代码放这了 CODE://#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register const int maxn=1e5+5; #define INF 0x3f3f3f3f #define int long long int n,m,block,tot; int a[maxn],num[maxn],ans[maxn],belong[maxn]; int c[maxn]; inline void Discretization()&#123; sort(num+1,num+1+n); int tmp=unique(num+1,num+1+n)-num-1; for(re int i=1;i&lt;=n;i++)a[i]=lower_bound(num+1,num+1+tmp,a[i])-num; &#125; struct MOCAP&#123; int l,r,id; inline bool operator &lt; (const MOCAP &amp;a)const&#123; return belong[l]==belong[a.l]?r&lt;a.r:belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn]; inline int calc(int l,int r)&#123; int res=0; int cntt[maxn]; for(re int i=l;i&lt;=r;i++)&#123; cntt[a[i]]=0; &#125; for(re int i=l;i&lt;=r;i++)&#123; cntt[a[i]]++; res=max(res,cntt[a[i]]*num[a[i]]); &#125; return res; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; signed main()&#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;aa.out&quot;,&quot;w&quot;,stdout); #endif n=read();m=read(); block=sqrt(n); for(re int i=1;i&lt;=n;i++)&#123; a[i]=num[i]=read(); belong[i]=(i-1)/block+1; &#125; tot=belong[n]; Discretization(); for(re int i=1;i&lt;=m;i++)&#123; mocap[i].l=read();mocap[i].r=read(); mocap[i].id=i; &#125; sort(mocap+1,mocap+1+m); for(re int j=1,i=1;j&lt;=tot;j++)&#123; int nowr=min(n,j*block),l=nowr+1,r=l-1,sum=0; memset(c,0,sizeof(c)); for(;belong[mocap[i].l]==j;i++)&#123; if(belong[mocap[i].r]==j)&#123; ans[mocap[i].id]=calc(mocap[i].l,mocap[i].r); continue; &#125; while(r&lt;mocap[i].r)&#123; r++; c[a[r]]++; sum=max(sum,c[a[r]]*num[a[r]]); &#125; int tmp=sum; while(l&gt;mocap[i].l)&#123; l--; c[a[l]]++; sum=max(sum,c[a[l]]*num[a[l]]); &#125; ans[mocap[i].id]=sum; while(l&lt;=nowr)&#123; c[a[l]]--; l++; &#125; sum=tmp; &#125; &#125; for(re int i=1;i&lt;=m;i++)&#123; printf(&quot;%lld\\n&quot;,ans[i]); &#125; return 0; &#125; 变式 Rmq Problem / mexP4137 Rmq Problem / mex 后来我在智能推荐里找到了这道题。 一眼看上去这个题面，貌似之前讲过的。 之前讲的是可持久化线段树的做法。 但是现在发现这玩意还可以用回滚莫队来搞。 不过做了这道题确实颠覆和加深了我对回滚莫队的认识。 题目很简洁：求给定区间内没有出现的最小的自然数是多少。 稍加思考可以发现，这个东西的加入操作是没有办法做到 $O(1)$ 的。 比如目前有一个序列：$0,6,3,5,4,2$ ，现在没有出现的最小自然数是 $1$。 如果随着查询端点的移动，下一个位置要加入的数字恰好是 $1$，那么现在这个区间就出现 $1$ 了，于是我们要统计最小没有出现过的自然数的话就要从新统计。 这是不好的。 反观删除操作，如果还是上面的例子，现在右端点收缩，$2$ 就会被删除，于是我们只需要比较一下 $2,1$ 的大小关系，就可以在 $O(1)$ 的时间内确定新的 $mex$. 这启示我们需要使用一个只资瓷删除而不资瓷增加的莫队。 而根据我们刚刚学回滚莫队所联想的只资瓷增加不资瓷删除的回滚莫队相类比，我们可以将每个块按照左端点递增排序，右端点递减排序。 首先求出整个序列的 $mex$. 然后我们让右端点从整个序列的右侧不断地向左删除，同时左端点向右删除，处理完了以后我们让左端点回滚到块的左端点。这样就可以实现了。 struct MOCAP&#123; int l,r,id; inline bool operator &lt;(const MOCAP &amp;a)const&#123; return belong[l]==belong[a.l]?r&gt;a.r:belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn]; 可以画个图理解一下： 这个是普通的回滚莫队 这个是只减不增的回滚莫队 处理完一个块的询问之后，左指针必然会回滚到块的左端点 这时，类似只加不减的回滚莫队，先暴力地把右指针遍历到整个序列的最右端，然后左指针向右删除到下一个块的左端点。 细节相关：贡献与端点移动的先后关系：之前我们写的回滚莫队是只增不减的，现在的是只减不增的。 在只增不减的回滚莫队中： 我们已经处理过当前询问内的贡献，现在需要扩大范围，但是当前的贡献也要保留，所以应该先跳动端点指针，然后再增加贡献： while(r&lt;mocap[i].r)&#123; r++; c[a[r]]++; sum=max(sum,c[a[r]]*num[a[r]]); &#125; while(l&gt;mocap[i].l)&#123; l--; c[a[l]]++; sum=max(sum,c[a[l]]*num[a[l]]); &#125; （这两个片段是歴史の研究里面的） 在只减不增的回滚莫队中： 再来看这道题，只删除不增加： 我们需要缩小范围，也就是要逐个删除贡献，于是当前位置的贡献已经没有用了，所以要先删掉，才能移动指针去修改下一个位置： while(r&gt;mocap[i].r)&#123; if(a[r]&lt;=n+1&amp;&amp;!--cnt[a[r]])p=min(p,a[r]); r--; &#125; while(l&lt;mocap[i].l)&#123; if(a[l]&lt;=n+1&amp;&amp;!--cnt[a[l]])tmp=min(tmp,a[l]); l++; &#125; 关于左右端点的位置记录与移动因为以往的回滚都是要回到当前块的右端点，所以我们每次只记录右端点就可以了，但是这道题是要回到左端点，所以需要记录左端点。 处理完一个块以后，我们要控制左端点移动到下一个快的左端点，所以这些问题都要注意： int nowr=min(n,j*block),l=nowr+1,r=l-1,sum=0; （依然是歴史の研究里面的） int nowl=min(n,(j-1)*block)+1,l=nowl,r=n,p=mex,nxtl=min(n,j*block)+1; （本题目） 而且要注意，我们的右端点是要从整个序列的右端开始走的，所以要 $r=n$ . 然后就是把右端点拉回最右侧，左端点拉到下一个块，这个东西也是平常的回滚莫队没有的： while(r&lt;n)&#123; r++; if(a[r]&lt;=n+1)cnt[a[r]]++; &#125; while(l&lt;nxtl)&#123; if(a[l]&lt;=n+1&amp;&amp;!--cnt[a[l]])mex=min(mex,a[l]); l++; &#125; 关于在同一个块内的暴力计算首先这个东西有两种实现方法; $1$：开一个全局数组，每次暴力算就先用一用，然后统计完再把贡献删掉： if(belong[mocap[i].r]==j)&#123; int res=0; for(re int k=mocap[i].l;k&lt;=mocap[i].r;k++)&#123; if(a[k]&lt;=n+1)cntt[a[k]]++; &#125; while(cntt[res])res++; ans[mocap[i].id]=res; for(re int k=mocap[i].l;k&lt;=mocap[i].r;k++)&#123; if(a[k]&lt;=n+1)cntt[a[k]]--; &#125; continue; &#125; 但是我不喜欢。 如果你和我一样，都喜欢单独搞一个函数，然后在函数里直接统计，这样就可以不删除贡献了，用完就可以扔了。可以不负责的感觉好爽 但是一定要记得初始化！！ 不然你会 $WA$ 的很惨~ inline int calc(int l,int r)&#123; int res=0,cntt[maxn]; memset(cntt,0,sizeof(cntt)); for(re int i=l;i&lt;=r;i++)&#123; if(a[i]&lt;=n+1)cntt[a[i]]++; &#125; while(cntt[res])res++; return res; &#125; 其他问题就没啥可说的了。 放下代码 CODE：//#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define INF 0x3f3f3f3f #define re register const int maxn=2e5+5; int n,m,belong[maxn],block,tot; int cnt[maxn],mex,ans[maxn]; int a[maxn]; struct MOCAP&#123; int l,r,id; inline bool operator &lt;(const MOCAP &amp;a)const&#123; return belong[l]==belong[a.l]?r&gt;a.r:belong[l]&lt;belong[a.l]; &#125; &#125;mocap[maxn]; inline int calc(int l,int r)&#123; int res=0,cntt[maxn]; memset(cntt,0,sizeof(cntt)); for(re int i=l;i&lt;=r;i++)&#123; if(a[i]&lt;=n+1)cntt[a[i]]++; &#125; while(cntt[res])res++; return res; &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read(); block=sqrt(n); for(re int i=1;i&lt;=n;i++)&#123; a[i]=read(); belong[i]=(i-1)/block+1; if(a[i]&lt;=n+1)cnt[a[i]]++; &#125; while(cnt[mex])mex++; tot=belong[n]; for(re int i=1;i&lt;=m;i++)&#123; mocap[i].l=read();mocap[i].r=read(); mocap[i].id=i; &#125; sort(mocap+1,mocap+1+m); for(re int i=1,j=1;j&lt;=tot;j++)&#123; int nowl=min(n,(j-1)*block)+1,l=nowl,r=n,p=mex,nxtl=min(n,j*block)+1; for(;belong[mocap[i].l]==j;i++)&#123; if(belong[mocap[i].r]==j)&#123; ans[mocap[i].id]=calc(mocap[i].l,mocap[i].r); continue; &#125; while(r&gt;mocap[i].r)&#123; if(a[r]&lt;=n+1&amp;&amp;!--cnt[a[r]])p=min(p,a[r]); r--; &#125; int tmp=p; while(l&lt;mocap[i].l)&#123; if(a[l]&lt;=n+1&amp;&amp;!--cnt[a[l]])tmp=min(tmp,a[l]); l++; &#125; ans[mocap[i].id]=tmp; while(l&gt;nowl)&#123; l--; if(a[l]&lt;=n+1)cnt[a[l]]++; &#125; &#125; while(r&lt;n)&#123; r++; if(a[r]&lt;=n+1)cnt[a[r]]++; &#125; while(l&lt;nxtl)&#123; if(a[l]&lt;=n+1&amp;&amp;!--cnt[a[l]])mex=min(mex,a[l]); l++; &#125; &#125; for(re int i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0; &#125;","path":"2021/04/22/莫队全家桶/","date":"04-22","excerpt":"","tags":[]},{"title":"P3960 列队（动态开点线段树）","text":"我们都知道，线段树是一种效率较高的数据结构。但是它有一个缺点，就是我们需要的空间比较大。对于权值线段树，如果我们的值域比较大，那么我们所需要的空间就是惊人的，于是我们需要采取一些策略来解决这个问题。 在线段树的应用过程中，我们可以发现，在每次修改与查询操作的时候，我们只需要针对从根节点开始最多的 $log(n)$ 个节点进行操作就可以了，那么可以发现其他的很多节点其实并没有用上，那么我们可不可以在用到某一个区间的时候动态地把他开出来而不是一次性全部开出来呢？ 答案是肯定的，我们完全可以在一开始开出一个根节点代表$[1-n]$，在需要用到某个区间的时候再把这个区间所对的节点开出来供我们使用。 这样的话，可以发现我们舍弃了线段树的二倍编码原则，而是采用用变量记录形式来记录编号，并且在递归访问的时候，把每个节点代表的区间作为参数传递。 struct node&#123; int ls,rs; int data; &#125;st[maxn&lt;&lt;1]; int cnt; int build()&#123; cnt++; st[cnt].ls=st[cnt].rs=st[cnt].data=0; return cnt; &#125; 动态开点线段树比较好的例题是 P3960 [NOIP2017 提高组] 列队 经过观察我们可以发现，每次离队所影响的最多只是当前位置还有这一排的最后一个位置以及最后一列最后一行的位置； 于是我们可以考虑用一个支持单点修改的线段树，建立$n + 1$棵，前$n$棵代表第$n$行前$m - 1$个答案，第$n+1$棵表示最后一列。 第一步：我们所操作的是一个长相很规整的的矩形，根据题目的操作要求，我们可以将其分为n+1个区间，即$n \\times m$的矩形分为，$n \\times (m-1)$的矩形和$1 \\times n$ 的矩形，红色的矩形每一行算作一个区间，最后蓝色的一列独自成为一个区间，一共$n+1$个区间。 每我们的操作就是从所有红区间中，当输入x,y时，即代表我们要将第$x4=$的红区间的第$y$个数取出来，$[y+1,m]$的数往前挪一位，然后蓝区间的第$x$个数就会空出，然后将蓝区间的$[x+1,n]$的数往前挪一位，蓝区间的最后一位，也就是整个矩形的右下角会空出，最后，将取出的数放入右下角这个空即可 第二步：我们因为此时的区间不是在移动就是在提取，所以是维护区间，所以自然想到了线段树，因为是维护多个区间，即多个根。所以此时要用到主席树. 第三步：一个区间约有$n$个数，如果每个数都往前挪一位，$q$次询问，每次询问带有$n$次挪移，那么我们考虑不挪动，而是给即将空出来的位置打上标记，表示这个数已经被用过，因为区间最后会再加一个数进来，所以区间长度不变。两种方式最后留下的区间等价 CODE： //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define re register const int maxn=3e5+5; int n,m,q,now; int cnt,Max; ll ans; struct node&#123; int ls,rs,size;//size:当前区间内有多少个数没有被标记 ll val; node()&#123;&#125; node(const int _ls,const int _rs,const int _size,const ll _val): ls(_ls),rs(_rs),size(_size),val(_val)&#123;&#125; &#125;st[maxn&lt;&lt;5];//严格来讲应该开 Q * log2(N)，也就是20倍 ，为了方便与保险，我们直接开32倍 int ins[maxn],root[maxn]; //ins[i]记录第i棵树插入了多少个新数 //root[i]记录第i棵树的根节点 inline int len(int l,int r)&#123; if(now==n+1)&#123; if(r&lt;=n)return r-l+1; if(l&lt;=n)return n-l+1; return 0; &#125; if(r&lt;m)return r-l+1; if(l&lt;m)return (m-1)-l+1; return 0; &#125; ll query(int &amp;rt,int l,int r,int pos)&#123; if(!rt)&#123;//动态开点 rt=++cnt; st[rt].size=len(l,r); if(l==r)&#123; if(now==n+1)st[rt].val=1ll*l*m; else st[rt].val=1ll*(now-1)*m+l; &#125; &#125; st[rt].size--;这个区间有一个数被取出 if(l==r)return st[rt].val; int mid=(l+r)&gt;&gt;1; if(!st[rt].ls &amp;&amp;len(l,mid)&gt;=pos||st[st[rt].ls].size&gt;=pos)&#123; query(st[rt].ls,l,mid,pos); &#125; else&#123; int tmp; if(!st[rt].ls)tmp=len(l,mid); else tmp=st[st[rt].ls].size; return query(st[rt].rs,mid+1,r,pos-tmp); &#125; &#125; void modify(int &amp;rt,int l,int r,int pos,ll num)&#123; if(!rt)&#123; rt=++cnt; st[rt].size=len(l,r); if(l==r)&#123; st[rt].val=num; &#125; &#125; ++st[rt].size;//这个区间末尾有一个人进去 if(l==r)return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)modify(st[rt].ls,l,mid,pos,num); else modify(st[rt].rs,mid+1,r,pos,num); &#125; inline int read() &#123; int x = 0, f = 1;char ch = getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x * f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read();q=read(); Max=max(n,m)+q;//一共有q次离队，于是最多有q个人再次进队，于是最大也就是队列长度加上他们本身（因为我们取出以后在位置进行标记，相当于占上了位置 while(q--)&#123; int x=read(),y=read(); if(y==m)&#123;//如果是最后一列 now=n+1;//那么一定要放到那个单独的区间里面去，也就是上面说到的蓝色区域 ans=query(root[now],1,Max,x); &#125; else&#123; now=x;//否则，那么一定在红色区域 ans=query(root[now],1,Max,y); &#125; printf(&quot;%lld\\n&quot;,ans);//输出答案 now=n+1;//让被选出的人进入蓝色区域的最后一个位置 modify(root[now],1,Max,n+(++ins[now]),ans); if(y!=m)&#123; ans=query(root[now],1,Max,x); now=x; modify(root[now],1,Max,m-1+(++ins[now]),ans); &#125; &#125; return 0; &#125;","path":"2021/04/21/P3960 列队（动态开点线段树）/","date":"04-21","excerpt":"","tags":[]},{"title":"P4556 雨天的尾巴（线段树合并）","text":"对于值域线段树，如果他们维护相同的值域，那么他们对各个子区间的划分是一致的，于是暗示着我们这些线段树是具有可合并性的。 我们可以使用两个指针以递归形式同步遍历这两棵线段树，也就是他们始终指向同一个区间。 显然地，会有两种情况： 1，其中有一个是空的，那么我们取另一个不空的作为新线段树的节点 2，两个都不为空，那么递归合并这两棵线段树的左右子树，最后删除一个，留下另一个，自底向上更新信息。 常见的写法有两种，它们各有利弊： 第一种，我们直接把两个合起来，也就是说，其中一个的结构会被破坏，这也就意味着如果合并后还有操作针对于被合并了的的某棵线段树那么我们就GG，于是只能离线去搞。 但是优点就是省空间。 int merge(int p,int q,int l,int r)&#123; if(!p||!q)return p+q; if(l==r)&#123; dat[p]+=dat[q]; t[p]=l; return p; &#125; int mid=(l+r)&gt;&gt;1; L[p]=merge(L[p],L[q],l,mid); R[p]=merge(R[p],R[q],mid+1,r); push_up(p); return p; &#125; 第二种，我们可以开出一个新的节点来存放合并后的树，这样我们原来的线段树的结构不变就得到了保障，这样就可以在线了。 缺点自然也很显然，每次合并我们都要重开一个新的节点，于是空间是炸的。 int merge(int p,int q,int l,int r) &#123; if(!p||!q)return p+q; int rt=++tot; if(l==r)&#123; dat[rt]=dat[p]+dat[q]; t[rt]=l; return rt; &#125; int mid=(x+y)&gt;&gt;1; L[root]=merge(L[p],L[q],l,mid); R[root]=merge(R[p],R[q],mid+1,r); pushup(rt); return rt; &#125; 根据情况权衡利弊以后谨慎使用吧 如果空间卡的死，又保证不对被合并过的树进行操作，那就选第一种。 要是要求在线保留树的结构，空间不严格那就第二种。 其他的部分对普通权值线段树微改一下就好了，没什么太大的区别； 复杂度是$O(mlogn)$的，很高效了 例题：P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并 题目很简单，我们直接把$z$当成值域，每一个节点维护一个权值线段树。 然后针对每次放粮我们直接树上差分，$u$到$v$的路径直接处理成$u+1$,$v+1$,$lca(u,v)-1$,$fa[lca(u,v)]-1$就好了，最后我们做一次树上前缀和就可了 //#define LawrenceSivan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; #define INF 0x3f3f3f3f #define re register const int maxn=1e5+5; const int maxm=6e6+5; inline int mymax(int a,int b)&#123; return a&gt;b?a:b; &#125; inline int mymin(int a,int b)&#123; return a&lt;b?a:b; &#125; int n,m,MAX,tot; int X[maxn],Y[maxn],Z[maxn],ans[maxn],root[maxn]; int L[maxm],R[maxm],dat[maxm],t[maxm]; int head[maxn],nxt[maxn&lt;&lt;1],to[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123; nxt[++cnt]=head[u]; to[cnt]=v; head[u]=cnt; &#125; int fa[maxn],top[maxn],size[maxn],son[maxn],dep[maxn]; void dfs1(int u,int f)&#123; size[u]=1; fa[u]=f; dep[u]=dep[f]+1; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==f)continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]])&#123; son[u]=v; &#125; &#125; &#125; void dfs2(int u,int topf)&#123; top[u]=topf; if(!son[u])return; dfs2(son[u],topf); for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==topf||v==son[u]||top[v])continue; dfs2(v,v); &#125; &#125; inline int lca(int u,int v)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); u=fa[top[u]]; &#125; return dep[u]&lt;dep[v]?u:v; &#125; inline void push_up(int rt)&#123; if(dat[L[rt]]&gt;=dat[R[rt]])dat[rt]=dat[L[rt]],t[rt]=t[L[rt]]; else dat[rt]=dat[R[rt]],t[rt]=t[R[rt]]; &#125; int modify(int rt,int l,int r,int pos,int val)&#123; if(!rt)rt=++tot; if(l==r)&#123; dat[rt]+=val; t[rt]=l; return rt; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)L[rt]=modify(L[rt],l,mid,pos,val); else R[rt]=modify(R[rt],mid+1,r,pos,val); push_up(rt); return rt; &#125; int merge(int p,int q,int l,int r)&#123; if(!p||!q)return p+q; if(l==r)&#123; dat[p]+=dat[q]; t[p]=l; return p; &#125; int mid=(l+r)&gt;&gt;1; L[p]=merge(L[p],L[q],l,mid); R[p]=merge(R[p],R[q],mid+1,r); push_up(p); return p; &#125; void solve(int u)&#123; for(re int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(dep[v]&gt;dep[u])solve(v),root[u]=merge(root[u],root[v],1,MAX); if(dat[root[u]])ans[u]=t[root[u]]; &#125; &#125; inline int read()&#123; int x=0, f=1;char ch=getchar(); while (!isdigit(ch)) &#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main() &#123; #ifdef LawrenceSivan freopen(&quot;aa.in&quot;, &quot;r&quot;, stdin); freopen(&quot;aa.out&quot;, &quot;w&quot;, stdout); #endif n=read();m=read(); for(re int i=1,u,v;i&lt;n;i++)&#123; u=read();v=read(); add(u,v); add(v,u); &#125; dfs1(1,0); dfs2(1,1); for(re int i=1;i&lt;=m;i++)&#123; X[i]=read();Y[i]=read();Z[i]=read(); MAX=mymax(Z[i],MAX); &#125; for(re int i=1;i&lt;=m;i++)&#123; int LCA=lca(X[i],Y[i]); root[X[i]]=modify(root[X[i]],1,MAX,Z[i],1); root[Y[i]]=modify(root[Y[i]],1,MAX,Z[i],1); root[LCA]=modify(root[LCA],1,MAX,Z[i],-1); if(fa[LCA])root[fa[LCA]]=modify(root[fa[LCA]],1,MAX,Z[i],-1); &#125; solve(1); for(re int i=1;i&lt;=n;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0; &#125;","path":"2021/04/20/P4556 雨天的尾巴（线段树合并）/","date":"04-20","excerpt":"","tags":[]},{"title":"十五数码问题（IDA*）","text":"这个题可真是快调死我了 题面很简单，就是十五个数字的华容道，然后问最少几步可以还原成初始状态（貌似是人工智能经典问题？ 有了八数码问题的经验，我们知道这玩意肯定是要各种玄学做法（比如什么要人命的康托展开双向广搜$A*$迭代加深$IDA*$ $bulabula$~ 康托展开就算了吧，那玩意真心懒得写，而且十五数码问题用这种东西貌似不合适（其实是不会 $A*$写起来太麻烦，于是写写$IDA*$罢,貌似这题双向广搜会快一些？ 其实$IDA*$也没有很慢好吧 （不开$O_2$根本过不了 对于估价函数，我们可以考虑曼哈顿距离，估价函数的值等同于当前状态下所有非 $0$ 的数字到目标位置的曼哈顿距离之和。 而且对于$15$数码问题，我们可以得出以下结论：十五数码和八数码判断是否有解的方法不同，八数码$0$的移动不影响其余$7$个数字逆序数的奇偶性，而十五数码$0$的左右移动不影响其余$15$个数逆序数的奇偶性 （顺序不变），但上下移动改变奇偶（移动三次），加上$0$的话$16$个数逆序数左右改变（移动一次），上下也改变（移动$7$次），需要注意每次移动$0$的距离奇偶性也改变（$0$到目标位置的曼哈顿距离不是加1就是减一），所以$16$个数逆序数与$0$的距离之和$s$的奇偶性不因$0$的滑动而改变，初始时$s$是奇数，所以只有$s$是奇数的状态才是可到达的. 于是我们在搜之前先判一下有没有解： inline bool check()&#123;//check it is the ans or not int cnt=0,tot=0; for (int i=1;i&lt;=4;++i)&#123; for (int j=1;j&lt;=4;++j)&#123; puz[tot]=tmp[i][j]; tot++; &#125; &#125; for (int i=0;i&lt;16;++i)&#123; if (puz[i]==0) cnt+=3-i/4; else&#123; for (int j=0;j&lt;i;++j)&#123; if (puz[j] &amp;&amp; puz[j]&gt;puz[i])&#123; cnt++; &#125; &#125; &#125; &#125; return !(cnt&amp;1); &#125; 之后我们还需要加入一个剪枝：永远不要走和上一步相反的路； 大概就这些 //#define LawrenceSivan #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define re register int x,y,cnt; int tmp[5][5]; int puz[16]; const int goal[5][5]=&#123; &#123;0,0,0,0,0&#125;, &#123;0,1,2,3,4&#125;, &#123;0,5,6,7,8&#125;, &#123;0,9,10,11,12&#125;, &#123;0,13,14,15,0&#125; &#125;; const int dx[4]=&#123;0,1,-1,0&#125;; const int dy[4]=&#123;1,0,0,-1&#125;; const int px[16]=&#123;4,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4&#125;; const int py[16]=&#123;4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3&#125;; inline int mabs(int a)&#123; return a&gt;0?a:-a; &#125; inline bool check()&#123;//check it is the ans or not int cnt=0,tot=0; for (int i=1;i&lt;=4;++i)&#123; for (int j=1;j&lt;=4;++j)&#123; puz[tot]=tmp[i][j]; tot++; &#125; &#125; for (int i=0;i&lt;16;++i)&#123; if (puz[i]==0) cnt+=3-i/4; else&#123; for (int j=0;j&lt;i;++j)&#123; if (puz[j] &amp;&amp; puz[j]&gt;puz[i])&#123; cnt++; &#125; &#125; &#125; &#125; return !(cnt&amp;1); &#125; inline int evaluate()&#123;//judge it can get the ans or not int res=0; for(int i=1;i&lt;=4;i++)&#123; for(int j=1;j&lt;=4;j++)&#123; if(tmp[i][j]==0)continue; res+=mabs(i-px[tmp[i][j]])+mabs(j-py[tmp[i][j]]); &#125; &#125; return res; &#125; inline int getway(int i)&#123; if(dx[i]==-1)return 2; if(dx[i]==1)return 1; if(dy[i]==-1)return 4; if(dy[i]==1)return 3; &#125; inline bool test(int i,int pre)&#123; if(dx[i]==-1&amp;&amp;pre==1)return true; if(dx[i]==1&amp;&amp;pre==2)return true; if(dy[i]==-1&amp;&amp;pre==3)return true; if(dy[i]==1&amp;&amp;pre==4)return true; return false; &#125; bool IDA_star(int step,int x,int y,int pre)&#123;//do it int eva=evaluate(); if(!eva)return true; if(step+eva&gt;cnt)return false; for(int i=0;i&lt;4;i++)&#123; int xx=x+dx[i]; int yy=y+dy[i]; if(xx&gt;4||xx&lt;1||yy&gt;4||yy&lt;1||test(i,pre))continue; swap(tmp[xx][yy],tmp[x][y]); if(IDA_star(step+1,xx,yy,getway(i)))return true; swap(tmp[xx][yy],tmp[x][y]); &#125; return false; &#125; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+(ch^48);ch=getchar();&#125; return x*f; &#125; int main()&#123; #ifdef LawrenceSivan freopen(&quot;puzzle.in&quot;,&quot;r&quot;,stdin); freopen(&quot;puzzle.out&quot;,&quot;w&quot;,stdout); #endif for(re int i=1;i&lt;=4;i++)&#123; for(re int j=1;j&lt;=4;j++)&#123; tmp[i][j]=read(); if(tmp[i][j]==0)x=i,y=j; &#125; &#125; /*for(re int i=1;i&lt;=4;i++)&#123; for(re int j=1;j&lt;=4;j++)&#123; cout&lt;&lt;tmp[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;*/ if(!evaluate())&#123;//if the begin is the end printf(&quot;%d\\n&quot;,0); return 0; &#125; if(!check())&#123;//if the begin is the end printf(&quot;No\\n&quot;); return 0; &#125; while(++cnt)&#123; if(IDA_star(0,x,y,0))&#123; printf(&quot;%d\\n&quot;,cnt); return 0; &#125; if(cnt&gt;50)&#123; printf(&quot;No\\n&quot;); return 0; &#125; &#125; return 0; &#125;","path":"2021/04/15/十五数码问题（IDA-）/","date":"04-15","excerpt":"","tags":[]},{"title":"p2455 线性方程组（高斯消元）","text":"p2455才是高斯消元的真模板题好吧 高斯消元题面：传送门 对不起我真的是太懒了 先来明确高斯消元是干什么的： 高斯消元是一种求解线性方程组的方法。 所谓线性方程组，就是由$M$个$N$元一次方程组共同构成的。 线性方程组的所有系数可以写成一个$M$行$N$列的系数矩阵，再加上每个方程等号右侧的常数，可以写成一个$M$行$N+1$列的“增广矩阵”。 $\\begin{cases}x_1+2x_2-x_3=-6\\\\2x_1+x_2-3x_3=-9\\\\-x_1-x_2+2x_3=7\\end{cases}\\Rightarrow\\left[\\begin{array}{ccc|c}1 &amp;2&amp;-1&amp;-6\\\\2&amp;1&amp;-3&amp;-9\\\\-1&amp;-1&amp;2&amp;7 \\end{array}\\right]$​ 相信各位小学或者初中一定学过二元一次方程组吧 如果没学过那我觉得宁可以退役了 有个消元的方法相信你记忆犹新：加减消元法； 其实高斯消元法干的事情和加减消元法是差不多的； 步骤大概就是： 我们将一行加上另一行的若干倍，这样就可以消去其中一行的某一个系数； 我们可以来看一下下面的过程： $\\begin{bmatrix} 1&amp;2&amp;-1&amp;-6\\\\2&amp;1&amp;-3&amp;-9\\\\-1&amp;-1&amp;2&amp;7\\end{bmatrix}$​ 我们将第二行每一项分别加上第一行的$-2$倍，于是我们发现，第二行的第一项系数被消成$0$了。如下 $\\begin{bmatrix} 1&amp;2&amp;-1&amp;-6\\\\0&amp;-3&amp;-1&amp;3\\\\-1&amp;-1&amp;2&amp;7\\end{bmatrix}$​ 接下来我们都这么操作。 对于第$n$行，我们让该行的第$n$个元素作为“主元”，并且将其他行的同列的系数都消掉，最后我们可以得到下面的形式： $\\left[ \\begin{array}{ccc|c} 1&amp;0&amp;0&amp;1\\\\0&amp;1&amp;0&amp;-2\\\\0&amp;0&amp;1&amp;3 \\end{array}\\right]$​ 是的，成了这样以后，发现主对角线上的数和常数一般都不是$0$，其他位置都是$0$了（后面还有一些特殊情况与判定技巧），我们就可以愉快的写出答案： $x_1=1$，$x_2=-2$，$x_3=3$； 是的，这就是高斯消元算法。 但是在实际应用中，我们也许会碰到很多奇奇怪怪的情况。 就例如你只掌握上面说到的东西是远远不够通过这道题的。 题目中还有一些更高端的东西：什么时候有无穷多的实数解？什么时候无解？这都是我们需要考虑的； 首先，在高斯消元的过程中，可能出现$0=d$这样的方程，其中$d$是一个非零常数，这表明这些方程中出现了矛盾，方程组无解。 其次，我们也可能出现这样的情况： 我们高斯消元结束以后，发现某一行系数全都是$0$，并且常数也是$0$. 啊就是出现了$0==0$的情况？？ 是的，此时方程组有无数解，如下图： $\\left[ \\begin{array}{ccc|c} 1&amp;2&amp;0&amp;4\\\\0&amp;0&amp;1&amp;1\\\\0&amp;0&amp;0&amp;0 \\end{array}\\right]$​ 那么我们总结一下： 1.当高斯消元结束以后，如果存在系数全是$0$，但是常数不是$0$的行，那么方程组无解 2.在高斯消元结束以后，如果存在系数全是$0$，并且常数也是$0$的行，那么方程组有无数解 学会了这些就能通过这些题了吗？ 当然不是！ 还有一个东西你没有注意到：精度损失 精度损失是怎么来的?如何降低精度损失呢? 我们在加减消元的时候，有的时候需要加的也许不是一个整数，可能是某一行的几分之几倍。 于是，考虑到这，我们发现精度损失的原因了。 所以，我们就要让产生几分之几倍（确切的说：当式子一的系数是$a_1$，式子二的系数是$a_2$时，我们加的这个数就是$a_2/a_1$倍（注意我们主元系数是在分母上））的这个过程有较小的精度损失 我们可以思考一下，我们在消元的时候一定要刻意按照题目中给的顺序一行一行来嘛？ 也许可以不这样。 在什么情况下，我们能产生较小的精度损失呢？ 我们举个例子来看： 考虑这样的一个方程组： $1000x_1+ax_2+bx_3=c$;（这几个都是x不是乘号） $0.5x_1+dx_2+ex_3=f$ 我们设精度误差$eps=1e-8$； 如果我们选择$1000$作为主元， 那么理论值$ima_1=0.5/1000$ 实际值$rea_1=0.5+eps/1000+eps$ 误差值Δ在$rea_1-ima_1=$一个超级小的数 如果我们选择$0.5$作为主元，那么理论值$ima_2=1000/0.5$ 实际值$rea_2=1000+eps/0.5+eps$； 误差值Δ在$rea_2-ima_2=40$左右 发现差距了吗？？ 知道该怎么做了吗？？ 是的，我们每次选择较大的作为主元就好了！ 代码实现嘛，长这样的; double maxx;//最大值 int maxline;//最大值所在行 for(re int i=1;i&lt;=n;++i)&#123;//枚举每一列 maxx=0,maxline=i; for(re int j=1;j&lt;=n;++j)//枚举每一行的同一列位置 if(!vis[j]&amp;&amp;abs(a[j][i])&gt;maxx)&#123;//如果没来过并且很大（因为我们加的数正负都可以，所以我们取绝对值 maxx=abs(a[j][i]),maxline=j;//记录最大值以及所在的行数 &#125; //........ if(maxline!=i)swap(a[i],a[maxline]);//如果发现我们在消元过程中，这个位置不是需要的最大的，我们就把这一行和最大的那一行换一下位置 vis[i]=1;//来过了 &#125; 掌握了这些，这个题就可以$A$了 CODE： #include&lt;bits/stdc++.h&gt; using namespace std; #define re register const int N=105; const double eps=1e-8;//精度误差 double a[N][N];//矩阵 bool vis[N]; int n; inline int read()&#123; int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=x*10+ch-48;ch=getchar();&#125; return x*f; &#125; int main()&#123; n=read(); for(re int i=1;i&lt;=n;++i)&#123; for(re int j=1;j&lt;=n+1;++j)&#123;//读入矩阵，把常数也读进去所以是n+1 a[i][j]=read(); &#125; &#125; double maxx; int maxline; for(re int i=1;i&lt;=n;++i)&#123; maxx=0,maxline=i; for(re int j=1;j&lt;=n;++j) if(!vis[j]&amp;&amp;abs(a[j][i])&gt;maxx)maxx=abs(a[j][i]),maxline=j;//找最大的 if(maxx&lt;=eps)continue;//如果太小了，我们可以认为是0，并且把他跳过去，因为已经是0了不需要再操作 if(maxline!=i)swap(a[i],a[maxline]);//将系数最大的换到i行 vis[i]=1; for(re int j=1;j&lt;=n;++j)//对其他行关于i列进行消元 if(j!=i)&#123; double t=a[j][i]/a[i][i]; for(re int k=i;k&lt;=n+1;++k)&#123; a[j][k]-=t*a[i][k]; &#125; &#125; &#125; bool flag=0;//因为在消元完成后，只有主对角线上系数不是零，所以我们只需要检查一下，如果主对角线上出现了0的那一行的常数是不是0就可以了 for(re int i=1;i&lt;=n;++i) if(abs(a[i][i])&lt;=eps)&#123; flag=1;//如果发现主对角线上有0存在，那么一定出了特殊情况，要么是无解，要么是无穷解 abs(a[i][n+1])&gt;eps?puts(&quot;-1&quot;):puts(&quot;0&quot;);//如果常数不是零，那么可以认定就是无解，如果主对角线上有0，并且常数是0，那么就一定有无穷多解 return 0; &#125; for(re int i=1;i&lt;=n;i++)&#123;//不然我们就要输出每一项的解是多少 printf(&quot;x%d=%.2lf\\n&quot;,i,a[i][n+1]/a[i][i]);//这里解释一下，为什么要用常数除以系数：因为我们在消元以后，系数并不一定变成了1，也可能是其他的常数，那么就成了kx=b的形式，所以我们拿b/k就是x了 &#125; return 0; &#125;","path":"2021/02/18/p2455 线性方程组（高斯消元）/","date":"02-18","excerpt":"","tags":[]},{"title":"Huffman树（荷马史诗）","text":"hi 晚上好啊 今天讲了基本算法（基本听不懂的算法）—— ~~又被学长虐了呢~~~~~ 终于在下课前学长讲了一道能写得出来的题， 为了庆祝， 我们来写一篇博客。 $Huffman$树首先，我们来考虑这样一个问题： 构造一棵包含 $n$ 个叶子节点的 $k$ 叉树，其中第 $i$ 个叶子节点带有权值 $w_i$，要求最小化 $\\sum w_i * l_i$，其中 $l_i$ 表示第 $i$ 个叶子节点到根节点的距离。 该问题的解被称为 $k$ 叉 $Huffman$ 树（哈夫曼树） 为了最小化 $\\sum w_i * l_i$，应该让权值大的叶子节点的深度尽量小（这应该十分显然了）。 当 $k==2$ 时，我们就可以维护一个小根堆（出门左转合并果子） 对于 $k&gt;2 $的 $k$ 叉 $Huffman$ 树的求解，直观的想法是在贪心的基础上，改为每次取出最小的 $k$ 个权值。 然鹅，经过仔细思考，可以发现： 如果在执行最后一轮循环时，堆的大小在 $2-k$ 之间（也就是说，不足以取出 $k$ 个），那么整棵$Huffman$ 树的根的子节点数就小于 $k$。这显然不是最优解——我们取 $Huffman$ 树中任意一个深度最大的节点，把他改为树根的子节点，就会使 $\\sum w_i * l_i$ 变小。 因此，我们在执行贪心步骤之前，首先要补充一些额外的权值为 $0$ 的叶节点，使得叶节点的个数 $n$ 满足$(n-1)mod(k-1)==0$. 也就是说，我们让子节点不足k的情况发生在最底层，而不是在根结点处，在 $(n-1)mod(k-1)==0$ 时，执行“每次从堆中取出最小的 $k$ 个权值”的贪心思路是正确的。 那么，我们现在来看 $p2168$ 荷马史诗 其实看了上面的，题目自然就很显然了 啊淦为什么我也这么爱说显然了 那我们把单词出现的次数作为权值，然后直接构造 $k$ 叉 $Huffman$ 树，对于每个节点的第 $k$ 个分支，分别标记为 $0-k-1$； 下面我们需要一点跟 $trie$ 有关的东西 如果把这个 $Huffman $树看作是一颗 $trie$，那么就得到了总长度最小的编码方式——单词 $i$ 的编码就是从根节点到叶节点 $i$ 上各个字符相连（如果没学过 $trie$ 建议去看一看，反正也不难，一举两得）。 那么如何保证一个单词不是另一个单词的前缀呢？ 我们只需要保证，单词的结尾是叶子节点就好了啊（这是 $trie $的性质，如果一个串是另一个串的前缀的话，那么这个串的结尾一定还可以向后延伸，也就是可以经变长变为另一个更长的单词。） 如何保证 $s_i$ 最短呢？ 只需要在构造 $Huffman$ 树的时候，对于权值相同的节，我们优先合并当前深度小（也就是合并次数小的）即可。 CODE： #include&quot;bits/stdc++.h&quot; using namespace std; #define ll long long struct node&#123;//结构体，这个是节点，里面有两个域，分别是权值和当前深度（也就代表着合并次数） ll w,h; node(ll w,ll h):w(w),h(h)&#123;&#125;//构造函数赋初值 bool operator &lt; (const node &amp;a)const&#123;//我们重载小于号，使之成为一个优先按照权值大小排序，深度（即合并次数）为第二关键字的小根堆 return w==a.w?h&gt;a.h:w&gt;a.w; &#125; &#125;; ll ans;//答案 priority_queue &lt;node&gt; q;//小根堆 int main()&#123; ios::sync_with_stdio(false); ll n,k,ans=0; cin&gt;&gt;n&gt;&gt;k;//可以想一下，k进制代表每个数字都是不超过k-1的，那么我们可以联想到，这不就是k叉Huffman的k吗？ for(int i=1;i&lt;=n;i++)&#123; ll w; cin&gt;&gt;w;//我们把出现次数看成权值 q.push((node)&#123;w,1&#125;); &#125; while((q.size()-1)%(k-1)!=0)q.push((node)&#123;0,1&#125;);//判断是不是要补上空节点 while(q.size()&gt;=k)&#123;//合并操作 ll h=-1,w=0; for(int i=1;i&lt;=k;i//取出最小的k个 node t=q.top(); q.pop(); h=max(h,t.h); w+=t.w; &#125; ans+=w; q.push((node)&#123;w,h+1&#125;); &#125; cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;q.top().h-1&lt;&lt;endl; return 0; &#125;","path":"2021/02/05/Huffman树（荷马史诗）/","date":"02-05","excerpt":"","tags":[]},{"title":"Hexo-Theme-Sakura","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125; # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125; # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125; # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125; # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： &#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： &#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","path":"2018/12/12/Hexo-Theme-Sakura/","date":"12-12","excerpt":"","tags":[]},{"title":"图集","text":"这个页面是图集","path":"2018/05/28/图集/","date":"05-28","excerpt":"","tags":[{"name":"图集","slug":"图集","permalink":"https://lawrencesivan.github.io/tags/%E5%9B%BE%E9%9B%86/"}]},{"title":"转载","text":"这个页面用来存放转载","path":"2018/05/28/转载/","date":"05-28","excerpt":"","tags":[]},{"title":"随想","text":"这个页面用来存放随想","path":"2018/05/28/随想/","date":"05-28","excerpt":"","tags":[]},{"title":"资源","text":"这个页面用来存放资源","path":"2018/05/28/资源/","date":"05-28","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://lawrencesivan.github.io/tags/%E6%82%A6%E8%AF%BB/"},{"name":"图集","slug":"图集","permalink":"https://lawrencesivan.github.io/tags/%E5%9B%BE%E9%9B%86/"}]}